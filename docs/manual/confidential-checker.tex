\htmlhr
\chapterAndLabel{Confidential Checker}{confidential-checker}

The Confidential Checker identifies
\href{https://cwe.mitre.org/data/definitions/1417.html}{sensitive information
exposure}, also known as information leakage. An information leak occurs when private information
such as PII (personally identifiable information), passwords, or local file
paths is revealed.  Information is revealed by being passed to
a public-facing sink, such as website and app user interfaces,
log files, error messages, and URL targets.

The Confidential Checker guarantees that no values marked as
\emph{confidential} flow to a location marked as
\emph{non-confidential}.

It is the responsibility of the user to annotate sources and sinks as
confidential or non-confidential.
Since \code{@NonConfidential} is the default annotation, if a programmer
forgets to annotate a sensitive source as \<@Confidential>, then there will
be an information leak that the Confidential Checker cannot warn about.
Once sources and sinks are annotated, the Confidential
Checker guarantees that any other annotations in the program are consistent
with those annotations, and that no information flows from confidential to
non-confidential locations.

The confidential checker does not identify \emph{indirect} information flows, such
as in:

\begin{Verbatim}
  // Information is leaked, but the Confidential Checker issues no error.
  @Confidential boolean secret = ...;
  @NonConfidential boolean revealed;
  if (secret) {
    revealed = true;
  } else {
    revealed = false;
  }
\end{Verbatim}

Exposure may occur mistakenly --- in which case
it should be fixed --- or with a benign objective in mind, such as when
logging to aid troubleshooting.  After the Confidential Checker reveals a
leak, it is up to the user to decide whether the leakage is acceptable.

To run the Confidential Checker, supply one of these
command-line options to javac:
\begin{Verbatim}
-processor ConfidentialChecker
-processor org.checkerframework.checker.confidential.ConfidentialChecker
\end{Verbatim}


\sectionAndLabel{Confidential annotations}{confidential-annotations}

The Confidential Checker type system uses the following type qualifiers;
their subtyping hierarchy is shown in
Figure~\ref{fig-confidential-hierarchy}.

\begin{description}
\item[\refqualclass{checker/confidential/qual}{Confidential}]
    An expression whose type is qualified with
    \refqualclass{checker/confidential/qual}{Confidential} may evaluate to
    a value that should not be exposed.
\item[\refqualclass{checker/confidential/qual}{NonConfidential}]
    The value of an expression of type
    \refqualclass{checker/confidential/qual}{NonConfidential} might be
    exposed.  It is written on the formal parameter type of a method such
    as \<println> that may leak its argument.  It is the default qualifier.
\item[\refqualclass{checker/confidential/qual}{UnknownConfidential}]
    indicates a value whose confidentiality is unknown.
    \code{@UnknownConfidential} is a supertype of \code{@Confidential}
    and \code{@NonConfidential}.
\item[\refqualclass{checker/confidential/qual}{PolyConfidential}]
    indicates qualifier polymorphism. For a description of qualifier polymorphism,
    see Section~\ref{method-qualifier-polymorphism}.
\item[\refqualclass{checker/confidential/qual}{BottomConfidential}]
    is the bottom qualifier. Programmers rarely need to write it.
\end{description}


\begin{figure}
\includeimage{confidential}{5.5cm}
\caption{The subtyping relationship of the Confidential Checker's qualifiers.
  Qualifiers in gray are used internally by the type system and should rarely
  be written by a programmer.}
\label{fig-confidential-hierarchy}
\end{figure}

The Confidential Checker's
\code{@Confidential} qualifier has similarities to the Taint Checker's \code{@Tainted}
qualifier.  One difference is that
there is no subtyping relationship between \code{@Confidential} and
\code{@NonConfidential}. However, the external behavior of these annotations
can strongly resemble that of a supertype and subtype, as casts from the latter
to the former are always permitted (see Section~\ref{confidential-checks}). As
a result, while the Confidential Checker (correctly) does not allow
\code{@Confidential} values to flow to \code{@NonConfidential} sinks, it does
allow \code{@NonConfidential} values in \code{@Confidential} sinks.

\sectionAndLabel{Concatenation}{confidential-concatenation}

Concatenation of \code{@Confidential} and \code{@NonConfidential} values is
always dominated by \code{@Confidential}. In other words, concatenation of
\code{@Confidential} and \code{@NonConfidential} values are most narrowly typed
as follows:

\begin{Verbatim}
    @Confidential + @Confidential = @Confidential
    @Confidential + @NonConfidential = @Confidential
    @NonConfidential + @Confidential = @Confidential
    @NonConfidential + @NonConfidential = @NonConfidential
\end{Verbatim}

However, casts of any type in the Confidential hierarchy to \code{@Confidential}
are always allowed as they do not pose a risk of sensitive information exposure:
\code{@NonConfidential} to \code{@Confidential} casts only increase stringency,
while \code{@UnknownConfidential} is subtyped by \code{@Confidential},
\code{@NonConfidential} and can thus be safely cast. This allowance was motivated
by a high percentage of \code{@SuppressWarnings} annotations being written to allow
casts from \code{@NonConfidential} to \code{@Confidential}.

\sectionAndLabel{Library annotations}{confidential-library-annotations}

The Confidential Checker provides annotations for certain public-facing
sinks.  For instance, methods in Android's \code{TextView} class have a
formal parameter of type \code{@NonConfidential CharSequence}, indicating
that they display the argument on the user's viewport.  The Confidential
Checker will issue a type error if a \<@Confidential> value can be passed
to such functions.

The built-in annotations appear in the Checker
Framework's annotated JDK and in stub files in directory
\<checker/src/main/java/org/checkerframework/checker/confidential/>.
A developer can write more annotations in stub files
(\chapterpageref{stub}), especially for libraries that do not already have
annotations.  (Please share these with the Checker Framework developers, so
that they can distribute them to all users.)

If a program contains a method that tests whether a run-time value is
confidential, use annotation
\refqualclass{framework/qual}{EnsuresQualifierIf} (\chapterpageref{type-refinement}).

If a program contains a method that takes a possibly-confidential argument
and returns a non-confidential result, then suppress the warning
(\chapterpageref{suppressing-warnings}) after manually validating the
method's behavior.
