\chapterAndLabel{Modifiable Checker}{modifiable-checker}

The Modifiable Checker warns, at compile time, if a program might throw
\<UnsupportedOperationException> at run time due to calling a mutating method
on an unmodifiable collection.

\sectionAndLabel{Modifiable annotations}{modifiable-annotations}

The Modifiable Checker uses these qualifiers:

\begin{description}
\item[\refqualclass{checker/modifiable/qual}{Modifiable}]
  indicates that the annotated collection supports mutating operations such as
  \<add()> and \<remove()> without throwing \<UnsupportedOperationException>.
  This is the top qualifier and the default.

\item[\refqualclass{checker/modifiable/qual}{Unmodifiable}]
  indicates that the annotated collection does not support mutating operations.
  Calling methods like \<add()> or \<remove()> on such collections will throw
  \<UnsupportedOperationException> at runtime. This is the bottom qualifier.
\end{description}

\sectionAndLabel{What the Modifiable Checker guarantees}{modifiable-guarantees}

If the Modifiable Checker issues no warnings for a given program, then the
program will never throw \<UnsupportedOperationException> due to calling
mutating methods on unmodifiable collections.

More specifically, the checker guarantees that:
\begin{itemize}
\item Mutating methods (such as \<add()>, \<remove()>, \<clear()>, etc.) are
      only called on collections that are known to be modifiable.
\item Collections returned by methods that create unmodifiable collections
      are properly tracked as \<@Unmodifiable>.
\item The modifiability property is preserved through method calls and
      assignments.
\end{itemize}

\sectionAndLabel{Modifiable inference}{modifiable-inference}}

The Modifiable Checker automatically infers \<@Unmodifiable> for collections
returned by these methods:

\subsectionAndLabel{List methods}{modifiable-list-methods}
\begin{itemize}
\item \<List.of()> and its overloaded variants
\item \<List.copyOf(Collection)>
\item \<Collections.emptyList()>
\item \<Collections.unmodifiableList(List)>
\end{itemize}

\subsectionAndLabel{Set methods}{modifiable-set-methods}
\begin{itemize}
\item \<Set.of()> and its overloaded variants
\item \<Set.copyOf(Collection)>
\item \<Collections.emptySet()>
\item \<Collections.unmodifiableSet(Set)>
\end{itemize}

\subsectionAndLabel{Map methods}{modifiable-map-methods}
\begin{itemize}
\item \<Map.of()> and its overloaded variants
\item \<Map.copyOf(Map)>
\item \<Collections.emptyMap()>
\item \<Collections.unmodifiableMap(Map)>
\end{itemize}

All other collections are inferred to be \<@Modifiable> by default.

\sectionAndLabel{Modifiable annotations in practice}{modifiable-examples}

\subsectionAndLabel{Basic usage}{modifiable-basic-usage}

The Modifiable Checker will issue warnings when mutating methods are called
on unmodifiable collections:

\begin{Verbatim}
List<String> immutableList = List.of("a", "b", "c");
immutableList.add("d");  // Warning: calling add() on @Unmodifiable collection

List<String> mutableList = new ArrayList<>();
mutableList.add("d");    // OK: ArrayList is @Modifiable by default
\end{Verbatim}

\subsectionAndLabel{Method parameters and return types}{modifiable-signatures}

You can explicitly annotate method parameters and return types to document
and enforce modifiability requirements:

\begin{Verbatim}
public void processItems(@Modifiable List<String> items) {
    items.add("processed");  // OK: parameter is explicitly @Modifiable
}

public @Unmodifiable List<String> getImmutableData() {
    return List.of("data1", "data2");  // OK: matches return type
}

public @Unmodifiable List<String> getBadData() {
    return new ArrayList<>();  // Warning: @Modifiable assigned to @Unmodifiable
}
\end{Verbatim}

\subsectionAndLabel{Collections utility methods}{modifiable-collections-methods}

The checker understands the semantics of \<Collections> utility methods:

\begin{Verbatim}
List<String> original = new ArrayList<>();
List<String> wrapper = Collections.unmodifiableList(original);
wrapper.add("item");     // Warning: calling add() on @Unmodifiable collection

Set<Integer> emptySet = Collections.emptySet();
emptySet.add(42);        // Warning: calling add() on @Unmodifiable collection
\end{Verbatim}

\subsectionAndLabel{Avoiding false positives}{modifiable-avoid-false-positives}

In some cases, you may know that a collection is modifiable even though the
checker cannot prove it. You can use explicit annotations or suppression:

\begin{Verbatim}
// If you know the collection is modifiable
@SuppressWarnings("modifiable")
someUnknownCollection.add("item");

// Or cast to @Modifiable if you're certain
((@Modifiable List<String>) someCollection).add("item");
\end{Verbatim}

\sectionAndLabel{Suppressing warnings}{modifiable-suppressing}

You can suppress Modifiable Checker warnings using the standard
\<@SuppressWarnings> annotation with the argument \<"modifiable">:

\begin{Verbatim}
@SuppressWarnings("modifiable")
public void methodThatModifiesUnknownCollection(List<String> list) {
    list.add("item");  // Warning suppressed
}
\end{Verbatim}

\sectionAndLabel{Running the Modifiable Checker}{modifiable-running}}

To run the Modifiable Checker, use the \<-processor> command-line option:

\begin{Verbatim}
javac -processor checker.modifiable.ModifiableChecker MyFile.java
\end{Verbatim}

Or add it to your build configuration. For Maven:

\begin{Verbatim}
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <annotationProcessors>
      <annotationProcessor>checker.modifiable.ModifiableChecker</annotationProcessor>
    </annotationProcessors>
  </configuration>
</plugin>
\end{Verbatim}

\sectionAndLabel{Common patterns and idioms}{modifiable-patterns}

\subsectionAndLabel{Defensive copying}{modifiable-defensive-copying}

When you need a modifiable copy of an unmodifiable collection:

\begin{Verbatim}
@Unmodifiable List<String> immutable = List.of("a", "b");
@Modifiable List<String> mutable = new ArrayList<>(immutable);
mutable.add("c");  // OK: mutable is explicitly @Modifiable
\end{Verbatim}

\subsectionAndLabel{Builder patterns}{modifiable-builder-pattern}

Builders typically work with modifiable collections internally:

\begin{Verbatim}
public class DataBuilder {
    private final @Modifiable List<String> items = new ArrayList<>();

    public DataBuilder add(String item) {
        items.add(item);  // OK: items is @Modifiable
        return this;
    }

    public @Unmodifiable List<String> build() {
        return List.copyOf(items);  // Returns @Unmodifiable copy
    }
}
\end{Verbatim}

\sectionAndLabel{Limitations}{modifiable-limitations}

The Modifiable Checker has these limitations:

\begin{itemize}
\item Collection views (such as
      \<List.subList()> or \<Map.keySet()>) are conservatively
      treated as having the same modifiability as their parent.
\item Reflection-based collection modifications are not checked.
\end{itemize}
