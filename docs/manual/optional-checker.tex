\htmlhr
\chapter{Optional Checker for the \<Optional> type that represents possibly-present data\label{optional-checker}}

Java 8 introduced the \sunjavadoc{java/lang/Optional.html}{Optional}
class, a container that is either empty or contains a non-null value.

Using \<Optional> is intended to help programmers remember to check whether
data is present or not.  However, \<Optional> itself is prone to misuse.
The article
\href{https://homes.cs.washington.edu/~mernst/advice/nothing-is-better-than-optional.html}{Nothing
  is better than the \<Optional> type} explains why you may wish to use
regular nullable references rather than \<Optional>.  However, if you do use
\<Optional>, then the Optional Checker will help you avoid some of
\<Optional>'s pitfalls.

Stuart Marks gave
\href{https://stuartmarks.wordpress.com/2016/09/27/vjug24-session-on-optional/}{7
  rules} to avoid problems with Optional:
\begin{enumerate}
\item
  Never, ever, use null for an Optional variable or return value.
\item
  Never use Optional.get() unless you can prove that the Optional is present.
\item
  Prefer alternative APIs over Optional.isPresent() and Optional.get().
\item
  It’s generally a bad idea to create an Optional for the specific purpose of chaining methods from it to get a value.
\item
  If an Optional chain has a nested Optional chain, or has an intermediate result of Optional, it’s probably too complex.
\item
  Avoid using Optional in fields, method parameters, and collections.
\item
  Don’t use an Optional to wrap any collection type (List, Set, Map).
  Instead, use an empty collection to represent the absence of values.
\end{enumerate}

Rule \#1 is guaranteed by the Nullness Checker
(\chapterpageref{nullness-checker}).
Rule \#2 is guaranteed by the Optional Checker, described in this chapter..
Rules \#3-\#7 may be checked by the Optional Checker in the future.


\section{Optional Regex annotations\label{regex-annotations}}

These qualifiers make up the Regex type system:

\begin{description}

% alternate name: PossiblyAbsent.  But, the Optional Javadoc is careful
% never to use the term "absent", and it's nice parallelism to have
% "Present" in the names of all the annotations.
\item[\refqualclass{checker/optional/qual}{MaybePresent}]
  The annotated \<Optional> container may or may not contain a value.
  This is the default type.

\item[\refqualclass{checker/optional/qual}{Present}]
  The annotated \<Optional> container definitely contains a (non-null) value.

\item[\refqualclass{checker/optional/qual}{PolyPresent}]
  indicates qualifier polymorphism (see Section~\ref{qualifier-polymorphism}).

\end{description}

The subtyping hierarchy of the Regex Checker's qualifiers is shown in
Figure~\ref{fig-regex-hierarchy}.

\begin{figure}
\includeimage{optional-subtyping}{9cm}
\caption{The subtyping relationship of the Optional Checker's qualifiers.}
\label{fig-optional-hierarchy}
\end{figure}


\section{Annotating your code with \code{@Regex}\label{annotating-with-regex}}


\subsection{Implicit qualifiers\label{regex-implicit-qualifiers}}

As described in Section~\ref{effective-qualifier}, the Regex Checker adds
implicit qualifiers, reducing the number of annotations that must appear
in your code. The checker implicitly adds the \code{Regex} qualifier with
the parameter set to the correct number of capturing groups to
any \code{String} literal that is a valid regex. The Regex Checker allows
the \code{null} literal to be assigned to any type qualified with the
\code{Regex} qualifier.


\subsection{Capturing groups\label{regex-capturing-groups}}

The Regex Checker validates that a legal capturing group number is passed
to \sunjavadoc{java/util/regex/Matcher.html}{Matcher}'s
\sunjavadoc{java/util/regex/Matcher.html\#group-int-}{group},
\sunjavadoc{java/util/regex/Matcher.html\#start-int-}{start} and
\sunjavadoc{java/util/regex/Matcher.html\#end-int-}{end} methods. To do this,
the type of \<Matcher> must be qualified with a \<@Regex> annotation
with the number of capturing groups in the regular expression. This is
handled implicitly by the Regex Checker for local variables (see
Section~\ref{type-refinement}), but you may need to add \<@Regex> annotations
with a capturing group count to \<Pattern> and \<Matcher> fields and
parameters.


\subsection{Concatenation of partial regular expressions\label{regex-partial-regex}}

\begin{figure}
\begin{Verbatim}
public @Regex String parenthesize(@Regex String regex) {
    return "(" + regex + ")"; // Even though the parentheses are not @Regex Strings,
                              // the whole expression is a @Regex String
}
\end{Verbatim}
\caption{An example of the Regex Checker's support for concatenation
of non-regular-expression Strings to produce valid regular expression Strings.}
\label{fig-regex-partial}
\end{figure}

In general, concatenating a non-regular-expression String with any other
string yields a non-regular-expression String.  The Regex Checker can
sometimes determine that concatenation of non-regular-expression Strings
will produce valid regular expression Strings. For an example see
Figure~\ref{fig-regex-partial}.


\subsection{Testing whether a string is a regular expression\label{regexutil-methods}}

Sometimes, the Regex Checker cannot infer whether a particular expression
is a regular expression --- and sometimes your code cannot either!  In
these cases, you can use the \<isRegex> method to perform such a test, and
other helper methods to provide useful error messages.  A
common use is for user-provided regular expressions (such as ones passed
on the command-line).
Figure~\ref{fig-regex-util-example} gives an
example of the intended use of the \code{RegexUtil} methods.

\begin{description}

\item[\refmethod{checker/regex}{RegexUtil}{isRegex}{-java.lang.String-}]
  returns \<true> if its argument is a valid regular expression.

\item[\refmethod{checker/regex}{RegexUtil}{regexError}{-java.lang.String-}]
  returns a \<String> error message if its argument is not a valid regular
  expression, or \<null> if its argument is a valid regular expression.

\item[\refmethod{checker/regex}{RegexUtil}{regexException}{-java.lang.String-}]
  returns the
  \sunjavadoc{java/util/regex/PatternSyntaxException.html}{Pattern\-Syntax\-Exception}
  that \sunjavadoc{java/util/regex/Pattern.html\#compile-java.lang.String-}{Pattern.compile(String)}
  throws when compiling an invalid regular expression.  It returns \<null>
  if its argument is a valid regular expression.

\end{description}

An additional version of each of these methods is also provided that takes
an additional group count parameter. The
\refmethod{checker/regex}{RegexUtil}{isRegex}{-java.lang.String-int-} method
verifies that the argument has at least the given number of groups. The
\refmethod{checker/regex}{RegexUtil}{regexError}{-java.lang.String-int-} and
\refmethod{checker/regex}{RegexUtil}{regexException}{-java.lang.String-int-}
methods return a \<String> error message and \<Pattern\-Syntax\-Exception>,
respectively, detailing why the given String is not a syntactically valid
regular expression with at least the given number of capturing groups.

\begin{sloppypar}
If you detect that a \<String> is not a valid regular expression but would like
to report the error higher up the call stack (potentially where you can
provide a more detailed error message) you can throw a
\refclass{checker/regex}{RegexUtil.CheckedPatternSyntaxException}. This exception is
functionally the same as a
\sunjavadoc{java/util/regex/PatternSyntaxException.html}{Pattern\-Syntax\-Exception}
except it is checked to guarantee that the error will be handled up the
call stack.  For more details, see the Javadoc for
\refclass{checker/regex}{RegexUtil.CheckedPatternSyntaxException}.
\end{sloppypar}

A potential disadvantage of using the \<RegexUtil> class is that your code becomes
dependent on the Checker Framework at run time as well as at compile time.
That is, the \<checker.jar> or \<checker-qual.jar> file
must be on the classpath at run time.
You can avoid this by
copying the \<RegexUtil> class into
your own code.

\begin{figure}
%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
String regex = getRegexFromUser();
if (! RegexUtil.isRegex(regex)) {
   throw new RuntimeException("Error parsing regex " + regex, RegexUtil.regexException(regex));
}
Pattern p = Pattern.compile(regex);
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX
\caption{Example use of \code{RegexUtil} methods.}
\label{fig-regex-util-example}
\end{figure}

\subsection{Suppressing warnings\label{regex-suppressing-warnings}}

If you are positive that a particular string that is being used as a
regular expression is syntactically valid, but the Regex Checker cannot
conclude this and issues a warning about possible use of an invalid regular
expression, then you can use the
\refmethod{checker/regex}{RegexUtil}{asRegex}{-java.lang.String-} method to suppress the
warning.

You can think of this method
as a cast:  it returns its argument unchanged, but with the type
\code{@Regex String} if it is a valid regular expression.  It throws an
error if its argument is not a valid regular expression, but you should
only use it when you are sure it will not throw an error.

There is an additional \refmethod{checker/regex}{RegexUtil}{asRegex}{-java.lang.String-int-}
method that takes a capturing group parameter. This method works the same as
described above, but returns a \code{@Regex String} with the parameter on the
annotation set to the value of the capturing group parameter passed to the method.

The use case shown in Figure~\ref{fig-regex-util-example} should support most cases
so the \<asRegex> method should be used rarely.




% LocalWords:  Regex regex quals PolyRegex isRegex RegexUtil regexError asRegex
% LocalWords:  regexException PatternSyntaxException Matcher java
%  LocalWords:  CheckedPatternSyntaxException colo colou
