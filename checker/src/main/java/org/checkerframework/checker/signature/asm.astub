import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.checker.signature.qual.FullyQualifiedName;
import org.checkerframework.checker.signature.qual.Identifier;
import org.checkerframework.checker.signature.qual.InternalForm;

package org.objectweb.asm.tree.analysis;

import java.util.List;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MultiANewArrayInsnNode;
import org.objectweb.asm.tree.TypeInsnNode;

/**
 * An {@link Interpreter} for {@link BasicValue} values.
 *
 * @author Eric Bruneton
 * @author Bing Ran
 */
public class BasicInterpreter extends Interpreter<BasicValue> implements Opcodes {

  /**
   * Special type used for the {@literal null} literal. This is an object reference type with
   * descriptor 'Lnull;'.
   */
  public static final Type NULL_TYPE = Type.getObjectType("null");

  /**
   * Constructs a new {@link BasicInterpreter} for the latest ASM API version. <i>Subclasses must
   * not use this constructor</i>. Instead, they must use the {@link #BasicInterpreter(int)}
   * version.
   */
  public BasicInterpreter() {
    super(/* latest api = */ ASM9);
    if (getClass() != BasicInterpreter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link BasicInterpreter}.
   *
   * @param api the ASM API version supported by this interpreter. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected BasicInterpreter(final int api) {
    super(api);
  }

  @Override
  public BasicValue newValue(final Type type) {
    if (type == null) {
      return BasicValue.UNINITIALIZED_VALUE;
    }
    switch (type.getSort()) {
      case Type.VOID:
        return null;
      case Type.BOOLEAN:
      case Type.CHAR:
      case Type.BYTE:
      case Type.SHORT:
      case Type.INT:
        return BasicValue.INT_VALUE;
      case Type.FLOAT:
        return BasicValue.FLOAT_VALUE;
      case Type.LONG:
        return BasicValue.LONG_VALUE;
      case Type.DOUBLE:
        return BasicValue.DOUBLE_VALUE;
      case Type.ARRAY:
      case Type.OBJECT:
        return BasicValue.REFERENCE_VALUE;
      default:
        throw new AssertionError();
    }
  }

  @Override
  public BasicValue newOperation(final AbstractInsnNode insn) throws AnalyzerException {
    switch (insn.getOpcode()) {
      case ACONST_NULL:
        return newValue(NULL_TYPE);
      case ICONST_M1:
      case ICONST_0:
      case ICONST_1:
      case ICONST_2:
      case ICONST_3:
      case ICONST_4:
      case ICONST_5:
        return BasicValue.INT_VALUE;
      case LCONST_0:
      case LCONST_1:
        return BasicValue.LONG_VALUE;
      case FCONST_0:
      case FCONST_1:
      case FCONST_2:
        return BasicValue.FLOAT_VALUE;
      case DCONST_0:
      case DCONST_1:
        return BasicValue.DOUBLE_VALUE;
      case BIPUSH:
      case SIPUSH:
        return BasicValue.INT_VALUE;
      case LDC:
        Object value = ((LdcInsnNode) insn).cst;
        if (value instanceof Integer) {
          return BasicValue.INT_VALUE;
        } else if (value instanceof Float) {
          return BasicValue.FLOAT_VALUE;
        } else if (value instanceof Long) {
          return BasicValue.LONG_VALUE;
        } else if (value instanceof Double) {
          return BasicValue.DOUBLE_VALUE;
        } else if (value instanceof String) {
          return newValue(Type.getObjectType("java/lang/String"));
        } else if (value instanceof Type) {
          int sort = ((Type) value).getSort();
          if (sort == Type.OBJECT || sort == Type.ARRAY) {
            return newValue(Type.getObjectType("java/lang/Class"));
          } else if (sort == Type.METHOD) {
            return newValue(Type.getObjectType("java/lang/invoke/MethodType"));
          } else {
            throw new AnalyzerException(insn, "Illegal LDC value " + value);
          }
        } else if (value instanceof Handle) {
          return newValue(Type.getObjectType("java/lang/invoke/MethodHandle"));
        } else if (value instanceof ConstantDynamic) {
          return newValue(Type.getType(((ConstantDynamic) value).getDescriptor()));
        } else {
          throw new AnalyzerException(insn, "Illegal LDC value " + value);
        }
      case JSR:
        return BasicValue.RETURNADDRESS_VALUE;
      case GETSTATIC:
        return newValue(Type.getType(((FieldInsnNode) insn).desc));
      case NEW:
        return newValue(Type.getObjectType(((TypeInsnNode) insn).desc));
      default:
        throw new AssertionError();
    }
  }

  @Override
  public BasicValue copyOperation(final AbstractInsnNode insn, final BasicValue value)
      throws AnalyzerException {
    return value;
  }

  @Override
  public BasicValue unaryOperation(final AbstractInsnNode insn, final BasicValue value)
      throws AnalyzerException {
    switch (insn.getOpcode()) {
      case INEG:
      case IINC:
      case L2I:
      case F2I:
      case D2I:
      case I2B:
      case I2C:
      case I2S:
        return BasicValue.INT_VALUE;
      case FNEG:
      case I2F:
      case L2F:
      case D2F:
        return BasicValue.FLOAT_VALUE;
      case LNEG:
      case I2L:
      case F2L:
      case D2L:
        return BasicValue.LONG_VALUE;
      case DNEG:
      case I2D:
      case L2D:
      case F2D:
        return BasicValue.DOUBLE_VALUE;
      case IFEQ:
      case IFNE:
      case IFLT:
      case IFGE:
      case IFGT:
      case IFLE:
      case TABLESWITCH:
      case LOOKUPSWITCH:
      case IRETURN:
      case LRETURN:
      case FRETURN:
      case DRETURN:
      case ARETURN:
      case PUTSTATIC:
        return null;
      case GETFIELD:
        return newValue(Type.getType(((FieldInsnNode) insn).desc));
      case NEWARRAY:
        switch (((IntInsnNode) insn).operand) {
          case T_BOOLEAN:
            return newValue(Type.getType("[Z"));
          case T_CHAR:
            return newValue(Type.getType("[C"));
          case T_BYTE:
            return newValue(Type.getType("[B"));
          case T_SHORT:
            return newValue(Type.getType("[S"));
          case T_INT:
            return newValue(Type.getType("[I"));
          case T_FLOAT:
            return newValue(Type.getType("[F"));
          case T_DOUBLE:
            return newValue(Type.getType("[D"));
          case T_LONG:
            return newValue(Type.getType("[J"));
          default:
            break;
        }
        throw new AnalyzerException(insn, "Invalid array type");
      case ANEWARRAY:
        return newValue(Type.getType("[" + Type.getObjectType(((TypeInsnNode) insn).desc)));
      case ARRAYLENGTH:
        return BasicValue.INT_VALUE;
      case ATHROW:
        return null;
      case CHECKCAST:
        return newValue(Type.getObjectType(((TypeInsnNode) insn).desc));
      case INSTANCEOF:
        return BasicValue.INT_VALUE;
      case MONITORENTER:
      case MONITOREXIT:
      case IFNULL:
      case IFNONNULL:
        return null;
      default:
        throw new AssertionError();
    }
  }

  @Override
  public BasicValue binaryOperation(
      final AbstractInsnNode insn, final BasicValue value1, final BasicValue value2)
      throws AnalyzerException {
    switch (insn.getOpcode()) {
      case IALOAD:
      case BALOAD:
      case CALOAD:
      case SALOAD:
      case IADD:
      case ISUB:
      case IMUL:
      case IDIV:
      case IREM:
      case ISHL:
      case ISHR:
      case IUSHR:
      case IAND:
      case IOR:
      case IXOR:
        return BasicValue.INT_VALUE;
      case FALOAD:
      case FADD:
      case FSUB:
      case FMUL:
      case FDIV:
      case FREM:
        return BasicValue.FLOAT_VALUE;
      case LALOAD:
      case LADD:
      case LSUB:
      case LMUL:
      case LDIV:
      case LREM:
      case LSHL:
      case LSHR:
      case LUSHR:
      case LAND:
      case LOR:
      case LXOR:
        return BasicValue.LONG_VALUE;
      case DALOAD:
      case DADD:
      case DSUB:
      case DMUL:
      case DDIV:
      case DREM:
        return BasicValue.DOUBLE_VALUE;
      case AALOAD:
        return BasicValue.REFERENCE_VALUE;
      case LCMP:
      case FCMPL:
      case FCMPG:
      case DCMPL:
      case DCMPG:
        return BasicValue.INT_VALUE;
      case IF_ICMPEQ:
      case IF_ICMPNE:
      case IF_ICMPLT:
      case IF_ICMPGE:
      case IF_ICMPGT:
      case IF_ICMPLE:
      case IF_ACMPEQ:
      case IF_ACMPNE:
      case PUTFIELD:
        return null;
      default:
        throw new AssertionError();
    }
  }

  @Override
  public BasicValue ternaryOperation(
      final AbstractInsnNode insn,
      final BasicValue value1,
      final BasicValue value2,
      final BasicValue value3)
      throws AnalyzerException {
    return null;
  }

  @Override
  public BasicValue naryOperation(
      final AbstractInsnNode insn, final List<? extends BasicValue> values)
      throws AnalyzerException {
    int opcode = insn.getOpcode();
    if (opcode == MULTIANEWARRAY) {
      return newValue(Type.getType(((MultiANewArrayInsnNode) insn).desc));
    } else if (opcode == INVOKEDYNAMIC) {
      return newValue(Type.getReturnType(((InvokeDynamicInsnNode) insn).desc));
    } else {
      return newValue(Type.getReturnType(((MethodInsnNode) insn).desc));
    }
  }

  @Override
  public void returnOperation(
      final AbstractInsnNode insn, final BasicValue value, final BasicValue expected)
      throws AnalyzerException {
    // Nothing to do.
  }

  @Override
  public BasicValue merge(final BasicValue value1, final BasicValue value2) {
    if (!value1.equals(value2)) {
      return BasicValue.UNINITIALIZED_VALUE;
    }
    return value1;
  }
}

package org.objectweb.asm.tree.analysis;

import org.objectweb.asm.tree.AbstractInsnNode;

/**
 * An exception thrown if a problem occurs during the analysis of a method.
 *
 * @author Bing Ran
 * @author Eric Bruneton
 */
public class AnalyzerException extends Exception {

  private static final long serialVersionUID = 3154190448018943333L;

  /** The bytecode instruction where the analysis failed. */
  public final transient AbstractInsnNode node;

  /**
   * Constructs a new {@link AnalyzerException}.
   *
   * @param insn the bytecode instruction where the analysis failed.
   * @param message the reason why the analysis failed.
   */
  public AnalyzerException(final AbstractInsnNode insn, final String message) {
    super(message);
    this.node = insn;
  }

  /**
   * Constructs a new {@link AnalyzerException}.
   *
   * @param insn the bytecode instruction where the analysis failed.
   * @param message the reason why the analysis failed.
   * @param cause the cause of the failure.
   */
  public AnalyzerException(
      final AbstractInsnNode insn, final String message, final Throwable cause) {
    super(message, cause);
    this.node = insn;
  }

  /**
   * Constructs a new {@link AnalyzerException}.
   *
   * @param insn the bytecode instruction where the analysis failed.
   * @param message the reason why the analysis failed.
   * @param expected an expected value.
   * @param actual the actual value, different from the expected one.
   */
  public AnalyzerException(
      final AbstractInsnNode insn,
      final String message,
      final Object expected,
      final Value actual) {
    super(
        (message == null ? "Expected " : message + ": expected ")
            + expected
            + ", but found "
            + actual);
    this.node = insn;
  }
}

package org.objectweb.asm.tree.analysis;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.IincInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.TryCatchBlockNode;
import org.objectweb.asm.tree.VarInsnNode;

/**
 * A semantic bytecode analyzer. <i>This class does not fully check that JSR and RET instructions
 * are valid.</i>
 *
 * @param <V> type of the {@link Value} used for the analysis.
 * @author Eric Bruneton
 */
public class Analyzer<V extends Value> implements Opcodes {

  /** The interpreter to use to symbolically interpret the bytecode instructions. */
  private final Interpreter<V> interpreter;

  /** The instructions of the currently analyzed method. */
  private InsnList insnList;

  /** The size of {@link #insnList}. */
  private int insnListSize;

  /** The exception handlers of the currently analyzed method (one list per instruction index). */
  private List<TryCatchBlockNode>[] handlers;

  /** The execution stack frames of the currently analyzed method (one per instruction index). */
  private Frame<V>[] frames;

  /** The subroutines of the currently analyzed method (one per instruction index). */
  private Subroutine[] subroutines;

  /** The instructions that remain to process (one boolean per instruction index). */
  private boolean[] inInstructionsToProcess;

  /** The indices of the instructions that remain to process in the currently analyzed method. */
  private int[] instructionsToProcess;

  /** The number of instructions that remain to process in the currently analyzed method. */
  private int numInstructionsToProcess;

  /**
   * Constructs a new {@link Analyzer}.
   *
   * @param interpreter the interpreter to use to symbolically interpret the bytecode instructions.
   */
  public Analyzer(final Interpreter<V> interpreter) {
    this.interpreter = interpreter;
  }

  /**
   * Analyzes the given method.
   *
   * @param owner the internal name of the class to which 'method' belongs (see {@link
   *     Type#getInternalName()}).
   * @param method the method to be analyzed. The maxStack and maxLocals fields must have correct
   *     values.
   * @return the symbolic state of the execution stack frame at each bytecode instruction of the
   *     method. The size of the returned array is equal to the number of instructions (and labels)
   *     of the method. A given frame is {@literal null} if and only if the corresponding
   *     instruction cannot be reached (dead code).
   * @throws AnalyzerException if a problem occurs during the analysis.
   */
  @SuppressWarnings("unchecked")
  public Frame<V>[] analyze(final @InternalForm String owner, final MethodNode method) throws AnalyzerException {
    if ((method.access & (ACC_ABSTRACT | ACC_NATIVE)) != 0) {
      frames = (Frame<V>[]) new Frame<?>[0];
      return frames;
    }
    insnList = method.instructions;
    insnListSize = insnList.size();
    handlers = (List<TryCatchBlockNode>[]) new List<?>[insnListSize];
    frames = (Frame<V>[]) new Frame<?>[insnListSize];
    subroutines = new Subroutine[insnListSize];
    inInstructionsToProcess = new boolean[insnListSize];
    instructionsToProcess = new int[insnListSize];
    numInstructionsToProcess = 0;

    // For each exception handler, and each instruction within its range, record in 'handlers' the
    // fact that execution can flow from this instruction to the exception handler.
    for (int i = 0; i < method.tryCatchBlocks.size(); ++i) {
      TryCatchBlockNode tryCatchBlock = method.tryCatchBlocks.get(i);
      int startIndex = insnList.indexOf(tryCatchBlock.start);
      int endIndex = insnList.indexOf(tryCatchBlock.end);
      for (int j = startIndex; j < endIndex; ++j) {
        List<TryCatchBlockNode> insnHandlers = handlers[j];
        if (insnHandlers == null) {
          insnHandlers = new ArrayList<>();
          handlers[j] = insnHandlers;
        }
        insnHandlers.add(tryCatchBlock);
      }
    }

    // Finds the method's subroutines.
    findSubroutines(method.maxLocals);

    // Initializes the data structures for the control flow analysis.
    Frame<V> currentFrame;
    try {
      currentFrame = computeInitialFrame(owner, method);
      merge(0, currentFrame, null);
      init(owner, method);
    } catch (RuntimeException e) {
      // DontCheck(IllegalCatch): can't be fixed, for backward compatibility.
      throw new AnalyzerException(insnList.get(0), "Error at instruction 0: " + e.getMessage(), e);
    }

    // Control flow analysis.
    while (numInstructionsToProcess > 0) {
      // Get and remove one instruction from the list of instructions to process.
      int insnIndex = instructionsToProcess[--numInstructionsToProcess];
      Frame<V> oldFrame = frames[insnIndex];
      Subroutine subroutine = subroutines[insnIndex];
      inInstructionsToProcess[insnIndex] = false;

      // Simulate the execution of this instruction.
      AbstractInsnNode insnNode = null;
      try {
        insnNode = method.instructions.get(insnIndex);
        int insnOpcode = insnNode.getOpcode();
        int insnType = insnNode.getType();

        if (insnType == AbstractInsnNode.LABEL
            || insnType == AbstractInsnNode.LINE
            || insnType == AbstractInsnNode.FRAME) {
          // Update the current frame, so it can be used during processing for this instruction
          currentFrame.init(oldFrame);
          merge(insnIndex + 1, oldFrame, subroutine);
          newControlFlowEdge(insnIndex, insnIndex + 1);
        } else {
          currentFrame.init(oldFrame).execute(insnNode, interpreter);
          subroutine = subroutine == null ? null : new Subroutine(subroutine);

          if (insnNode instanceof JumpInsnNode) {
            JumpInsnNode jumpInsn = (JumpInsnNode) insnNode;
            if (insnOpcode != GOTO && insnOpcode != JSR) {
              currentFrame.initJumpTarget(insnOpcode, /* target= */ null);
              merge(insnIndex + 1, currentFrame, subroutine);
              newControlFlowEdge(insnIndex, insnIndex + 1);
            }
            int jumpInsnIndex = insnList.indexOf(jumpInsn.label);
            currentFrame.initJumpTarget(insnOpcode, jumpInsn.label);
            if (insnOpcode == JSR) {
              merge(
                  jumpInsnIndex,
                  currentFrame,
                  new Subroutine(jumpInsn.label, method.maxLocals, jumpInsn));
            } else {
              merge(jumpInsnIndex, currentFrame, subroutine);
            }
            newControlFlowEdge(insnIndex, jumpInsnIndex);
          } else if (insnNode instanceof LookupSwitchInsnNode) {
            LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) insnNode;
            int targetInsnIndex = insnList.indexOf(lookupSwitchInsn.dflt);
            currentFrame.initJumpTarget(insnOpcode, lookupSwitchInsn.dflt);
            merge(targetInsnIndex, currentFrame, subroutine);
            newControlFlowEdge(insnIndex, targetInsnIndex);
            for (int i = 0; i < lookupSwitchInsn.labels.size(); ++i) {
              LabelNode label = lookupSwitchInsn.labels.get(i);
              targetInsnIndex = insnList.indexOf(label);
              currentFrame.initJumpTarget(insnOpcode, label);
              merge(targetInsnIndex, currentFrame, subroutine);
              newControlFlowEdge(insnIndex, targetInsnIndex);
            }
          } else if (insnNode instanceof TableSwitchInsnNode) {
            TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) insnNode;
            int targetInsnIndex = insnList.indexOf(tableSwitchInsn.dflt);
            currentFrame.initJumpTarget(insnOpcode, tableSwitchInsn.dflt);
            merge(targetInsnIndex, currentFrame, subroutine);
            newControlFlowEdge(insnIndex, targetInsnIndex);
            for (int i = 0; i < tableSwitchInsn.labels.size(); ++i) {
              LabelNode label = tableSwitchInsn.labels.get(i);
              currentFrame.initJumpTarget(insnOpcode, label);
              targetInsnIndex = insnList.indexOf(label);
              merge(targetInsnIndex, currentFrame, subroutine);
              newControlFlowEdge(insnIndex, targetInsnIndex);
            }
          } else if (insnOpcode == RET) {
            if (subroutine == null) {
              throw new AnalyzerException(insnNode, "RET instruction outside of a subroutine");
            }
            for (int i = 0; i < subroutine.callers.size(); ++i) {
              JumpInsnNode caller = subroutine.callers.get(i);
              int jsrInsnIndex = insnList.indexOf(caller);
              if (frames[jsrInsnIndex] != null) {
                merge(
                    jsrInsnIndex + 1,
                    frames[jsrInsnIndex],
                    currentFrame,
                    subroutines[jsrInsnIndex],
                    subroutine.localsUsed);
                newControlFlowEdge(insnIndex, jsrInsnIndex + 1);
              }
            }
          } else if (insnOpcode != ATHROW && (insnOpcode < IRETURN || insnOpcode > RETURN)) {
            if (subroutine != null) {
              if (insnNode instanceof VarInsnNode) {
                int varIndex = ((VarInsnNode) insnNode).var;
                subroutine.localsUsed[varIndex] = true;
                if (insnOpcode == LLOAD
                    || insnOpcode == DLOAD
                    || insnOpcode == LSTORE
                    || insnOpcode == DSTORE) {
                  subroutine.localsUsed[varIndex + 1] = true;
                }
              } else if (insnNode instanceof IincInsnNode) {
                int varIndex = ((IincInsnNode) insnNode).var;
                subroutine.localsUsed[varIndex] = true;
              }
            }
            merge(insnIndex + 1, currentFrame, subroutine);
            newControlFlowEdge(insnIndex, insnIndex + 1);
          }
        }

        List<TryCatchBlockNode> insnHandlers = handlers[insnIndex];
        if (insnHandlers != null) {
          for (TryCatchBlockNode tryCatchBlock : insnHandlers) {
            Type catchType;
            if (tryCatchBlock.type == null) {
              catchType = Type.getObjectType("java/lang/Throwable");
            } else {
              catchType = Type.getObjectType(tryCatchBlock.type);
            }
            if (newControlFlowExceptionEdge(insnIndex, tryCatchBlock)) {
              // Merge the frame *before* this instruction, with its stack cleared and an exception
              // pushed, with the handler's frame.
              Frame<V> handler = newFrame(oldFrame);
              handler.clearStack();
              V exceptionValue = interpreter.newExceptionValue(tryCatchBlock, handler, catchType);
              handler.push(exceptionValue);
              merge(insnList.indexOf(tryCatchBlock.handler), handler, subroutine);
              // Merge the frame *after* this instruction, with its stack cleared and an exception
              // pushed, with the handler's frame.
              handler = newFrame(currentFrame);
              handler.clearStack();
              handler.push(exceptionValue);
              merge(insnList.indexOf(tryCatchBlock.handler), handler, subroutine);
            }
          }
        }
      } catch (AnalyzerException e) {
        throw new AnalyzerException(
            e.node, "Error at instruction " + insnIndex + ": " + e.getMessage(), e);
      } catch (RuntimeException e) {
        // DontCheck(IllegalCatch): can't be fixed, for backward compatibility.
        throw new AnalyzerException(
            insnNode, "Error at instruction " + insnIndex + ": " + e.getMessage(), e);
      }
    }

    return frames;
  }

  /**
   * Analyzes the given method and computes and sets its maximum stack size and maximum number of
   * local variables.
   *
   * @param owner the internal name of the class to which 'method' belongs (see {@link
   *     Type#getInternalName()}).
   * @param method the method to be analyzed.
   * @return the symbolic state of the execution stack frame at each bytecode instruction of the
   *     method. The size of the returned array is equal to the number of instructions (and labels)
   *     of the method. A given frame is {@literal null} if and only if the corresponding
   *     instruction cannot be reached (dead code).
   * @throws AnalyzerException if a problem occurs during the analysis.
   */
  public Frame<V>[] analyzeAndComputeMaxs(final @InternalForm String owner, final MethodNode method)
      throws AnalyzerException {
    method.maxLocals = computeMaxLocals(method);
    method.maxStack = -1;
    analyze(owner, method);
    method.maxStack = computeMaxStack(frames);
    return frames;
  }

  /**
   * Computes and returns the maximum number of local variables used in the given method.
   *
   * @param method a method.
   * @return the maximum number of local variables used in the given method.
   */
  private static int computeMaxLocals(final MethodNode method) {
    int maxLocals = Type.getArgumentsAndReturnSizes(method.desc) >> 2;
    if ((method.access & Opcodes.ACC_STATIC) != 0) {
      maxLocals -= 1;
    }
    for (AbstractInsnNode insnNode : method.instructions) {
      if (insnNode instanceof VarInsnNode) {
        int local = ((VarInsnNode) insnNode).var;
        int size =
            (insnNode.getOpcode() == Opcodes.LLOAD
                    || insnNode.getOpcode() == Opcodes.DLOAD
                    || insnNode.getOpcode() == Opcodes.LSTORE
                    || insnNode.getOpcode() == Opcodes.DSTORE)
                ? 2
                : 1;
        maxLocals = Math.max(maxLocals, local + size);
      } else if (insnNode instanceof IincInsnNode) {
        int local = ((IincInsnNode) insnNode).var;
        maxLocals = Math.max(maxLocals, local + 1);
      }
    }
    return maxLocals;
  }

  /**
   * Computes and returns the maximum stack size of a method, given its stack map frames.
   *
   * @param frames the stack map frames of a method.
   * @return the maximum stack size of the given method.
   */
  private static int computeMaxStack(final Frame<?>[] frames) {
    int maxStack = 0;
    for (Frame<?> frame : frames) {
      if (frame != null) {
        int stackSize = 0;
        for (int i = 0; i < frame.getStackSize(); ++i) {
          stackSize += frame.getStack(i).getSize();
        }
        maxStack = Math.max(maxStack, stackSize);
      }
    }
    return maxStack;
  }

  /**
   * Finds the subroutines of the currently analyzed method and stores them in {@link #subroutines}.
   *
   * @param maxLocals the maximum number of local variables of the currently analyzed method (long
   *     and double values count for two variables).
   * @throws AnalyzerException if the control flow graph can fall off the end of the code.
   */
  private void findSubroutines(final int maxLocals) throws AnalyzerException {
    // For each instruction, compute the subroutine to which it belongs.
    // Follow the main 'subroutine', and collect the jsr instructions to nested subroutines.
    Subroutine main = new Subroutine(null, maxLocals, null);
    List<AbstractInsnNode> jsrInsns = new ArrayList<>();
    findSubroutine(0, main, jsrInsns);
    // Follow the nested subroutines, and collect their own nested subroutines, until all
    // subroutines are found.
    Map<LabelNode, Subroutine> jsrSubroutines = new HashMap<>();
    while (!jsrInsns.isEmpty()) {
      JumpInsnNode jsrInsn = (JumpInsnNode) jsrInsns.remove(0);
      Subroutine subroutine = jsrSubroutines.get(jsrInsn.label);
      if (subroutine == null) {
        subroutine = new Subroutine(jsrInsn.label, maxLocals, jsrInsn);
        jsrSubroutines.put(jsrInsn.label, subroutine);
        findSubroutine(insnList.indexOf(jsrInsn.label), subroutine, jsrInsns);
      } else {
        subroutine.callers.add(jsrInsn);
      }
    }
    // Clear the main 'subroutine', which is not a real subroutine (and was used only as an
    // intermediate step above to find the real ones).
    for (int i = 0; i < insnListSize; ++i) {
      if (subroutines[i] != null && subroutines[i].start == null) {
        subroutines[i] = null;
      }
    }
  }

  /**
   * Follows the control flow graph of the currently analyzed method, starting at the given
   * instruction index, and stores a copy of the given subroutine in {@link #subroutines} for each
   * encountered instruction. Jumps to nested subroutines are <i>not</i> followed: instead, the
   * corresponding instructions are put in the given list.
   *
   * @param insnIndex an instruction index.
   * @param subroutine a subroutine.
   * @param jsrInsns where the jsr instructions for nested subroutines must be put.
   * @throws AnalyzerException if the control flow graph can fall off the end of the code.
   */
  private void findSubroutine(
      final int insnIndex, final Subroutine subroutine, final List<AbstractInsnNode> jsrInsns)
      throws AnalyzerException {
    ArrayList<Integer> instructionIndicesToProcess = new ArrayList<>();
    instructionIndicesToProcess.add(insnIndex);
    while (!instructionIndicesToProcess.isEmpty()) {
      int currentInsnIndex =
          instructionIndicesToProcess.remove(instructionIndicesToProcess.size() - 1);
      if (currentInsnIndex < 0 || currentInsnIndex >= insnListSize) {
        throw new AnalyzerException(null, "Execution can fall off the end of the code");
      }
      if (subroutines[currentInsnIndex] != null) {
        continue;
      }
      subroutines[currentInsnIndex] = new Subroutine(subroutine);
      AbstractInsnNode currentInsn = insnList.get(currentInsnIndex);

      // Push the normal successors of currentInsn onto instructionIndicesToProcess.
      if (currentInsn instanceof JumpInsnNode) {
        if (currentInsn.getOpcode() == JSR) {
          // Do not follow a jsr, it leads to another subroutine!
          jsrInsns.add(currentInsn);
        } else {
          JumpInsnNode jumpInsn = (JumpInsnNode) currentInsn;
          instructionIndicesToProcess.add(insnList.indexOf(jumpInsn.label));
        }
      } else if (currentInsn instanceof TableSwitchInsnNode) {
        TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) currentInsn;
        findSubroutine(insnList.indexOf(tableSwitchInsn.dflt), subroutine, jsrInsns);
        for (int i = tableSwitchInsn.labels.size() - 1; i >= 0; --i) {
          LabelNode labelNode = tableSwitchInsn.labels.get(i);
          instructionIndicesToProcess.add(insnList.indexOf(labelNode));
        }
      } else if (currentInsn instanceof LookupSwitchInsnNode) {
        LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) currentInsn;
        findSubroutine(insnList.indexOf(lookupSwitchInsn.dflt), subroutine, jsrInsns);
        for (int i = lookupSwitchInsn.labels.size() - 1; i >= 0; --i) {
          LabelNode labelNode = lookupSwitchInsn.labels.get(i);
          instructionIndicesToProcess.add(insnList.indexOf(labelNode));
        }
      }

      // Push the exception handler successors of currentInsn onto instructionIndicesToProcess.
      List<TryCatchBlockNode> insnHandlers = handlers[currentInsnIndex];
      if (insnHandlers != null) {
        for (TryCatchBlockNode tryCatchBlock : insnHandlers) {
          instructionIndicesToProcess.add(insnList.indexOf(tryCatchBlock.handler));
        }
      }

      // Push the next instruction, if the control flow can go from currentInsn to the next.
      switch (currentInsn.getOpcode()) {
        case GOTO:
        case RET:
        case TABLESWITCH:
        case LOOKUPSWITCH:
        case IRETURN:
        case LRETURN:
        case FRETURN:
        case DRETURN:
        case ARETURN:
        case RETURN:
        case ATHROW:
          break;
        default:
          instructionIndicesToProcess.add(currentInsnIndex + 1);
          break;
      }
    }
  }

  /**
   * Computes the initial execution stack frame of the given method.
   *
   * @param owner the internal name of the class to which 'method' belongs (see {@link
   *     Type#getInternalName()}).
   * @param method the method to be analyzed.
   * @return the initial execution stack frame of the 'method'.
   */
  private Frame<V> computeInitialFrame(final @InternalForm String owner, final MethodNode method) {
    Frame<V> frame = newFrame(method.maxLocals, method.maxStack);
    int currentLocal = 0;
    boolean isInstanceMethod = (method.access & ACC_STATIC) == 0;
    if (isInstanceMethod) {
      Type ownerType = Type.getObjectType(owner);
      frame.setLocal(
          currentLocal, interpreter.newParameterValue(isInstanceMethod, currentLocal, ownerType));
      currentLocal++;
    }
    Type[] argumentTypes = Type.getArgumentTypes(method.desc);
    for (Type argumentType : argumentTypes) {
      frame.setLocal(
          currentLocal,
          interpreter.newParameterValue(isInstanceMethod, currentLocal, argumentType));
      currentLocal++;
      if (argumentType.getSize() == 2) {
        frame.setLocal(currentLocal, interpreter.newEmptyValue(currentLocal));
        currentLocal++;
      }
    }
    while (currentLocal < method.maxLocals) {
      frame.setLocal(currentLocal, interpreter.newEmptyValue(currentLocal));
      currentLocal++;
    }
    frame.setReturn(interpreter.newReturnTypeValue(Type.getReturnType(method.desc)));
    return frame;
  }

  /**
   * Returns the symbolic execution stack frame for each instruction of the last analyzed method.
   *
   * @return the symbolic state of the execution stack frame at each bytecode instruction of the
   *     method. The size of the returned array is equal to the number of instructions (and labels)
   *     of the method. A given frame is {@literal null} if the corresponding instruction cannot be
   *     reached, or if an error occurred during the analysis of the method.
   */
  public Frame<V>[] getFrames() {
    return frames;
  }

  /**
   * Returns the exception handlers for the given instruction.
   *
   * @param insnIndex the index of an instruction of the last analyzed method.
   * @return a list of {@link TryCatchBlockNode} objects.
   */
  public List<TryCatchBlockNode> getHandlers(final int insnIndex) {
    return handlers[insnIndex];
  }

  /**
   * Initializes this analyzer. This method is called just before the execution of control flow
   * analysis loop in {@link #analyze}. The default implementation of this method does nothing.
   *
   * @param owner the internal name of the class to which the method belongs (see {@link
   *     Type#getInternalName()}).
   * @param method the method to be analyzed.
   * @throws AnalyzerException if a problem occurs.
   */
  protected void init(final @InternalForm String owner, final MethodNode method) throws AnalyzerException {
    // Nothing to do.
  }

  /**
   * Constructs a new frame with the given size.
   *
   * @param numLocals the maximum number of local variables of the frame.
   * @param numStack the maximum stack size of the frame.
   * @return the created frame.
   */
  protected Frame<V> newFrame(final int numLocals, final int numStack) {
    return new Frame<>(numLocals, numStack);
  }

  /**
   * Constructs a copy of the given frame.
   *
   * @param frame a frame.
   * @return the created frame.
   */
  protected Frame<V> newFrame(final Frame<? extends V> frame) {
    return new Frame<>(frame);
  }

  /**
   * Creates a control flow graph edge. The default implementation of this method does nothing. It
   * can be overridden in order to construct the control flow graph of a method (this method is
   * called by the {@link #analyze} method during its visit of the method's code).
   *
   * @param insnIndex an instruction index.
   * @param successorIndex index of a successor instruction.
   */
  protected void newControlFlowEdge(final int insnIndex, final int successorIndex) {
    // Nothing to do.
  }

  /**
   * Creates a control flow graph edge corresponding to an exception handler. The default
   * implementation of this method does nothing. It can be overridden in order to construct the
   * control flow graph of a method (this method is called by the {@link #analyze} method during its
   * visit of the method's code).
   *
   * @param insnIndex an instruction index.
   * @param successorIndex index of a successor instruction.
   * @return true if this edge must be considered in the data flow analysis performed by this
   *     analyzer, or false otherwise. The default implementation of this method always returns
   *     true.
   */
  protected boolean newControlFlowExceptionEdge(final int insnIndex, final int successorIndex) {
    return true;
  }

  /**
   * Creates a control flow graph edge corresponding to an exception handler. The default
   * implementation of this method delegates to {@link #newControlFlowExceptionEdge(int, int)}. It
   * can be overridden in order to construct the control flow graph of a method (this method is
   * called by the {@link #analyze} method during its visit of the method's code).
   *
   * @param insnIndex an instruction index.
   * @param tryCatchBlock TryCatchBlockNode corresponding to this edge.
   * @return true if this edge must be considered in the data flow analysis performed by this
   *     analyzer, or false otherwise. The default implementation of this method delegates to {@link
   *     #newControlFlowExceptionEdge(int, int)}.
   */
  protected boolean newControlFlowExceptionEdge(
      final int insnIndex, final TryCatchBlockNode tryCatchBlock) {
    return newControlFlowExceptionEdge(insnIndex, insnList.indexOf(tryCatchBlock.handler));
  }

  // -----------------------------------------------------------------------------------------------

  /**
   * Merges the given frame and subroutine into the frame and subroutines at the given instruction
   * index. If the frame or the subroutine at the given instruction index changes as a result of
   * this merge, the instruction index is added to the list of instructions to process (if it is not
   * already the case).
   *
   * @param insnIndex an instruction index.
   * @param frame a frame. This frame is left unchanged by this method.
   * @param subroutine a subroutine. This subroutine is left unchanged by this method.
   * @throws AnalyzerException if the frames have incompatible sizes.
   */
  private void merge(final int insnIndex, final Frame<V> frame, final Subroutine subroutine)
      throws AnalyzerException {
    boolean changed;
    Frame<V> oldFrame = frames[insnIndex];
    if (oldFrame == null) {
      frames[insnIndex] = newFrame(frame);
      changed = true;
    } else {
      changed = oldFrame.merge(frame, interpreter);
    }
    Subroutine oldSubroutine = subroutines[insnIndex];
    if (oldSubroutine == null) {
      if (subroutine != null) {
        subroutines[insnIndex] = new Subroutine(subroutine);
        changed = true;
      }
    } else {
      if (subroutine != null) {
        changed |= oldSubroutine.merge(subroutine);
      }
    }
    if (changed && !inInstructionsToProcess[insnIndex]) {
      inInstructionsToProcess[insnIndex] = true;
      instructionsToProcess[numInstructionsToProcess++] = insnIndex;
    }
  }

  /**
   * Merges the given frame and subroutine into the frame and subroutines at the given instruction
   * index (case of a RET instruction). If the frame or the subroutine at the given instruction
   * index changes as a result of this merge, the instruction index is added to the list of
   * instructions to process (if it is not already the case).
   *
   * @param insnIndex the index of an instruction immediately following a jsr instruction.
   * @param frameBeforeJsr the execution stack frame before the jsr instruction. This frame is
   *     merged into 'frameAfterRet'.
   * @param frameAfterRet the execution stack frame after a ret instruction of the subroutine. This
   *     frame is merged into the frame at 'insnIndex' (after it has itself been merge with
   *     'frameBeforeJsr').
   * @param subroutineBeforeJsr if the jsr is itself part of a subroutine (case of nested
   *     subroutine), the subroutine it belongs to.
   * @param localsUsed the local variables read or written in the subroutine.
   * @throws AnalyzerException if the frames have incompatible sizes.
   */
  private void merge(
      final int insnIndex,
      final Frame<V> frameBeforeJsr,
      final Frame<V> frameAfterRet,
      final Subroutine subroutineBeforeJsr,
      final boolean[] localsUsed)
      throws AnalyzerException {
    frameAfterRet.merge(frameBeforeJsr, localsUsed);

    boolean changed;
    Frame<V> oldFrame = frames[insnIndex];
    if (oldFrame == null) {
      frames[insnIndex] = newFrame(frameAfterRet);
      changed = true;
    } else {
      changed = oldFrame.merge(frameAfterRet, interpreter);
    }
    Subroutine oldSubroutine = subroutines[insnIndex];
    if (oldSubroutine != null && subroutineBeforeJsr != null) {
      changed |= oldSubroutine.merge(subroutineBeforeJsr);
    }
    if (changed && !inInstructionsToProcess[insnIndex]) {
      inInstructionsToProcess[insnIndex] = true;
      instructionsToProcess[numInstructionsToProcess++] = insnIndex;
    }
  }
}

package org.objectweb.asm.tree.analysis;

import java.util.Set;
import org.objectweb.asm.tree.AbstractInsnNode;

/**
 * A {@link Value} which keeps track of the bytecode instructions that can produce it.
 *
 * @author Eric Bruneton
 */
public class SourceValue implements Value {

  /**
   * The size of this value, in 32 bits words. This size is 1 for byte, boolean, char, short, int,
   * float, object and array types, and 2 for long and double.
   */
  public final int size;

  /**
   * The instructions that can produce this value. For example, for the Java code below, the
   * instructions that can produce the value of {@code i} at line 5 are the two ISTORE instructions
   * at line 1 and 3:
   *
   * <pre>
   * 1: i = 0;
   * 2: if (...) {
   * 3:   i = 1;
   * 4: }
   * 5: return i;
   * </pre>
   */
  public final Set<AbstractInsnNode> insns;

  /**
   * Constructs a new {@link SourceValue}.
   *
   * @param size the size of this value, in 32 bits words. This size is 1 for byte, boolean, char,
   *     short, int, float, object and array types, and 2 for long and double.
   */
  public SourceValue(final int size) {
    this(size, new SmallSet<>());
  }

  /**
   * Constructs a new {@link SourceValue}.
   *
   * @param size the size of this value, in 32 bits words. This size is 1 for byte, boolean, char,
   *     short, int, float, object and array types, and 2 for long and double.
   * @param insnNode an instruction that can produce this value.
   */
  public SourceValue(final int size, final AbstractInsnNode insnNode) {
    this.size = size;
    this.insns = new SmallSet<>(insnNode);
  }

  /**
   * Constructs a new {@link SourceValue}.
   *
   * @param size the size of this value, in 32 bits words. This size is 1 for byte, boolean, char,
   *     short, int, float, object and array types, and 2 for long and double.
   * @param insnSet the instructions that can produce this value.
   */
  public SourceValue(final int size, final Set<AbstractInsnNode> insnSet) {
    this.size = size;
    this.insns = insnSet;
  }

  /**
   * Returns the size of this value.
   *
   * @return the size of this value, in 32 bits words. This size is 1 for byte, boolean, char,
   *     short, int, float, object and array types, and 2 for long and double.
   */
  @Override
  public int getSize() {
    return size;
  }

  @Override
  public boolean equals(final Object value) {
    if (!(value instanceof SourceValue)) {
      return false;
    }
    SourceValue sourceValue = (SourceValue) value;
    return size == sourceValue.size && insns.equals(sourceValue.insns);
  }

  @Override
  public int hashCode() {
    return insns.hashCode();
  }
}

package org.objectweb.asm.tree.analysis;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;

/**
 * A method subroutine (corresponds to a JSR instruction).
 *
 * @author Eric Bruneton
 */
final class Subroutine {

  /** The start of this subroutine. */
  final LabelNode start;

  /**
   * The local variables that are read or written by this subroutine. The i-th element is true if
   * and only if the local variable at index i is read or written by this subroutine.
   */
  final boolean[] localsUsed;

  /** The JSR instructions that jump to this subroutine. */
  final List<JumpInsnNode> callers;

  /**
   * Constructs a new {@link Subroutine}.
   *
   * @param start the start of this subroutine.
   * @param maxLocals the local variables that are read or written by this subroutine.
   * @param caller a JSR instruction that jump to this subroutine.
   */
  Subroutine(final LabelNode start, final int maxLocals, final JumpInsnNode caller) {
    this.start = start;
    this.localsUsed = new boolean[maxLocals];
    this.callers = new ArrayList<>();
    callers.add(caller);
  }

  /**
   * Constructs a copy of the given {@link Subroutine}.
   *
   * @param subroutine the subroutine to copy.
   */
  Subroutine(final Subroutine subroutine) {
    this.start = subroutine.start;
    this.localsUsed = subroutine.localsUsed.clone();
    this.callers = new ArrayList<>(subroutine.callers);
  }

  /**
   * Merges the given subroutine into this subroutine. The local variables read or written by the
   * given subroutine are marked as read or written by this one, and the callers of the given
   * subroutine are added as callers of this one (if both have the same start).
   *
   * @param subroutine another subroutine. This subroutine is left unchanged by this method.
   * @return whether this subroutine has been modified by this method.
   */
  public boolean merge(final Subroutine subroutine) {
    boolean changed = false;
    for (int i = 0; i < localsUsed.length; ++i) {
      if (subroutine.localsUsed[i] && !localsUsed[i]) {
        localsUsed[i] = true;
        changed = true;
      }
    }
    if (subroutine.start == start) {
      for (int i = 0; i < subroutine.callers.size(); ++i) {
        JumpInsnNode caller = subroutine.callers.get(i);
        if (!callers.contains(caller)) {
          callers.add(caller);
          changed = true;
        }
      }
    }
    return changed;
  }
}

package org.objectweb.asm.tree.analysis;

import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.TryCatchBlockNode;

/**
 * A semantic bytecode interpreter. More precisely, this interpreter only manages the computation of
 * values from other values: it does not manage the transfer of values to or from the stack, and to
 * or from the local variables. This separation allows a generic bytecode {@link Analyzer} to work
 * with various semantic interpreters, without needing to duplicate the code to simulate the
 * transfer of values.
 *
 * @param <V> type of the Value used for the analysis.
 * @author Eric Bruneton
 */
public abstract class Interpreter<V extends Value> {

  /**
   * The ASM API version supported by this interpreter. The value of this field must be one of the
   * {@code ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected final int api;

  /**
   * Constructs a new {@link Interpreter}.
   *
   * @param api the ASM API version supported by this interpreter. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected Interpreter(final int api) {
    this.api = api;
  }

  /**
   * Creates a new value that represents the given type.
   *
   * <p>Called for method parameters (including <code>this</code>), exception handler variable and
   * with <code>null</code> type for variables reserved by long and double types.
   *
   * <p>An interpreter may choose to implement one or more of {@link
   * Interpreter#newReturnTypeValue(Type)}, {@link Interpreter#newParameterValue(boolean, int,
   * Type)}, {@link Interpreter#newEmptyValue(int)}, {@link
   * Interpreter#newExceptionValue(TryCatchBlockNode, Frame, Type)} to distinguish different types
   * of new value.
   *
   * @param type a primitive or reference type, or {@literal null} to represent an uninitialized
   *     value.
   * @return a value that represents the given type. The size of the returned value must be equal to
   *     the size of the given type.
   */
  public abstract V newValue(Type type);

  /**
   * Creates a new value that represents the given parameter type. This method is called to
   * initialize the value of a local corresponding to a method parameter in a frame.
   *
   * <p>By default, calls <code>newValue(type)</code>.
   *
   * @param isInstanceMethod {@literal true} if the method is non-static.
   * @param local the local variable index.
   * @param type a primitive or reference type.
   * @return a value that represents the given type. The size of the returned value must be equal to
   *     the size of the given type.
   */
  public V newParameterValue(final boolean isInstanceMethod, final int local, final Type type) {
    return newValue(type);
  }

  /**
   * Creates a new value that represents the given return type. This method is called to initialize
   * the return type value of a frame.
   *
   * <p>By default, calls <code>newValue(type)</code>.
   *
   * @param type a primitive or reference type.
   * @return a value that represents the given type. The size of the returned value must be equal to
   *     the size of the given type.
   */
  public V newReturnTypeValue(final Type type) {
    return newValue(type);
  }

  /**
   * Creates a new uninitialized value for a local variable. This method is called to initialize the
   * value of a local that does not correspond to a method parameter, and to reset one half of a
   * size-2 value when the other half is assigned a size-1 value.
   *
   * <p>By default, calls <code>newValue(null)</code>.
   *
   * @param local the local variable index.
   * @return a value representing an uninitialized value. The size of the returned value must be
   *     equal to 1.
   */
  public V newEmptyValue(final int local) {
    return newValue(null);
  }

  /**
   * Creates a new value that represents the given exception type. This method is called to
   * initialize the exception value on the call stack at the entry of an exception handler.
   *
   * <p>By default, calls <code>newValue(exceptionType)</code>.
   *
   * @param tryCatchBlockNode the exception handler.
   * @param handlerFrame the exception handler frame.
   * @param exceptionType the exception type handled by this handler.
   * @return a value that represents the given {@code exceptionType}. The size of the returned value
   *     must be equal to 1.
   */
  public V newExceptionValue(
      final TryCatchBlockNode tryCatchBlockNode,
      final Frame<V> handlerFrame,
      final Type exceptionType) {
    return newValue(exceptionType);
  }

  /**
   * Interprets a bytecode instruction without arguments. This method is called for the following
   * opcodes:
   *
   * <p>ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,
   * LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, BIPUSH, SIPUSH, LDC, JSR,
   * GETSTATIC, NEW
   *
   * @param insn the bytecode instruction to be interpreted.
   * @return the result of the interpretation of the given instruction.
   * @throws AnalyzerException if an error occurred during the interpretation.
   */
  public abstract V newOperation(AbstractInsnNode insn) throws AnalyzerException;

  /**
   * Interprets a bytecode instruction that moves a value on the stack or to or from local
   * variables. This method is called for the following opcodes:
   *
   * <p>ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE, DUP, DUP_X1,
   * DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP
   *
   * @param insn the bytecode instruction to be interpreted.
   * @param value the value that must be moved by the instruction.
   * @return the result of the interpretation of the given instruction. The returned value must be
   *     {@code equal} to the given value.
   * @throws AnalyzerException if an error occurred during the interpretation.
   */
  public abstract V copyOperation(AbstractInsnNode insn, V value) throws AnalyzerException;

  /**
   * Interprets a bytecode instruction with a single argument. This method is called for the
   * following opcodes:
   *
   * <p>INEG, LNEG, FNEG, DNEG, IINC, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F,
   * I2B, I2C, I2S, IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, TABLESWITCH, LOOKUPSWITCH, IRETURN, LRETURN,
   * FRETURN, DRETURN, ARETURN, PUTSTATIC, GETFIELD, NEWARRAY, ANEWARRAY, ARRAYLENGTH, ATHROW,
   * CHECKCAST, INSTANCEOF, MONITORENTER, MONITOREXIT, IFNULL, IFNONNULL
   *
   * @param insn the bytecode instruction to be interpreted.
   * @param value the argument of the instruction to be interpreted.
   * @return the result of the interpretation of the given instruction.
   * @throws AnalyzerException if an error occurred during the interpretation.
   */
  public abstract V unaryOperation(AbstractInsnNode insn, V value) throws AnalyzerException;

  /**
   * Interprets a bytecode instruction with two arguments. This method is called for the following
   * opcodes:
   *
   * <p>IALOAD, LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IADD, LADD, FADD, DADD,
   * ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM,
   * ISHL, LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, LCMP, FCMPL, FCMPG,
   * DCMPL, DCMPG, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ,
   * IF_ACMPNE, PUTFIELD
   *
   * @param insn the bytecode instruction to be interpreted.
   * @param value1 the first argument of the instruction to be interpreted.
   * @param value2 the second argument of the instruction to be interpreted.
   * @return the result of the interpretation of the given instruction.
   * @throws AnalyzerException if an error occurred during the interpretation.
   */
  public abstract V binaryOperation(AbstractInsnNode insn, V value1, V value2)
      throws AnalyzerException;

  /**
   * Interprets a bytecode instruction with three arguments. This method is called for the following
   * opcodes:
   *
   * <p>IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE, SASTORE
   *
   * @param insn the bytecode instruction to be interpreted.
   * @param value1 the first argument of the instruction to be interpreted.
   * @param value2 the second argument of the instruction to be interpreted.
   * @param value3 the third argument of the instruction to be interpreted.
   * @return the result of the interpretation of the given instruction.
   * @throws AnalyzerException if an error occurred during the interpretation.
   */
  public abstract V ternaryOperation(AbstractInsnNode insn, V value1, V value2, V value3)
      throws AnalyzerException;

  /**
   * Interprets a bytecode instruction with a variable number of arguments. This method is called
   * for the following opcodes:
   *
   * <p>INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE, MULTIANEWARRAY and
   * INVOKEDYNAMIC
   *
   * @param insn the bytecode instruction to be interpreted.
   * @param values the arguments of the instruction to be interpreted.
   * @return the result of the interpretation of the given instruction.
   * @throws AnalyzerException if an error occurred during the interpretation.
   */
  public abstract V naryOperation(AbstractInsnNode insn, List<? extends V> values)
      throws AnalyzerException;

  /**
   * Interprets a bytecode return instruction. This method is called for the following opcodes:
   *
   * <p>IRETURN, LRETURN, FRETURN, DRETURN, ARETURN
   *
   * @param insn the bytecode instruction to be interpreted.
   * @param value the argument of the instruction to be interpreted.
   * @param expected the expected return type of the analyzed method.
   * @throws AnalyzerException if an error occurred during the interpretation.
   */
  public abstract void returnOperation(AbstractInsnNode insn, V value, V expected)
      throws AnalyzerException;

  /**
   * Merges two values. The merge operation must return a value that represents both values (for
   * instance, if the two values are two types, the merged value must be a common super type of the
   * two types. If the two values are integer intervals, the merged value must be an interval that
   * contains the previous ones. Likewise for other types of values).
   *
   * @param value1 a value.
   * @param value2 another value.
   * @return the merged value. If the merged value is equal to {@code value1}, this method
   *     <i>must</i> return {@code value1}.
   */
  public abstract V merge(V value1, V value2);
}

package org.objectweb.asm.tree.analysis;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.IincInsnNode;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MultiANewArrayInsnNode;
import org.objectweb.asm.tree.VarInsnNode;

/**
 * A symbolic execution stack frame. A stack frame contains a set of local variable slots, and an
 * operand stack. Warning: long and double values are represented with <i>two</i> slots in local
 * variables, and with <i>one</i> slot in the operand stack.
 *
 * @param <V> type of the Value used for the analysis.
 * @author Eric Bruneton
 */
public class Frame<V extends Value> {

  /** The maximum size of the operand stack of any method. */
  private static final int MAX_STACK_SIZE = 65536;

  /**
   * The expected return type of the analyzed method, or {@literal null} if the method returns void.
   */
  private V returnValue;

  /**
   * The local variables and the operand stack of this frame. The first {@link #numLocals} elements
   * correspond to the local variables. The following {@link #numStack} elements correspond to the
   * operand stack. Long and double values are represented with two elements in the local variables
   * section, and with one element in the operand stack section.
   */
  private V[] values;

  /**
   * The number of local variables of this frame. Long and double values are represented with two
   * elements.
   */
  private int numLocals;

  /**
   * The number of elements in the operand stack. Long and double values are represented with a
   * single element.
   */
  private int numStack;

  /**
   * The maximum number of elements in the operand stack. Long and double values are represented
   * with a single element.
   */
  private int maxStack;

  /**
   * Constructs a new frame with the given size.
   *
   * @param numLocals the number of local variables of the frame. Long and double values are
   *     represented with two elements.
   * @param maxStack the maximum number of elements in the operand stack, or -1 if there is no
   *     maximum value. Long and double values are represented with a single element.
   */
  @SuppressWarnings("unchecked")
  public Frame(final int numLocals, final int maxStack) {
    this.values = (V[]) new Value[numLocals + (maxStack >= 0 ? maxStack : 4)];
    this.numLocals = numLocals;
    this.numStack = 0;
    this.maxStack = maxStack >= 0 ? maxStack : MAX_STACK_SIZE;
  }

  /**
   * Constructs a copy of the given Frame.
   *
   * @param frame a frame.
   */
  public Frame(final Frame<? extends V> frame) {
    this(frame.numLocals, frame.values.length - frame.numLocals);
    init(frame); // NOPMD(ConstructorCallsOverridableMethod): can't fix for backward compatibility.
  }

  /**
   * Copies the state of the given frame into this frame.
   *
   * @param frame a frame.
   * @return this frame.
   */
  public Frame<V> init(final Frame<? extends V> frame) {
    returnValue = frame.returnValue;
    if (values.length < frame.values.length) {
      values = frame.values.clone();
    } else {
      System.arraycopy(frame.values, 0, values, 0, frame.values.length);
    }
    numLocals = frame.numLocals;
    numStack = frame.numStack;
    maxStack = frame.maxStack;
    return this;
  }

  /**
   * Initializes a frame corresponding to the target or to the successor of a jump instruction. This
   * method is called by {@link Analyzer#analyze(String, org.objectweb.asm.tree.MethodNode)} while
   * interpreting jump instructions. It is called once for each possible target of the jump
   * instruction, and once for its successor instruction (except for GOTO and JSR), before the frame
   * is merged with the existing frame at this location. The default implementation of this method
   * does nothing.
   *
   * <p>Overriding this method and changing the frame values allows implementing branch-sensitive
   * analyses.
   *
   * @param opcode the opcode of the jump instruction. Can be IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE,
   *     IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE,
   *     GOTO, JSR, IFNULL, IFNONNULL, TABLESWITCH or LOOKUPSWITCH.
   * @param target a target of the jump instruction this frame corresponds to, or {@literal null} if
   *     this frame corresponds to the successor of the jump instruction (i.e. the next instruction
   *     in the instructions sequence).
   */
  public void initJumpTarget(final int opcode, final LabelNode target) {
    // Does nothing by default.
  }

  /**
   * Sets the expected return type of the analyzed method.
   *
   * @param v the expected return type of the analyzed method, or {@literal null} if the method
   *     returns void.
   */
  public void setReturn(final V v) {
    returnValue = v;
  }

  /**
   * Returns the maximum number of local variables of this frame. Long and double values are
   * represented with two variables.
   *
   * @return the maximum number of local variables of this frame.
   */
  public int getLocals() {
    return numLocals;
  }

  /**
   * Returns the maximum number of elements in the operand stack of this frame. Long and double
   * values are represented with a single element.
   *
   * @return the maximum number of elements in the operand stack of this frame.
   */
  public int getMaxStackSize() {
    return maxStack;
  }

  /**
   * Returns the value of the given local variable. Long and double values are represented with two
   * variables.
   *
   * @param index a local variable index.
   * @return the value of the given local variable.
   * @throws IndexOutOfBoundsException if the variable does not exist.
   */
  public V getLocal(final int index) {
    if (index >= numLocals) {
      throw new IndexOutOfBoundsException("Trying to get an inexistant local variable " + index);
    }
    return values[index];
  }

  /**
   * Sets the value of the given local variable. Long and double values are represented with two
   * variables.
   *
   * @param index a local variable index.
   * @param value the new value of this local variable.
   * @throws IndexOutOfBoundsException if the variable does not exist.
   */
  public void setLocal(final int index, final V value) {
    if (index >= numLocals) {
      throw new IndexOutOfBoundsException("Trying to set an inexistant local variable " + index);
    }
    values[index] = value;
  }

  /**
   * Returns the number of elements in the operand stack of this frame. Long and double values are
   * represented with a single element.
   *
   * @return the number of elements in the operand stack of this frame.
   */
  public int getStackSize() {
    return numStack;
  }

  /**
   * Returns the value of the given operand stack slot.
   *
   * @param index the index of an operand stack slot.
   * @return the value of the given operand stack slot.
   * @throws IndexOutOfBoundsException if the operand stack slot does not exist.
   */
  public V getStack(final int index) {
    return values[numLocals + index];
  }

  /**
   * Sets the value of the given stack slot.
   *
   * @param index the index of an operand stack slot.
   * @param value the new value of the stack slot.
   * @throws IndexOutOfBoundsException if the stack slot does not exist.
   */
  public void setStack(final int index, final V value) {
    values[numLocals + index] = value;
  }

  /** Clears the operand stack of this frame. */
  public void clearStack() {
    numStack = 0;
  }

  /**
   * Pops a value from the operand stack of this frame.
   *
   * @return the value that has been popped from the stack.
   * @throws IndexOutOfBoundsException if the operand stack is empty.
   */
  public V pop() {
    if (numStack == 0) {
      throw new IndexOutOfBoundsException("Cannot pop operand off an empty stack.");
    }
    return values[numLocals + (--numStack)];
  }

  /**
   * Pushes a value into the operand stack of this frame.
   *
   * @param value the value that must be pushed into the stack.
   * @throws IndexOutOfBoundsException if the operand stack is full.
   */
  @SuppressWarnings("unchecked")
  public void push(final V value) {
    if (numLocals + numStack >= values.length) {
      if (numLocals + numStack >= maxStack) {
        throw new IndexOutOfBoundsException("Insufficient maximum stack size.");
      }
      V[] oldValues = values;
      values = (V[]) new Value[2 * values.length];
      System.arraycopy(oldValues, 0, values, 0, oldValues.length);
    }
    values[numLocals + (numStack++)] = value;
  }

  /**
   * Simulates the execution of the given instruction on this execution stack frame.
   *
   * @param insn the instruction to execute.
   * @param interpreter the interpreter to use to compute values from other values.
   * @throws AnalyzerException if the instruction cannot be executed on this execution frame (e.g. a
   *     POP on an empty operand stack).
   */
  public void execute(final AbstractInsnNode insn, final Interpreter<V> interpreter)
      throws AnalyzerException {
    V value1;
    V value2;
    V value3;
    V value4;
    int varIndex;

    switch (insn.getOpcode()) {
      case Opcodes.NOP:
        break;
      case Opcodes.ACONST_NULL:
      case Opcodes.ICONST_M1:
      case Opcodes.ICONST_0:
      case Opcodes.ICONST_1:
      case Opcodes.ICONST_2:
      case Opcodes.ICONST_3:
      case Opcodes.ICONST_4:
      case Opcodes.ICONST_5:
      case Opcodes.LCONST_0:
      case Opcodes.LCONST_1:
      case Opcodes.FCONST_0:
      case Opcodes.FCONST_1:
      case Opcodes.FCONST_2:
      case Opcodes.DCONST_0:
      case Opcodes.DCONST_1:
      case Opcodes.BIPUSH:
      case Opcodes.SIPUSH:
      case Opcodes.LDC:
        push(interpreter.newOperation(insn));
        break;
      case Opcodes.ILOAD:
      case Opcodes.LLOAD:
      case Opcodes.FLOAD:
      case Opcodes.DLOAD:
      case Opcodes.ALOAD:
        push(interpreter.copyOperation(insn, getLocal(((VarInsnNode) insn).var)));
        break;
      case Opcodes.ISTORE:
      case Opcodes.LSTORE:
      case Opcodes.FSTORE:
      case Opcodes.DSTORE:
      case Opcodes.ASTORE:
        value1 = interpreter.copyOperation(insn, pop());
        varIndex = ((VarInsnNode) insn).var;
        setLocal(varIndex, value1);
        if (value1.getSize() == 2) {
          setLocal(varIndex + 1, interpreter.newEmptyValue(varIndex + 1));
        }
        if (varIndex > 0) {
          Value local = getLocal(varIndex - 1);
          if (local != null && local.getSize() == 2) {
            setLocal(varIndex - 1, interpreter.newEmptyValue(varIndex - 1));
          }
        }
        break;
      case Opcodes.IASTORE:
      case Opcodes.LASTORE:
      case Opcodes.FASTORE:
      case Opcodes.DASTORE:
      case Opcodes.AASTORE:
      case Opcodes.BASTORE:
      case Opcodes.CASTORE:
      case Opcodes.SASTORE:
        value3 = pop();
        value2 = pop();
        value1 = pop();
        interpreter.ternaryOperation(insn, value1, value2, value3);
        break;
      case Opcodes.POP:
        if (pop().getSize() == 2) {
          throw new AnalyzerException(insn, "Illegal use of POP");
        }
        break;
      case Opcodes.POP2:
        if (pop().getSize() == 1 && pop().getSize() != 1) {
          throw new AnalyzerException(insn, "Illegal use of POP2");
        }
        break;
      case Opcodes.DUP:
        value1 = pop();
        if (value1.getSize() != 1) {
          throw new AnalyzerException(insn, "Illegal use of DUP");
        }
        push(interpreter.copyOperation(insn, value1));
        push(interpreter.copyOperation(insn, value1));
        break;
      case Opcodes.DUP_X1:
        value1 = pop();
        value2 = pop();
        if (value1.getSize() != 1 || value2.getSize() != 1) {
          throw new AnalyzerException(insn, "Illegal use of DUP_X1");
        }
        push(interpreter.copyOperation(insn, value1));
        push(interpreter.copyOperation(insn, value2));
        push(interpreter.copyOperation(insn, value1));
        break;
      case Opcodes.DUP_X2:
        value1 = pop();
        if (value1.getSize() == 1 && executeDupX2(insn, value1, interpreter)) {
          break;
        }
        throw new AnalyzerException(insn, "Illegal use of DUP_X2");
      case Opcodes.DUP2:
        value1 = pop();
        if (value1.getSize() == 1) {
          value2 = pop();
          if (value2.getSize() == 1) {
            push(interpreter.copyOperation(insn, value2));
            push(interpreter.copyOperation(insn, value1));
            push(interpreter.copyOperation(insn, value2));
            push(interpreter.copyOperation(insn, value1));
            break;
          }
        } else {
          push(value1);
          push(interpreter.copyOperation(insn, value1));
          break;
        }
        throw new AnalyzerException(insn, "Illegal use of DUP2");
      case Opcodes.DUP2_X1:
        value1 = pop();
        if (value1.getSize() == 1) {
          value2 = pop();
          if (value2.getSize() == 1) {
            value3 = pop();
            if (value3.getSize() == 1) {
              push(interpreter.copyOperation(insn, value2));
              push(interpreter.copyOperation(insn, value1));
              push(interpreter.copyOperation(insn, value3));
              push(interpreter.copyOperation(insn, value2));
              push(interpreter.copyOperation(insn, value1));
              break;
            }
          }
        } else {
          value2 = pop();
          if (value2.getSize() == 1) {
            push(interpreter.copyOperation(insn, value1));
            push(interpreter.copyOperation(insn, value2));
            push(interpreter.copyOperation(insn, value1));
            break;
          }
        }
        throw new AnalyzerException(insn, "Illegal use of DUP2_X1");
      case Opcodes.DUP2_X2:
        value1 = pop();
        if (value1.getSize() == 1) {
          value2 = pop();
          if (value2.getSize() == 1) {
            value3 = pop();
            if (value3.getSize() == 1) {
              value4 = pop();
              if (value4.getSize() == 1) {
                push(interpreter.copyOperation(insn, value2));
                push(interpreter.copyOperation(insn, value1));
                push(interpreter.copyOperation(insn, value4));
                push(interpreter.copyOperation(insn, value3));
                push(interpreter.copyOperation(insn, value2));
                push(interpreter.copyOperation(insn, value1));
                break;
              }
            } else {
              push(interpreter.copyOperation(insn, value2));
              push(interpreter.copyOperation(insn, value1));
              push(interpreter.copyOperation(insn, value3));
              push(interpreter.copyOperation(insn, value2));
              push(interpreter.copyOperation(insn, value1));
              break;
            }
          }
        } else if (executeDupX2(insn, value1, interpreter)) {
          break;
        }
        throw new AnalyzerException(insn, "Illegal use of DUP2_X2");
      case Opcodes.SWAP:
        value2 = pop();
        value1 = pop();
        if (value1.getSize() != 1 || value2.getSize() != 1) {
          throw new AnalyzerException(insn, "Illegal use of SWAP");
        }
        push(interpreter.copyOperation(insn, value2));
        push(interpreter.copyOperation(insn, value1));
        break;
      case Opcodes.IALOAD:
      case Opcodes.LALOAD:
      case Opcodes.FALOAD:
      case Opcodes.DALOAD:
      case Opcodes.AALOAD:
      case Opcodes.BALOAD:
      case Opcodes.CALOAD:
      case Opcodes.SALOAD:
      case Opcodes.IADD:
      case Opcodes.LADD:
      case Opcodes.FADD:
      case Opcodes.DADD:
      case Opcodes.ISUB:
      case Opcodes.LSUB:
      case Opcodes.FSUB:
      case Opcodes.DSUB:
      case Opcodes.IMUL:
      case Opcodes.LMUL:
      case Opcodes.FMUL:
      case Opcodes.DMUL:
      case Opcodes.IDIV:
      case Opcodes.LDIV:
      case Opcodes.FDIV:
      case Opcodes.DDIV:
      case Opcodes.IREM:
      case Opcodes.LREM:
      case Opcodes.FREM:
      case Opcodes.DREM:
      case Opcodes.ISHL:
      case Opcodes.LSHL:
      case Opcodes.ISHR:
      case Opcodes.LSHR:
      case Opcodes.IUSHR:
      case Opcodes.LUSHR:
      case Opcodes.IAND:
      case Opcodes.LAND:
      case Opcodes.IOR:
      case Opcodes.LOR:
      case Opcodes.IXOR:
      case Opcodes.LXOR:
      case Opcodes.LCMP:
      case Opcodes.FCMPL:
      case Opcodes.FCMPG:
      case Opcodes.DCMPL:
      case Opcodes.DCMPG:
        value2 = pop();
        value1 = pop();
        push(interpreter.binaryOperation(insn, value1, value2));
        break;
      case Opcodes.INEG:
      case Opcodes.LNEG:
      case Opcodes.FNEG:
      case Opcodes.DNEG:
        push(interpreter.unaryOperation(insn, pop()));
        break;
      case Opcodes.IINC:
        varIndex = ((IincInsnNode) insn).var;
        setLocal(varIndex, interpreter.unaryOperation(insn, getLocal(varIndex)));
        break;
      case Opcodes.I2L:
      case Opcodes.I2F:
      case Opcodes.I2D:
      case Opcodes.L2I:
      case Opcodes.L2F:
      case Opcodes.L2D:
      case Opcodes.F2I:
      case Opcodes.F2L:
      case Opcodes.F2D:
      case Opcodes.D2I:
      case Opcodes.D2L:
      case Opcodes.D2F:
      case Opcodes.I2B:
      case Opcodes.I2C:
      case Opcodes.I2S:
        push(interpreter.unaryOperation(insn, pop()));
        break;
      case Opcodes.IFEQ:
      case Opcodes.IFNE:
      case Opcodes.IFLT:
      case Opcodes.IFGE:
      case Opcodes.IFGT:
      case Opcodes.IFLE:
        interpreter.unaryOperation(insn, pop());
        break;
      case Opcodes.IF_ICMPEQ:
      case Opcodes.IF_ICMPNE:
      case Opcodes.IF_ICMPLT:
      case Opcodes.IF_ICMPGE:
      case Opcodes.IF_ICMPGT:
      case Opcodes.IF_ICMPLE:
      case Opcodes.IF_ACMPEQ:
      case Opcodes.IF_ACMPNE:
      case Opcodes.PUTFIELD:
        value2 = pop();
        value1 = pop();
        interpreter.binaryOperation(insn, value1, value2);
        break;
      case Opcodes.GOTO:
        break;
      case Opcodes.JSR:
        push(interpreter.newOperation(insn));
        break;
      case Opcodes.RET:
        break;
      case Opcodes.TABLESWITCH:
      case Opcodes.LOOKUPSWITCH:
        interpreter.unaryOperation(insn, pop());
        break;
      case Opcodes.IRETURN:
      case Opcodes.LRETURN:
      case Opcodes.FRETURN:
      case Opcodes.DRETURN:
      case Opcodes.ARETURN:
        value1 = pop();
        interpreter.unaryOperation(insn, value1);
        interpreter.returnOperation(insn, value1, returnValue);
        break;
      case Opcodes.RETURN:
        if (returnValue != null) {
          throw new AnalyzerException(insn, "Incompatible return type");
        }
        break;
      case Opcodes.GETSTATIC:
        push(interpreter.newOperation(insn));
        break;
      case Opcodes.PUTSTATIC:
        interpreter.unaryOperation(insn, pop());
        break;
      case Opcodes.GETFIELD:
        push(interpreter.unaryOperation(insn, pop()));
        break;
      case Opcodes.INVOKEVIRTUAL:
      case Opcodes.INVOKESPECIAL:
      case Opcodes.INVOKESTATIC:
      case Opcodes.INVOKEINTERFACE:
        executeInvokeInsn(insn, ((MethodInsnNode) insn).desc, interpreter);
        break;
      case Opcodes.INVOKEDYNAMIC:
        executeInvokeInsn(insn, ((InvokeDynamicInsnNode) insn).desc, interpreter);
        break;
      case Opcodes.NEW:
        push(interpreter.newOperation(insn));
        break;
      case Opcodes.NEWARRAY:
      case Opcodes.ANEWARRAY:
      case Opcodes.ARRAYLENGTH:
        push(interpreter.unaryOperation(insn, pop()));
        break;
      case Opcodes.ATHROW:
        interpreter.unaryOperation(insn, pop());
        break;
      case Opcodes.CHECKCAST:
      case Opcodes.INSTANCEOF:
        push(interpreter.unaryOperation(insn, pop()));
        break;
      case Opcodes.MONITORENTER:
      case Opcodes.MONITOREXIT:
        interpreter.unaryOperation(insn, pop());
        break;
      case Opcodes.MULTIANEWARRAY:
        List<V> valueList = new ArrayList<>();
        for (int i = ((MultiANewArrayInsnNode) insn).dims; i > 0; --i) {
          valueList.add(0, pop());
        }
        push(interpreter.naryOperation(insn, valueList));
        break;
      case Opcodes.IFNULL:
      case Opcodes.IFNONNULL:
        interpreter.unaryOperation(insn, pop());
        break;
      default:
        throw new AnalyzerException(insn, "Illegal opcode " + insn.getOpcode());
    }
  }

  private boolean executeDupX2(
      final AbstractInsnNode insn, final V value1, final Interpreter<V> interpreter)
      throws AnalyzerException {
    V value2 = pop();
    if (value2.getSize() == 1) {
      V value3 = pop();
      if (value3.getSize() == 1) {
        push(interpreter.copyOperation(insn, value1));
        push(interpreter.copyOperation(insn, value3));
        push(interpreter.copyOperation(insn, value2));
        push(interpreter.copyOperation(insn, value1));
        return true;
      }
    } else {
      push(interpreter.copyOperation(insn, value1));
      push(interpreter.copyOperation(insn, value2));
      push(interpreter.copyOperation(insn, value1));
      return true;
    }
    return false;
  }

  private void executeInvokeInsn(
      final AbstractInsnNode insn, final String methodDescriptor, final Interpreter<V> interpreter)
      throws AnalyzerException {
    ArrayList<V> valueList = new ArrayList<>();
    for (int i = Type.getArgumentCount(methodDescriptor); i > 0; --i) {
      valueList.add(0, pop());
    }
    if (insn.getOpcode() != Opcodes.INVOKESTATIC && insn.getOpcode() != Opcodes.INVOKEDYNAMIC) {
      valueList.add(0, pop());
    }
    if (Type.getReturnType(methodDescriptor) == Type.VOID_TYPE) {
      interpreter.naryOperation(insn, valueList);
    } else {
      push(interpreter.naryOperation(insn, valueList));
    }
  }

  /**
   * Merges the given frame into this frame.
   *
   * @param frame a frame. This frame is left unchanged by this method.
   * @param interpreter the interpreter used to merge values.
   * @return {@literal true} if this frame has been changed as a result of the merge operation, or
   *     {@literal false} otherwise.
   * @throws AnalyzerException if the frames have incompatible sizes.
   */
  public boolean merge(final Frame<? extends V> frame, final Interpreter<V> interpreter)
      throws AnalyzerException {
    if (numStack != frame.numStack) {
      throw new AnalyzerException(null, "Incompatible stack heights");
    }
    boolean changed = false;
    for (int i = 0; i < numLocals + numStack; ++i) {
      V v = interpreter.merge(values[i], frame.values[i]);
      if (!v.equals(values[i])) {
        values[i] = v;
        changed = true;
      }
    }
    return changed;
  }

  /**
   * Merges the given frame into this frame (case of a subroutine). The operand stacks are not
   * merged, and only the local variables that have not been used by the subroutine are merged.
   *
   * @param frame a frame. This frame is left unchanged by this method.
   * @param localsUsed the local variables that are read or written by the subroutine. The i-th
   *     element is true if and only if the local variable at index i is read or written by the
   *     subroutine.
   * @return {@literal true} if this frame has been changed as a result of the merge operation, or
   *     {@literal false} otherwise.
   */
  public boolean merge(final Frame<? extends V> frame, final boolean[] localsUsed) {
    boolean changed = false;
    for (int i = 0; i < numLocals; ++i) {
      if (!localsUsed[i] && !values[i].equals(frame.values[i])) {
        values[i] = frame.values[i];
        changed = true;
      }
    }
    return changed;
  }

  /**
   * Returns a string representation of this frame.
   *
   * @return a string representation of this frame.
   */
  @Override
  public String toString() {
    StringBuilder stringBuilder = new StringBuilder();
    for (int i = 0; i < getLocals(); ++i) {
      stringBuilder.append(getLocal(i));
    }
    stringBuilder.append(' ');
    for (int i = 0; i < getStackSize(); ++i) {
      stringBuilder.append(getStack(i).toString());
    }
    return stringBuilder.toString();
  }
}

package org.objectweb.asm.tree.analysis;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;

/**
 * An {@link Interpreter} for {@link SourceValue} values.
 *
 * @author Eric Bruneton
 */
public class SourceInterpreter extends Interpreter<SourceValue> implements Opcodes {

  /**
   * Constructs a new {@link SourceInterpreter} for the latest ASM API version. <i>Subclasses must
   * not use this constructor</i>. Instead, they must use the {@link #SourceInterpreter(int)}
   * version.
   */
  public SourceInterpreter() {
    super(/* latest api = */ ASM9);
    if (getClass() != SourceInterpreter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link SourceInterpreter}.
   *
   * @param api the ASM API version supported by this interpreter. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected SourceInterpreter(final int api) {
    super(api);
  }

  @Override
  public SourceValue newValue(final Type type) {
    if (type == Type.VOID_TYPE) {
      return null;
    }
    return new SourceValue(type == null ? 1 : type.getSize());
  }

  @Override
  public SourceValue newOperation(final AbstractInsnNode insn) {
    int size;
    switch (insn.getOpcode()) {
      case LCONST_0:
      case LCONST_1:
      case DCONST_0:
      case DCONST_1:
        size = 2;
        break;
      case LDC:
        // Values able to be pushed by LDC:
        //   - int, float, string (object), type (Class, object), type (MethodType, object),
        //       handle (MethodHandle, object): one word
        //   - long, double, ConstantDynamic (can produce either single word values, or double word
        //       values): (up to) two words
        Object value = ((LdcInsnNode) insn).cst;
        if (value instanceof Long || value instanceof Double) {
          // two words guaranteed
          size = 2;
        } else if (value instanceof ConstantDynamic) {
          // might yield two words
          size = ((ConstantDynamic) value).getSize();
        } else {
          // one word guaranteed
          size = 1;
        }
        break;
      case GETSTATIC:
        size = Type.getType(((FieldInsnNode) insn).desc).getSize();
        break;
      default:
        size = 1;
        break;
    }
    return new SourceValue(size, insn);
  }

  @Override
  public SourceValue copyOperation(final AbstractInsnNode insn, final SourceValue value) {
    return new SourceValue(value.getSize(), insn);
  }

  @Override
  public SourceValue unaryOperation(final AbstractInsnNode insn, final SourceValue value) {
    int size;
    switch (insn.getOpcode()) {
      case LNEG:
      case DNEG:
      case I2L:
      case I2D:
      case L2D:
      case F2L:
      case F2D:
      case D2L:
        size = 2;
        break;
      case GETFIELD:
        size = Type.getType(((FieldInsnNode) insn).desc).getSize();
        break;
      default:
        size = 1;
        break;
    }
    return new SourceValue(size, insn);
  }

  @Override
  public SourceValue binaryOperation(
      final AbstractInsnNode insn, final SourceValue value1, final SourceValue value2) {
    int size;
    switch (insn.getOpcode()) {
      case LALOAD:
      case DALOAD:
      case LADD:
      case DADD:
      case LSUB:
      case DSUB:
      case LMUL:
      case DMUL:
      case LDIV:
      case DDIV:
      case LREM:
      case DREM:
      case LSHL:
      case LSHR:
      case LUSHR:
      case LAND:
      case LOR:
      case LXOR:
        size = 2;
        break;
      default:
        size = 1;
        break;
    }
    return new SourceValue(size, insn);
  }

  @Override
  public SourceValue ternaryOperation(
      final AbstractInsnNode insn,
      final SourceValue value1,
      final SourceValue value2,
      final SourceValue value3) {
    return new SourceValue(1, insn);
  }

  @Override
  public SourceValue naryOperation(
      final AbstractInsnNode insn, final List<? extends SourceValue> values) {
    int size;
    int opcode = insn.getOpcode();
    if (opcode == MULTIANEWARRAY) {
      size = 1;
    } else if (opcode == INVOKEDYNAMIC) {
      size = Type.getReturnType(((InvokeDynamicInsnNode) insn).desc).getSize();
    } else {
      size = Type.getReturnType(((MethodInsnNode) insn).desc).getSize();
    }
    return new SourceValue(size, insn);
  }

  @Override
  public void returnOperation(
      final AbstractInsnNode insn, final SourceValue value, final SourceValue expected) {
    // Nothing to do.
  }

  @Override
  public SourceValue merge(final SourceValue value1, final SourceValue value2) {
    if (value1.insns instanceof SmallSet && value2.insns instanceof SmallSet) {
      Set<AbstractInsnNode> setUnion =
          ((SmallSet<AbstractInsnNode>) value1.insns)
              .union((SmallSet<AbstractInsnNode>) value2.insns);
      if (setUnion == value1.insns && value1.size == value2.size) {
        return value1;
      } else {
        return new SourceValue(Math.min(value1.size, value2.size), setUnion);
      }
    }
    if (value1.size != value2.size || !containsAll(value1.insns, value2.insns)) {
      HashSet<AbstractInsnNode> setUnion = new HashSet<>();
      setUnion.addAll(value1.insns);
      setUnion.addAll(value2.insns);
      return new SourceValue(Math.min(value1.size, value2.size), setUnion);
    }
    return value1;
  }

  private static <E> boolean containsAll(final Set<E> self, final Set<E> other) {
    if (self.size() < other.size()) {
      return false;
    }
    return self.containsAll(other);
  }
}

package org.objectweb.asm.tree.analysis;

import java.util.AbstractSet;
import java.util.HashSet;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Set;

/**
 * An immutable set of at most two elements, optimized for speed compared to a generic set
 * implementation.
 *
 * @author Eric Bruneton
 */
final class SmallSet<T> extends AbstractSet<T> {

  /** The first element of this set, maybe {@literal null}. */
  private final T element1;

  /**
   * The second element of this set, maybe {@literal null}. If {@link #element1} is {@literal null}
   * then this field must be {@literal null}, otherwise it must be different from {@link #element1}.
   */
  private final T element2;

  // -----------------------------------------------------------------------------------------------
  // Constructors
  // -----------------------------------------------------------------------------------------------

  /** Constructs an empty set. */
  SmallSet() {
    this.element1 = null;
    this.element2 = null;
  }

  /**
   * Constructs a set with exactly one element.
   *
   * @param element the unique set element.
   */
  SmallSet(final T element) {
    this.element1 = element;
    this.element2 = null;
  }

  /**
   * Constructs a new {@link SmallSet}.
   *
   * @param element1 see {@link #element1}.
   * @param element2 see {@link #element2}.
   */
  private SmallSet(final T element1, final T element2) {
    this.element1 = element1;
    this.element2 = element2;
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the inherited abstract methods
  // -----------------------------------------------------------------------------------------------

  @Override
  public Iterator<T> iterator() {
    return new IteratorImpl<>(element1, element2);
  }

  @Override
  public int size() {
    if (element1 == null) {
      return 0;
    } else if (element2 == null) {
      return 1;
    } else {
      return 2;
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the union of this set and of the given set.
   *
   * @param otherSet another small set.
   * @return the union of this set and of otherSet.
   */
  Set<T> union(final SmallSet<T> otherSet) {
    // If the two sets are equal, return this set.
    if ((otherSet.element1 == element1 && otherSet.element2 == element2)
        || (otherSet.element1 == element2 && otherSet.element2 == element1)) {
      return this;
    }
    // If one set is empty, return the other.
    if (otherSet.element1 == null) {
      return this;
    }
    if (element1 == null) {
      return otherSet;
    }

    // At this point we know that the two sets are non empty and are different.
    // If otherSet contains exactly one element:
    if (otherSet.element2 == null) {
      // If this set also contains exactly one element, we have two distinct elements.
      if (element2 == null) {
        return new SmallSet<>(element1, otherSet.element1);
      }
      // If otherSet is included in this set, return this set.
      if (otherSet.element1 == element1 || otherSet.element1 == element2) {
        return this;
      }
    }
    // If this set contains exactly one element, then otherSet contains two elements (because of the
    // above tests). Thus, if otherSet contains this set, return otherSet:
    if (element2 == null && (element1 == otherSet.element1 || element1 == otherSet.element2)) {
      return otherSet;
    }

    // At this point we know that there are at least 3 distinct elements, so we need a generic set
    // to store the result.
    HashSet<T> result = new HashSet<>(4);
    result.add(element1);
    if (element2 != null) {
      result.add(element2);
    }
    result.add(otherSet.element1);
    if (otherSet.element2 != null) {
      result.add(otherSet.element2);
    }
    return result;
  }

  static class IteratorImpl<T> implements Iterator<T> {

    /** The next element to return in {@link #next}. Maybe {@literal null}. */
    private T firstElement;

    /**
     * The element to return in {@link #next}, after {@link #firstElement} is returned. If {@link
     * #firstElement} is {@literal null} then this field must be {@literal null}, otherwise it must
     * be different from {@link #firstElement}.
     */
    private T secondElement;

    IteratorImpl(final T firstElement, final T secondElement) {
      this.firstElement = firstElement;
      this.secondElement = secondElement;
    }

    @Override
    public boolean hasNext() {
      return firstElement != null;
    }

    @Override
    public T next() {
      if (firstElement == null) {
        throw new NoSuchElementException();
      }
      T element = firstElement;
      firstElement = secondElement;
      secondElement = null;
      return element;
    }

    @Override
    public void remove() {
      throw new UnsupportedOperationException();
    }
  }
}

package org.objectweb.asm.tree.analysis;

/**
 * An immutable symbolic value for the semantic interpretation of bytecode.
 *
 * @author Eric Bruneton
 */
public interface Value {

  /**
   * Returns the size of this value in 32 bits words. This size should be 1 for byte, boolean, char,
   * short, int, float, object and array types, and 2 for long and double.
   *
   * @return either 1 or 2.
   */
  int getSize();
}

package org.objectweb.asm.tree.analysis;

import org.objectweb.asm.Type;

/**
 * A {@link Value} that is represented with its type in a seven types type system. This type system
 * distinguishes the UNINITIALZED, INT, FLOAT, LONG, DOUBLE, REFERENCE and RETURNADDRESS types.
 *
 * @author Eric Bruneton
 */
public class BasicValue implements Value {

  /** An uninitialized value. */
  public static final BasicValue UNINITIALIZED_VALUE = new BasicValue(null);

  /** A byte, boolean, char, short, or int value. */
  public static final BasicValue INT_VALUE = new BasicValue(Type.INT_TYPE);

  /** A float value. */
  public static final BasicValue FLOAT_VALUE = new BasicValue(Type.FLOAT_TYPE);

  /** A long value. */
  public static final BasicValue LONG_VALUE = new BasicValue(Type.LONG_TYPE);

  /** A double value. */
  public static final BasicValue DOUBLE_VALUE = new BasicValue(Type.DOUBLE_TYPE);

  /** An object or array reference value. */
  public static final BasicValue REFERENCE_VALUE =
      new BasicValue(Type.getObjectType("java/lang/Object"));

  /** A return address value (produced by a jsr instruction). */
  public static final BasicValue RETURNADDRESS_VALUE = new BasicValue(Type.VOID_TYPE);

  /** The {@link Type} of this value, or {@literal null} for uninitialized values. */
  private final Type type;

  /**
   * Constructs a new {@link BasicValue} of the given type.
   *
   * @param type the value type.
   */
  public BasicValue(final Type type) {
    this.type = type;
  }

  /**
   * Returns the {@link Type} of this value.
   *
   * @return the {@link Type} of this value.
   */
  public Type getType() {
    return type;
  }

  @Override
  public int getSize() {
    return type == Type.LONG_TYPE || type == Type.DOUBLE_TYPE ? 2 : 1;
  }

  /**
   * Returns whether this value corresponds to an object or array reference.
   *
   * @return whether this value corresponds to an object or array reference.
   */
  public boolean isReference() {
    return type != null && (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY);
  }

  @Override
  public boolean equals(final Object value) {
    if (value == this) {
      return true;
    } else if (value instanceof BasicValue) {
      if (type == null) {
        return ((BasicValue) value).type == null;
      } else {
        return type.equals(((BasicValue) value).type);
      }
    } else {
      return false;
    }
  }

  @Override
  public int hashCode() {
    return type == null ? 0 : type.hashCode();
  }

  @Override
  public String toString() {
    if (this == UNINITIALIZED_VALUE) {
      return ".";
    } else if (this == RETURNADDRESS_VALUE) {
      return "A";
    } else if (this == REFERENCE_VALUE) {
      return "R";
    } else {
      return type.getDescriptor();
    }
  }
}

package org.objectweb.asm.tree.analysis;

import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;

/**
 * An extended {@link BasicInterpreter} that checks that bytecode instructions are correctly used.
 *
 * @author Eric Bruneton
 * @author Bing Ran
 */
public class BasicVerifier extends BasicInterpreter {

  /**
   * Constructs a new {@link BasicVerifier} for the latest ASM API version. <i>Subclasses must not
   * use this constructor</i>. Instead, they must use the {@link #BasicVerifier(int)} version.
   */
  public BasicVerifier() {
    super(/* latest api = */ ASM9);
    if (getClass() != BasicVerifier.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link BasicVerifier}.
   *
   * @param api the ASM API version supported by this interpreter. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected BasicVerifier(final int api) {
    super(api);
  }

  @Override
  public BasicValue copyOperation(final AbstractInsnNode insn, final BasicValue value)
      throws AnalyzerException {
    Value expected;
    switch (insn.getOpcode()) {
      case ILOAD:
      case ISTORE:
        expected = BasicValue.INT_VALUE;
        break;
      case FLOAD:
      case FSTORE:
        expected = BasicValue.FLOAT_VALUE;
        break;
      case LLOAD:
      case LSTORE:
        expected = BasicValue.LONG_VALUE;
        break;
      case DLOAD:
      case DSTORE:
        expected = BasicValue.DOUBLE_VALUE;
        break;
      case ALOAD:
        if (!value.isReference()) {
          throw new AnalyzerException(insn, null, "an object reference", value);
        }
        return value;
      case ASTORE:
        if (!value.isReference() && !BasicValue.RETURNADDRESS_VALUE.equals(value)) {
          throw new AnalyzerException(insn, null, "an object reference or a return address", value);
        }
        return value;
      default:
        return value;
    }
    if (!expected.equals(value)) {
      throw new AnalyzerException(insn, null, expected, value);
    }
    return value;
  }

  @Override
  public BasicValue unaryOperation(final AbstractInsnNode insn, final BasicValue value)
      throws AnalyzerException {
    BasicValue expected;
    switch (insn.getOpcode()) {
      case INEG:
      case IINC:
      case I2F:
      case I2L:
      case I2D:
      case I2B:
      case I2C:
      case I2S:
      case IFEQ:
      case IFNE:
      case IFLT:
      case IFGE:
      case IFGT:
      case IFLE:
      case TABLESWITCH:
      case LOOKUPSWITCH:
      case IRETURN:
      case NEWARRAY:
      case ANEWARRAY:
        expected = BasicValue.INT_VALUE;
        break;
      case FNEG:
      case F2I:
      case F2L:
      case F2D:
      case FRETURN:
        expected = BasicValue.FLOAT_VALUE;
        break;
      case LNEG:
      case L2I:
      case L2F:
      case L2D:
      case LRETURN:
        expected = BasicValue.LONG_VALUE;
        break;
      case DNEG:
      case D2I:
      case D2F:
      case D2L:
      case DRETURN:
        expected = BasicValue.DOUBLE_VALUE;
        break;
      case GETFIELD:
        expected = newValue(Type.getObjectType(((FieldInsnNode) insn).owner));
        break;
      case ARRAYLENGTH:
        if (!isArrayValue(value)) {
          throw new AnalyzerException(insn, null, "an array reference", value);
        }
        return super.unaryOperation(insn, value);
      case CHECKCAST:
      case ARETURN:
      case ATHROW:
      case INSTANCEOF:
      case MONITORENTER:
      case MONITOREXIT:
      case IFNULL:
      case IFNONNULL:
        if (!value.isReference()) {
          throw new AnalyzerException(insn, null, "an object reference", value);
        }
        return super.unaryOperation(insn, value);
      case PUTSTATIC:
        expected = newValue(Type.getType(((FieldInsnNode) insn).desc));
        break;
      default:
        throw new AssertionError();
    }
    if (!isSubTypeOf(value, expected)) {
      throw new AnalyzerException(insn, null, expected, value);
    }
    return super.unaryOperation(insn, value);
  }

  @Override
  public BasicValue binaryOperation(
      final AbstractInsnNode insn, final BasicValue value1, final BasicValue value2)
      throws AnalyzerException {
    BasicValue expected1;
    BasicValue expected2;
    switch (insn.getOpcode()) {
      case IALOAD:
        expected1 = newValue(Type.getType("[I"));
        expected2 = BasicValue.INT_VALUE;
        break;
      case BALOAD:
        if (isSubTypeOf(value1, newValue(Type.getType("[Z")))) {
          expected1 = newValue(Type.getType("[Z"));
        } else {
          expected1 = newValue(Type.getType("[B"));
        }
        expected2 = BasicValue.INT_VALUE;
        break;
      case CALOAD:
        expected1 = newValue(Type.getType("[C"));
        expected2 = BasicValue.INT_VALUE;
        break;
      case SALOAD:
        expected1 = newValue(Type.getType("[S"));
        expected2 = BasicValue.INT_VALUE;
        break;
      case LALOAD:
        expected1 = newValue(Type.getType("[J"));
        expected2 = BasicValue.INT_VALUE;
        break;
      case FALOAD:
        expected1 = newValue(Type.getType("[F"));
        expected2 = BasicValue.INT_VALUE;
        break;
      case DALOAD:
        expected1 = newValue(Type.getType("[D"));
        expected2 = BasicValue.INT_VALUE;
        break;
      case AALOAD:
        expected1 = newValue(Type.getType("[Ljava/lang/Object;"));
        expected2 = BasicValue.INT_VALUE;
        break;
      case IADD:
      case ISUB:
      case IMUL:
      case IDIV:
      case IREM:
      case ISHL:
      case ISHR:
      case IUSHR:
      case IAND:
      case IOR:
      case IXOR:
      case IF_ICMPEQ:
      case IF_ICMPNE:
      case IF_ICMPLT:
      case IF_ICMPGE:
      case IF_ICMPGT:
      case IF_ICMPLE:
        expected1 = BasicValue.INT_VALUE;
        expected2 = BasicValue.INT_VALUE;
        break;
      case FADD:
      case FSUB:
      case FMUL:
      case FDIV:
      case FREM:
      case FCMPL:
      case FCMPG:
        expected1 = BasicValue.FLOAT_VALUE;
        expected2 = BasicValue.FLOAT_VALUE;
        break;
      case LADD:
      case LSUB:
      case LMUL:
      case LDIV:
      case LREM:
      case LAND:
      case LOR:
      case LXOR:
      case LCMP:
        expected1 = BasicValue.LONG_VALUE;
        expected2 = BasicValue.LONG_VALUE;
        break;
      case LSHL:
      case LSHR:
      case LUSHR:
        expected1 = BasicValue.LONG_VALUE;
        expected2 = BasicValue.INT_VALUE;
        break;
      case DADD:
      case DSUB:
      case DMUL:
      case DDIV:
      case DREM:
      case DCMPL:
      case DCMPG:
        expected1 = BasicValue.DOUBLE_VALUE;
        expected2 = BasicValue.DOUBLE_VALUE;
        break;
      case IF_ACMPEQ:
      case IF_ACMPNE:
        expected1 = BasicValue.REFERENCE_VALUE;
        expected2 = BasicValue.REFERENCE_VALUE;
        break;
      case PUTFIELD:
        FieldInsnNode fieldInsn = (FieldInsnNode) insn;
        expected1 = newValue(Type.getObjectType(fieldInsn.owner));
        expected2 = newValue(Type.getType(fieldInsn.desc));
        break;
      default:
        throw new AssertionError();
    }
    if (!isSubTypeOf(value1, expected1)) {
      throw new AnalyzerException(insn, "First argument", expected1, value1);
    } else if (!isSubTypeOf(value2, expected2)) {
      throw new AnalyzerException(insn, "Second argument", expected2, value2);
    }
    if (insn.getOpcode() == AALOAD) {
      return getElementValue(value1);
    } else {
      return super.binaryOperation(insn, value1, value2);
    }
  }

  @Override
  public BasicValue ternaryOperation(
      final AbstractInsnNode insn,
      final BasicValue value1,
      final BasicValue value2,
      final BasicValue value3)
      throws AnalyzerException {
    BasicValue expected1;
    BasicValue expected3;
    switch (insn.getOpcode()) {
      case IASTORE:
        expected1 = newValue(Type.getType("[I"));
        expected3 = BasicValue.INT_VALUE;
        break;
      case BASTORE:
        if (isSubTypeOf(value1, newValue(Type.getType("[Z")))) {
          expected1 = newValue(Type.getType("[Z"));
        } else {
          expected1 = newValue(Type.getType("[B"));
        }
        expected3 = BasicValue.INT_VALUE;
        break;
      case CASTORE:
        expected1 = newValue(Type.getType("[C"));
        expected3 = BasicValue.INT_VALUE;
        break;
      case SASTORE:
        expected1 = newValue(Type.getType("[S"));
        expected3 = BasicValue.INT_VALUE;
        break;
      case LASTORE:
        expected1 = newValue(Type.getType("[J"));
        expected3 = BasicValue.LONG_VALUE;
        break;
      case FASTORE:
        expected1 = newValue(Type.getType("[F"));
        expected3 = BasicValue.FLOAT_VALUE;
        break;
      case DASTORE:
        expected1 = newValue(Type.getType("[D"));
        expected3 = BasicValue.DOUBLE_VALUE;
        break;
      case AASTORE:
        expected1 = value1;
        expected3 = BasicValue.REFERENCE_VALUE;
        break;
      default:
        throw new AssertionError();
    }
    if (!isSubTypeOf(value1, expected1)) {
      throw new AnalyzerException(
          insn, "First argument", "a " + expected1 + " array reference", value1);
    } else if (!BasicValue.INT_VALUE.equals(value2)) {
      throw new AnalyzerException(insn, "Second argument", BasicValue.INT_VALUE, value2);
    } else if (!isSubTypeOf(value3, expected3)) {
      throw new AnalyzerException(insn, "Third argument", expected3, value3);
    }
    return null;
  }

  @Override
  public BasicValue naryOperation(
      final AbstractInsnNode insn, final List<? extends BasicValue> values)
      throws AnalyzerException {
    int opcode = insn.getOpcode();
    if (opcode == MULTIANEWARRAY) {
      for (BasicValue value : values) {
        if (!BasicValue.INT_VALUE.equals(value)) {
          throw new AnalyzerException(insn, null, BasicValue.INT_VALUE, value);
        }
      }
    } else {
      int i = 0;
      int j = 0;
      if (opcode != INVOKESTATIC && opcode != INVOKEDYNAMIC) {
        Type owner = Type.getObjectType(((MethodInsnNode) insn).owner);
        if (!isSubTypeOf(values.get(i++), newValue(owner))) {
          throw new AnalyzerException(insn, "Method owner", newValue(owner), values.get(0));
        }
      }
      String methodDescriptor =
          (opcode == INVOKEDYNAMIC)
              ? ((InvokeDynamicInsnNode) insn).desc
              : ((MethodInsnNode) insn).desc;
      Type[] args = Type.getArgumentTypes(methodDescriptor);
      while (i < values.size()) {
        BasicValue expected = newValue(args[j++]);
        BasicValue actual = values.get(i++);
        if (!isSubTypeOf(actual, expected)) {
          throw new AnalyzerException(insn, "Argument " + j, expected, actual);
        }
      }
    }
    return super.naryOperation(insn, values);
  }

  @Override
  public void returnOperation(
      final AbstractInsnNode insn, final BasicValue value, final BasicValue expected)
      throws AnalyzerException {
    if (!isSubTypeOf(value, expected)) {
      throw new AnalyzerException(insn, "Incompatible return type", expected, value);
    }
  }

  /**
   * Returns whether the given value corresponds to an array reference.
   *
   * @param value a value.
   * @return whether 'value' corresponds to an array reference.
   */
  protected boolean isArrayValue(final BasicValue value) {
    return value.isReference();
  }

  /**
   * Returns the value corresponding to the type of the elements of the given array reference value.
   *
   * @param objectArrayValue a value corresponding to array of object (or array) references.
   * @return the value corresponding to the type of the elements of 'objectArrayValue'.
   * @throws AnalyzerException if objectArrayValue does not correspond to an array type.
   */
  protected BasicValue getElementValue(final BasicValue objectArrayValue) throws AnalyzerException {
    return BasicValue.REFERENCE_VALUE;
  }

  /**
   * Returns whether the type corresponding to the first argument is a subtype of the type
   * corresponding to the second argument.
   *
   * @param value a value.
   * @param expected another value.
   * @return whether the type corresponding to 'value' is a subtype of the type corresponding to
   *     'expected'.
   */
  protected boolean isSubTypeOf(final BasicValue value, final BasicValue expected) {
    return value.equals(expected);
  }
}

package org.objectweb.asm.tree.analysis;

import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * An extended {@link BasicVerifier} that performs more precise verifications. This verifier
 * computes exact class types, instead of using a single "object reference" type (as done in {@link
 * BasicVerifier}).
 *
 * @author Eric Bruneton
 * @author Bing Ran
 */
public class SimpleVerifier extends BasicVerifier {

  /** The type of the Object class. */
  private static final Type OBJECT_TYPE = Type.getObjectType("java/lang/Object");

  /** The type of the class that is verified. */
  private final Type currentClass;

  /** The type of the super class of the class that is verified. */
  private final Type currentSuperClass;

  /** The types of the interfaces directly implemented by the class that is verified. */
  private final List<Type> currentClassInterfaces;

  /** Whether the class that is verified is an interface. */
  private final boolean isInterface;

  /** The loader to use to load the referenced classes. */
  private ClassLoader loader = getClass().getClassLoader();

  /**
   * Constructs a new {@link SimpleVerifier}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #SimpleVerifier(int, Type, Type, List, boolean)} version.
   */
  public SimpleVerifier() {
    this(null, null, false);
  }

  /**
   * Constructs a new {@link SimpleVerifier} to verify a specific class. This class will not be
   * loaded into the JVM since it may be incorrect. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #SimpleVerifier(int, Type, Type, List, boolean)} version.
   *
   * @param currentClass the type of the class to be verified.
   * @param currentSuperClass the type of the super class of the class to be verified.
   * @param isInterface whether the class to be verifier is an interface.
   */
  public SimpleVerifier(
      final Type currentClass, final Type currentSuperClass, final boolean isInterface) {
    this(currentClass, currentSuperClass, null, isInterface);
  }

  /**
   * Constructs a new {@link SimpleVerifier} to verify a specific class. This class will not be
   * loaded into the JVM since it may be incorrect. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #SimpleVerifier(int, Type, Type, List, boolean)} version.
   *
   * @param currentClass the type of the class to be verified.
   * @param currentSuperClass the type of the super class of the class to be verified.
   * @param currentClassInterfaces the types of the interfaces directly implemented by the class to
   *     be verified.
   * @param isInterface whether the class to be verifier is an interface.
   */
  public SimpleVerifier(
      final Type currentClass,
      final Type currentSuperClass,
      final List<Type> currentClassInterfaces,
      final boolean isInterface) {
    this(
        /* latest api = */ ASM9,
        currentClass,
        currentSuperClass,
        currentClassInterfaces,
        isInterface);
    if (getClass() != SimpleVerifier.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link SimpleVerifier} to verify a specific class. This class will not be
   * loaded into the JVM since it may be incorrect.
   *
   * @param api the ASM API version supported by this verifier. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param currentClass the type of the class to be verified.
   * @param currentSuperClass the type of the super class of the class to be verified.
   * @param currentClassInterfaces the types of the interfaces directly implemented by the class to
   *     be verified.
   * @param isInterface whether the class to be verifier is an interface.
   */
  protected SimpleVerifier(
      final int api,
      final Type currentClass,
      final Type currentSuperClass,
      final List<Type> currentClassInterfaces,
      final boolean isInterface) {
    super(api);
    this.currentClass = currentClass;
    this.currentSuperClass = currentSuperClass;
    this.currentClassInterfaces = currentClassInterfaces;
    this.isInterface = isInterface;
  }

  /**
   * Sets the <code>ClassLoader</code> to be used in {@link #getClass}.
   *
   * @param loader the <code>ClassLoader</code> to use.
   */
  public void setClassLoader(final ClassLoader loader) {
    this.loader = loader;
  }

  @Override
  public BasicValue newValue(final Type type) {
    if (type == null) {
      return BasicValue.UNINITIALIZED_VALUE;
    }

    boolean isArray = type.getSort() == Type.ARRAY;
    if (isArray) {
      switch (type.getElementType().getSort()) {
        case Type.BOOLEAN:
        case Type.CHAR:
        case Type.BYTE:
        case Type.SHORT:
          return new BasicValue(type);
        default:
          break;
      }
    }

    BasicValue value = super.newValue(type);
    if (BasicValue.REFERENCE_VALUE.equals(value)) {
      if (isArray) {
        value = newValue(type.getElementType());
        StringBuilder descriptor = new StringBuilder();
        for (int i = 0; i < type.getDimensions(); ++i) {
          descriptor.append('[');
        }
        descriptor.append(value.getType().getDescriptor());
        value = new BasicValue(Type.getType(descriptor.toString()));
      } else {
        value = new BasicValue(type);
      }
    }
    return value;
  }

  @Override
  protected boolean isArrayValue(final BasicValue value) {
    Type type = value.getType();
    return type != null && (type.getSort() == Type.ARRAY || type.equals(NULL_TYPE));
  }

  @Override
  protected BasicValue getElementValue(final BasicValue objectArrayValue) throws AnalyzerException {
    Type arrayType = objectArrayValue.getType();
    if (arrayType != null) {
      if (arrayType.getSort() == Type.ARRAY) {
        return newValue(Type.getType(arrayType.getDescriptor().substring(1)));
      } else if (arrayType.equals(NULL_TYPE)) {
        return objectArrayValue;
      }
    }
    throw new AssertionError();
  }

  @Override
  protected boolean isSubTypeOf(final BasicValue value, final BasicValue expected) {
    Type type = value.getType();
    Type expectedType = expected.getType();
    // Null types correspond to BasicValue.UNINITIALIZED_VALUE.
    if (type == null || expectedType == null) {
      return type == null && expectedType == null;
    }
    if (type.equals(expectedType)) {
      return true;
    }
    switch (expectedType.getSort()) {
      case Type.INT:
      case Type.FLOAT:
      case Type.LONG:
      case Type.DOUBLE:
        return false;
      case Type.ARRAY:
      case Type.OBJECT:
        if (type.equals(NULL_TYPE)) {
          return true;
        }
        // Convert 'type' to its element type and array dimension. Arrays of primitive values are
        // seen as Object arrays with one dimension less. Hence the element type is always of
        // Type.OBJECT sort.
        int dim = 0;
        if (type.getSort() == Type.ARRAY) {
          dim = type.getDimensions();
          type = type.getElementType();
          if (type.getSort() != Type.OBJECT) {
            dim = dim - 1;
            type = OBJECT_TYPE;
          }
        }
        // Do the same for expectedType.
        int expectedDim = 0;
        if (expectedType.getSort() == Type.ARRAY) {
          expectedDim = expectedType.getDimensions();
          expectedType = expectedType.getElementType();
          if (expectedType.getSort() != Type.OBJECT) {
            // If the expected type is an array of some primitive type, it does not have any subtype
            // other than itself. And 'type' is different by hypothesis.
            return false;
          }
        }
        // A type with less dimensions than expected can't be a subtype of the expected type.
        if (dim < expectedDim) {
          return false;
        }
        // A type with more dimensions than expected is seen as an array with the expected
        // dimensions but with an Object element type. For instance an array of arrays of Integer is
        // seen as an array of Object if the expected type is an array of Serializable.
        if (dim > expectedDim) {
          type = OBJECT_TYPE;
        }
        // type and expectedType have a Type.OBJECT sort by construction (see above),
        // as expected by isAssignableFrom.
        if (isAssignableFrom(expectedType, type)) {
          return true;
        }
        if (getClass(expectedType).isInterface()) {
          // The merge of class or interface types can only yield class types (because it is not
          // possible in general to find an unambiguous common super interface, due to multiple
          // inheritance). Because of this limitation, we need to relax the subtyping check here
          // if 'value' is an interface.
          return Object.class.isAssignableFrom(getClass(type));
        } else {
          return false;
        }
      default:
        throw new AssertionError();
    }
  }

  @Override
  public BasicValue merge(final BasicValue value1, final BasicValue value2) {
    Type type1 = value1.getType();
    Type type2 = value2.getType();
    // Null types correspond to BasicValue.UNINITIALIZED_VALUE.
    if (type1 == null || type2 == null) {
      return BasicValue.UNINITIALIZED_VALUE;
    }
    if (type1.equals(type2)) {
      return value1;
    }
    // The merge of a primitive type with a different type is the type of uninitialized values.
    if (type1.getSort() != Type.OBJECT && type1.getSort() != Type.ARRAY) {
      return BasicValue.UNINITIALIZED_VALUE;
    }
    if (type2.getSort() != Type.OBJECT && type2.getSort() != Type.ARRAY) {
      return BasicValue.UNINITIALIZED_VALUE;
    }
    // Special case for the type of the "null" literal.
    if (type1.equals(NULL_TYPE)) {
      return value2;
    }
    if (type2.equals(NULL_TYPE)) {
      return value1;
    }
    // Convert type1 to its element type and array dimension. Arrays of primitive values are seen as
    // Object arrays with one dimension less. Hence the element type is always of Type.OBJECT sort.
    int dim1 = 0;
    if (type1.getSort() == Type.ARRAY) {
      dim1 = type1.getDimensions();
      type1 = type1.getElementType();
      if (type1.getSort() != Type.OBJECT) {
        dim1 = dim1 - 1;
        type1 = OBJECT_TYPE;
      }
    }
    // Do the same for type2.
    int dim2 = 0;
    if (type2.getSort() == Type.ARRAY) {
      dim2 = type2.getDimensions();
      type2 = type2.getElementType();
      if (type2.getSort() != Type.OBJECT) {
        dim2 = dim2 - 1;
        type2 = OBJECT_TYPE;
      }
    }
    // The merge of array types of different dimensions is an Object array type.
    if (dim1 != dim2) {
      return newArrayValue(OBJECT_TYPE, Math.min(dim1, dim2));
    }
    // Type1 and type2 have a Type.OBJECT sort by construction (see above),
    // as expected by isAssignableFrom.
    if (isAssignableFrom(type1, type2)) {
      return newArrayValue(type1, dim1);
    }
    if (isAssignableFrom(type2, type1)) {
      return newArrayValue(type2, dim1);
    }
    if (!isInterface(type1)) {
      while (!type1.equals(OBJECT_TYPE)) {
        type1 = getSuperClass(type1);
        if (isAssignableFrom(type1, type2)) {
          return newArrayValue(type1, dim1);
        }
      }
    }
    return newArrayValue(OBJECT_TYPE, dim1);
  }

  private BasicValue newArrayValue(final Type type, final int dimensions) {
    if (dimensions == 0) {
      return newValue(type);
    } else {
      StringBuilder descriptor = new StringBuilder();
      for (int i = 0; i < dimensions; ++i) {
        descriptor.append('[');
      }
      descriptor.append(type.getDescriptor());
      return newValue(Type.getType(descriptor.toString()));
    }
  }

  /**
   * Returns whether the given type corresponds to the type of an interface. The default
   * implementation of this method loads the class and uses the reflection API to return its result
   * (unless the given type corresponds to the class being verified).
   *
   * @param type an object reference type (i.e., with Type.OBJECT sort).
   * @return whether 'type' corresponds to an interface.
   */
  protected boolean isInterface(final Type type) {
    if (currentClass != null && currentClass.equals(type)) {
      return isInterface;
    }
    return getClass(type).isInterface();
  }

  /**
   * Returns the type corresponding to the super class of the given type. The default implementation
   * of this method loads the class and uses the reflection API to return its result (unless the
   * given type corresponds to the class being verified).
   *
   * @param type an object reference type (i.e., with Type.OBJECT sort).
   * @return the type corresponding to the super class of 'type', or {@literal null} if 'type' is
   *     the type of the Object class.
   */
  protected Type getSuperClass(final Type type) {
    if (currentClass != null && currentClass.equals(type)) {
      return currentSuperClass;
    }
    Class<?> superClass = getClass(type).getSuperclass();
    return superClass == null ? null : Type.getType(superClass);
  }

  /**
   * Returns whether the class corresponding to the first argument is either the same as, or is a
   * superclass or superinterface of the class corresponding to the second argument. The default
   * implementation of this method loads the classes and uses the reflection API to return its
   * result (unless the result can be computed from the class being verified, and the types of its
   * super classes and implemented interfaces).
   *
   * @param type1 an object reference type (i.e., with Type.OBJECT sort).
   * @param type2 another object reference type (i.e., with Type.OBJECT sort).
   * @return whether the class corresponding to 'type1' is either the same as, or is a superclass or
   *     superinterface of the class corresponding to 'type2'.
   */
  protected boolean isAssignableFrom(final Type type1, final Type type2) {
    if (type1.equals(type2)) {
      return true;
    }
    if (currentClass != null && currentClass.equals(type1)) {
      Type superType2 = getSuperClass(type2);
      if (superType2 == null) {
        return false;
      }
      if (isInterface) {
        // This should always be true, given the preconditions of this method, but is kept for
        // backward compatibility.
        return type2.getSort() == Type.OBJECT || type2.getSort() == Type.ARRAY;
      }
      return isAssignableFrom(type1, superType2);
    }
    if (currentClass != null && currentClass.equals(type2)) {
      if (isAssignableFrom(type1, currentSuperClass)) {
        return true;
      }
      if (currentClassInterfaces != null) {
        for (Type currentClassInterface : currentClassInterfaces) {
          if (isAssignableFrom(type1, currentClassInterface)) {
            return true;
          }
        }
      }
      return false;
    }
    return getClass(type1).isAssignableFrom(getClass(type2));
  }

  /**
   * Loads the class corresponding to the given type. The class is loaded with the class loader
   * specified with {@link #setClassLoader}, or with the class loader of this class if no class
   * loader was specified.
   *
   * @param type an object reference type (i.e., with Type.OBJECT sort).
   * @return the class corresponding to 'type'.
   */
  protected Class<?> getClass(final Type type) {
    try {
      if (type.getSort() == Type.ARRAY) {
        // This should never happen, given the preconditions of this method, but is kept for
        // backward compatibility.
        return Class.forName(type.getDescriptor().replace('/', '.'), false, loader);
      }
      return Class.forName(type.getClassName(), false, loader);
    } catch (ClassNotFoundException e) {
      throw new TypeNotPresentException(e.toString(), e);
    }
  }
}

package org.objectweb.asm;

/**
 * Exception thrown when the Code attribute of a method produced by a {@link ClassWriter} is too
 * large.
 *
 * @author Jason Zaugg
 */
public final class MethodTooLargeException extends IndexOutOfBoundsException {
  private static final long serialVersionUID = 6807380416709738314L;

  private final String className;
  private final String methodName;
  private final String descriptor;
  private final int codeSize;

  /**
   * Constructs a new {@link MethodTooLargeException}.
   *
   * @param className the internal name of the owner class (see {@link Type#getInternalName()}).
   * @param methodName the name of the method.
   * @param descriptor the descriptor of the method.
   * @param codeSize the size of the method's Code attribute, in bytes.
   */
  public MethodTooLargeException(
      final @InternalForm String className,
      final String methodName,
      final String descriptor,
      final int codeSize) {
    super("Method too large: " + className + "." + methodName + " " + descriptor);
    this.className = className;
    this.methodName = methodName;
    this.descriptor = descriptor;
    this.codeSize = codeSize;
  }

  /**
   * Returns the internal name of the owner class.
   *
   * @return the internal name of the owner class (see {@link Type#getInternalName()}).
   */
  public @InternalForm String getClassName() {
    return className;
  }

  /**
   * Returns the name of the method.
   *
   * @return the name of the method.
   */
  public String getMethodName() {
    return methodName;
  }

  /**
   * Returns the descriptor of the method.
   *
   * @return the descriptor of the method.
   */
  public String getDescriptor() {
    return descriptor;
  }

  /**
   * Returns the size of the method's Code attribute, in bytes.
   *
   * @return the size of the method's Code attribute, in bytes.
   */
  public int getCodeSize() {
    return codeSize;
  }
}

package org.objectweb.asm;

/**
 * A visitor to visit a Java field. The methods of this class must be called in the following order:
 * ( {@code visitAnnotation} | {@code visitTypeAnnotation} | {@code visitAttribute} )* {@code
 * visitEnd}.
 *
 * @author Eric Bruneton
 */
public abstract class FieldVisitor {

  /**
   * The ASM API version implemented by this visitor. The value of this field must be one of the
   * {@code ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected final int api;

  /** The field visitor to which this visitor must delegate method calls. May be {@literal null}. */
  protected FieldVisitor fv;

  /**
   * Constructs a new {@link FieldVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected FieldVisitor(final int api) {
    this(api, null);
  }

  /**
   * Constructs a new {@link FieldVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param fieldVisitor the field visitor to which this visitor must delegate method calls. May be
   *     null.
   */
  protected FieldVisitor(final int api, final FieldVisitor fieldVisitor) {
    if (api != Opcodes.ASM9
        && api != Opcodes.ASM8
        && api != Opcodes.ASM7
        && api != Opcodes.ASM6
        && api != Opcodes.ASM5
        && api != Opcodes.ASM4
        && api != Opcodes.ASM10_EXPERIMENTAL) {
      throw new IllegalArgumentException("Unsupported api " + api);
    }
    if (api == Opcodes.ASM10_EXPERIMENTAL) {
      Constants.checkAsmExperimental(this);
    }
    this.api = api;
    this.fv = fieldVisitor;
  }

  /**
   * The field visitor to which this visitor must delegate method calls. May be {@literal null}.
   *
   * @return the field visitor to which this visitor must delegate method calls, or {@literal null}.
   */
  public FieldVisitor getDelegate() {
    return fv;
  }

  /**
   * Visits an annotation of the field.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (fv != null) {
      return fv.visitAnnotation(descriptor, visible);
    }
    return null;
  }

  /**
   * Visits an annotation on the type of the field.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#FIELD}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException("This feature requires ASM5");
    }
    if (fv != null) {
      return fv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a non standard attribute of the field.
   *
   * @param attribute an attribute.
   */
  public void visitAttribute(final Attribute attribute) {
    if (fv != null) {
      fv.visitAttribute(attribute);
    }
  }

  /**
   * Visits the end of the field. This method, which is the last one to be called, is used to inform
   * the visitor that all the annotations and attributes of the field have been visited.
   */
  public void visitEnd() {
    if (fv != null) {
      fv.visitEnd();
    }
  }
}

package org.objectweb.asm;

/**
 * A visitor to visit a Java method. The methods of this class must be called in the following
 * order: ( {@code visitParameter} )* [ {@code visitAnnotationDefault} ] ( {@code visitAnnotation} |
 * {@code visitAnnotableParameterCount} | {@code visitParameterAnnotation} | {@code
 * visitTypeAnnotation} | {@code visitAttribute} )* [ {@code visitCode} ( {@code visitFrame} |
 * {@code visit<i>X</i>Insn} | {@code visitLabel} | {@code visitInsnAnnotation} | {@code
 * visitTryCatchBlock} | {@code visitTryCatchAnnotation} | {@code visitLocalVariable} | {@code
 * visitLocalVariableAnnotation} | {@code visitLineNumber} | {@code visitAttribute} )* {@code
 * visitMaxs} ] {@code visitEnd}. In addition, the {@code visit<i>X</i>Insn} and {@code visitLabel}
 * methods must be called in the sequential order of the bytecode instructions of the visited code,
 * {@code visitInsnAnnotation} must be called <i>after</i> the annotated instruction, {@code
 * visitTryCatchBlock} must be called <i>before</i> the labels passed as arguments have been
 * visited, {@code visitTryCatchBlockAnnotation} must be called <i>after</i> the corresponding try
 * catch block has been visited, and the {@code visitLocalVariable}, {@code
 * visitLocalVariableAnnotation} and {@code visitLineNumber} methods must be called <i>after</i> the
 * labels passed as arguments have been visited. Finally, the {@code visitAttribute} method must be
 * called before {@code visitCode} for non-code attributes, and after it for code attributes.
 *
 * @author Eric Bruneton
 */
public abstract class MethodVisitor {

  private static final String REQUIRES_ASM5 = "This feature requires ASM5";

  /**
   * The ASM API version implemented by this visitor. The value of this field must be one of the
   * {@code ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected final int api;

  /**
   * The method visitor to which this visitor must delegate method calls. May be {@literal null}.
   */
  protected MethodVisitor mv;

  /**
   * Constructs a new {@link MethodVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected MethodVisitor(final int api) {
    this(api, null);
  }

  /**
   * Constructs a new {@link MethodVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param methodVisitor the method visitor to which this visitor must delegate method calls. May
   *     be null.
   */
  protected MethodVisitor(final int api, final MethodVisitor methodVisitor) {
    if (api != Opcodes.ASM9
        && api != Opcodes.ASM8
        && api != Opcodes.ASM7
        && api != Opcodes.ASM6
        && api != Opcodes.ASM5
        && api != Opcodes.ASM4
        && api != Opcodes.ASM10_EXPERIMENTAL) {
      throw new IllegalArgumentException("Unsupported api " + api);
    }
    if (api == Opcodes.ASM10_EXPERIMENTAL) {
      Constants.checkAsmExperimental(this);
    }
    this.api = api;
    this.mv = methodVisitor;
  }

  /**
   * The method visitor to which this visitor must delegate method calls. May be {@literal null}.
   *
   * @return the method visitor to which this visitor must delegate method calls, or {@literal
   *     null}.
   */
  public MethodVisitor getDelegate() {
    return mv;
  }

  // -----------------------------------------------------------------------------------------------
  // Parameters, annotations and non standard attributes
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a parameter of this method.
   *
   * @param name parameter name or {@literal null} if none is provided.
   * @param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}
   *     or/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).
   */
  public void visitParameter(final String name, final int access) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      mv.visitParameter(name, access);
    }
  }

  /**
   * Visits the default value of this annotation interface method.
   *
   * @return a visitor to the visit the actual default value of this annotation interface method, or
   *     {@literal null} if this visitor is not interested in visiting this default value. The
   *     'name' parameters passed to the methods of this annotation visitor are ignored. Moreover,
   *     exactly one visit method must be called on this annotation visitor, followed by visitEnd.
   */
  public AnnotationVisitor visitAnnotationDefault() {
    if (mv != null) {
      return mv.visitAnnotationDefault();
    }
    return null;
  }

  /**
   * Visits an annotation of this method.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (mv != null) {
      return mv.visitAnnotation(descriptor, visible);
    }
    return null;
  }

  /**
   * Visits an annotation on a type in the method signature.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link
   *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link
   *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link
   *     TypeReference#THROWS}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits the number of method parameters that can have annotations. By default (i.e. when this
   * method is not called), all the method parameters defined by the method descriptor can have
   * annotations.
   *
   * @param parameterCount the number of method parameters than can have annotations. This number
   *     must be less or equal than the number of parameter types in the method descriptor. It can
   *     be strictly less when a method has synthetic parameters and when these parameters are
   *     ignored when computing parameter indices for the purpose of parameter annotations (see
   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
   * @param visible {@literal true} to define the number of method parameters that can have
   *     annotations visible at runtime, {@literal false} to define the number of method parameters
   *     that can have annotations invisible at runtime.
   */
  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    if (mv != null) {
      mv.visitAnnotableParameterCount(parameterCount, visible);
    }
  }

  /**
   * Visits an annotation of a parameter this method.
   *
   * @param parameter the parameter index. This index must be strictly smaller than the number of
   *     parameters in the method descriptor, and strictly smaller than the parameter count
   *     specified in {@link #visitAnnotableParameterCount}. Important note: <i>a parameter index i
   *     is not required to correspond to the i'th parameter descriptor in the method
   *     descriptor</i>, in particular in case of synthetic parameters (see
   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitParameterAnnotation(
      final int parameter, final String descriptor, final boolean visible) {
    if (mv != null) {
      return mv.visitParameterAnnotation(parameter, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a non standard attribute of this method.
   *
   * @param attribute an attribute.
   */
  public void visitAttribute(final Attribute attribute) {
    if (mv != null) {
      mv.visitAttribute(attribute);
    }
  }

  /** Starts the visit of the method's code, if any (i.e. non abstract method). */
  public void visitCode() {
    if (mv != null) {
      mv.visitCode();
    }
  }

  /**
   * Visits the current state of the local variables and operand stack elements. This method must(*)
   * be called <i>just before</i> any instruction <b>i</b> that follows an unconditional branch
   * instruction such as GOTO or THROW, that is the target of a jump instruction, or that starts an
   * exception handler block. The visited types must describe the values of the local variables and
   * of the operand stack elements <i>just before</i> <b>i</b> is executed.<br>
   * <br>
   * (*) this is mandatory only for classes whose version is greater than or equal to {@link
   * Opcodes#V1_6}. <br>
   * <br>
   * The frames of a method must be given either in expanded form, or in compressed form (all frames
   * must use the same format, i.e. you must not mix expanded and compressed frames within a single
   * method):
   *
   * <ul>
   *   <li>In expanded form, all frames must have the F_NEW type.
   *   <li>In compressed form, frames are basically "deltas" from the state of the previous frame:
   *       <ul>
   *         <li>{@link Opcodes#F_SAME} representing frame with exactly the same locals as the
   *             previous frame and with the empty stack.
   *         <li>{@link Opcodes#F_SAME1} representing frame with exactly the same locals as the
   *             previous frame and with single value on the stack ( <code>numStack</code> is 1 and
   *             <code>stack[0]</code> contains value for the type of the stack item).
   *         <li>{@link Opcodes#F_APPEND} representing frame with current locals are the same as the
   *             locals in the previous frame, except that additional locals are defined (<code>
   *             numLocal</code> is 1, 2 or 3 and <code>local</code> elements contains values
   *             representing added types).
   *         <li>{@link Opcodes#F_CHOP} representing frame with current locals are the same as the
   *             locals in the previous frame, except that the last 1-3 locals are absent and with
   *             the empty stack (<code>numLocal</code> is 1, 2 or 3).
   *         <li>{@link Opcodes#F_FULL} representing complete frame data.
   *       </ul>
   * </ul>
   *
   * <br>
   * In both cases the first frame, corresponding to the method's parameters and access flags, is
   * implicit and must not be visited. Also, it is illegal to visit two or more frames for the same
   * code location (i.e., at least one instruction must be visited between two calls to visitFrame).
   *
   * @param type the type of this stack map frame. Must be {@link Opcodes#F_NEW} for expanded
   *     frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link
   *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.
   * @param numLocal the number of local variables in the visited frame. Long and double values
   *     count for one variable.
   * @param local the local variable types in this frame. This array must not be modified. Primitive
   *     types are represented by {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link
   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL} or
   *     {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a single element).
   *     Reference types are represented by String objects (representing internal names, see {@link
   *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates
   *     the NEW instruction that created this uninitialized value).
   * @param numStack the number of operand stack elements in the visited frame. Long and double
   *     values count for one stack element.
   * @param stack the operand stack types in this frame. This array must not be modified. Its
   *     content has the same format as the "local" array.
   * @throws IllegalStateException if a frame is visited just after another one, without any
   *     instruction between the two (unless this frame is a Opcodes#F_SAME frame, in which case it
   *     is silently ignored).
   */
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    if (mv != null) {
      mv.visitFrame(type, numLocal, local, numStack, stack);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Normal instructions
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a zero operand instruction.
   *
   * @param opcode the opcode of the instruction to be visited. This opcode is either NOP,
   *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,
   *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,
   *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,
   *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,
   *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,
   *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,
   *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,
   *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,
   *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.
   */
  public void visitInsn(final int opcode) {
    if (mv != null) {
      mv.visitInsn(opcode);
    }
  }

  /**
   * Visits an instruction with a single int operand.
   *
   * @param opcode the opcode of the instruction to be visited. This opcode is either BIPUSH, SIPUSH
   *     or NEWARRAY.
   * @param operand the operand of the instruction to be visited.<br>
   *     When opcode is BIPUSH, operand value should be between Byte.MIN_VALUE and Byte.MAX_VALUE.
   *     <br>
   *     When opcode is SIPUSH, operand value should be between Short.MIN_VALUE and Short.MAX_VALUE.
   *     <br>
   *     When opcode is NEWARRAY, operand value should be one of {@link Opcodes#T_BOOLEAN}, {@link
   *     Opcodes#T_CHAR}, {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE}, {@link Opcodes#T_BYTE},
   *     {@link Opcodes#T_SHORT}, {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
   */
  public void visitIntInsn(final int opcode, final int operand) {
    if (mv != null) {
      mv.visitIntInsn(opcode, operand);
    }
  }

  /**
   * Visits a local variable instruction. A local variable instruction is an instruction that loads
   * or stores the value of a local variable.
   *
   * @param opcode the opcode of the local variable instruction to be visited. This opcode is either
   *     ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
   * @param varIndex the operand of the instruction to be visited. This operand is the index of a
   *     local variable.
   */
  public void visitVarInsn(final int opcode, final int varIndex) {
    if (mv != null) {
      mv.visitVarInsn(opcode, varIndex);
    }
  }

  /**
   * Visits a type instruction. A type instruction is an instruction that takes the internal name of
   * a class as parameter (see {@link Type#getInternalName()}).
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW,
   *     ANEWARRAY, CHECKCAST or INSTANCEOF.
   * @param type the operand of the instruction to be visited. This operand must be the internal
   *     name of an object or array class (see {@link Type#getInternalName()}).
   */
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    if (mv != null) {
      mv.visitTypeInsn(opcode, type);
    }
  }

  /**
   * Visits a field instruction. A field instruction is an instruction that loads or stores the
   * value of a field of an object.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
   * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link Type}).
   */
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    if (mv != null) {
      mv.visitFieldInsn(opcode, owner, name, descriptor);
    }
  }

  /**
   * Visits a method instruction. A method instruction is an instruction that invokes a method.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.
   */
  @Deprecated
  public void visitMethodInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    int opcodeAndSource = opcode | (api < Opcodes.ASM5 ? Opcodes.SOURCE_DEPRECATED : 0);
    visitMethodInsn(opcodeAndSource, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);
  }

  /**
   * Visits a method instruction. A method instruction is an instruction that invokes a method.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param isInterface if the method's owner class is an interface.
   */
  public void visitMethodInsn(
      final int opcode,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcode & Opcodes.SOURCE_DEPRECATED) == 0) {
      if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {
        throw new UnsupportedOperationException("INVOKESPECIAL/STATIC on interfaces requires ASM5");
      }
      visitMethodInsn(opcode, owner, name, descriptor);
      return;
    }
    if (mv != null) {
      mv.visitMethodInsn(opcode & ~Opcodes.SOURCE_MASK, owner, name, descriptor, isInterface);
    }
  }

  /**
   * Visits an invokedynamic instruction.
   *
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param bootstrapMethodHandle the bootstrap method.
   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be
   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link
   *     Type}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify
   *     the content of the array so a caller should expect that this array may change.
   */
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
    }
  }

  /**
   * Visits a jump instruction. A jump instruction is an instruction that may jump to another
   * instruction.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,
   *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,
   *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
   * @param label the operand of the instruction to be visited. This operand is a label that
   *     designates the instruction to which the jump instruction may jump.
   */
  public void visitJumpInsn(final int opcode, final Label label) {
    if (mv != null) {
      mv.visitJumpInsn(opcode, label);
    }
  }

  /**
   * Visits a label. A label designates the instruction that will be visited just after it.
   *
   * @param label a {@link Label} object.
   */
  public void visitLabel(final Label label) {
    if (mv != null) {
      mv.visitLabel(label);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Special instructions
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a LDC instruction. Note that new constant types may be added in future versions of the
   * Java Virtual Machine. To easily detect new constant types, implementations of this method
   * should check for unexpected constant types, like this:
   *
   * <pre>
   * if (cst instanceof Integer) {
   *     // ...
   * } else if (cst instanceof Float) {
   *     // ...
   * } else if (cst instanceof Long) {
   *     // ...
   * } else if (cst instanceof Double) {
   *     // ...
   * } else if (cst instanceof String) {
   *     // ...
   * } else if (cst instanceof Type) {
   *     int sort = ((Type) cst).getSort();
   *     if (sort == Type.OBJECT) {
   *         // ...
   *     } else if (sort == Type.ARRAY) {
   *         // ...
   *     } else if (sort == Type.METHOD) {
   *         // ...
   *     } else {
   *         // throw an exception
   *     }
   * } else if (cst instanceof Handle) {
   *     // ...
   * } else if (cst instanceof ConstantDynamic) {
   *     // ...
   * } else {
   *     // throw an exception
   * }
   * </pre>
   *
   * @param value the constant to be loaded on the stack. This parameter must be a non null {@link
   *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link
   *     Type} of OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is
   *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle
   *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant
   *     dynamic for classes whose version is 55.
   */
  public void visitLdcInsn(final Object value) {
    if (api < Opcodes.ASM5
        && (value instanceof Handle
            || (value instanceof Type && ((Type) value).getSort() == Type.METHOD))) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (api < Opcodes.ASM7 && value instanceof ConstantDynamic) {
      throw new UnsupportedOperationException("This feature requires ASM7");
    }
    if (mv != null) {
      mv.visitLdcInsn(value);
    }
  }

  /**
   * Visits an IINC instruction.
   *
   * @param varIndex index of the local variable to be incremented.
   * @param increment amount to increment the local variable by.
   */
  public void visitIincInsn(final int varIndex, final int increment) {
    if (mv != null) {
      mv.visitIincInsn(varIndex, increment);
    }
  }

  /**
   * Visits a TABLESWITCH instruction.
   *
   * @param min the minimum key value.
   * @param max the maximum key value.
   * @param dflt beginning of the default handler block.
   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the
   *     handler block for the {@code min + i} key.
   */
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    if (mv != null) {
      mv.visitTableSwitchInsn(min, max, dflt, labels);
    }
  }

  /**
   * Visits a LOOKUPSWITCH instruction.
   *
   * @param dflt beginning of the default handler block.
   * @param keys the values of the keys.
   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the
   *     handler block for the {@code keys[i]} key.
   */
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    if (mv != null) {
      mv.visitLookupSwitchInsn(dflt, keys, labels);
    }
  }

  /**
   * Visits a MULTIANEWARRAY instruction.
   *
   * @param descriptor an array type descriptor (see {@link Type}).
   * @param numDimensions the number of dimensions of the array to allocate.
   */
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    if (mv != null) {
      mv.visitMultiANewArrayInsn(descriptor, numDimensions);
    }
  }

  /**
   * Visits an annotation on an instruction. This method must be called just <i>after</i> the
   * annotated instruction. It can be called several times for the same instruction.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link
   *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link
   *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link
   *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link
   *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link
   *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      return mv.visitInsnAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  // -----------------------------------------------------------------------------------------------
  // Exceptions table entries, debug information, max stack and max locals
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a try catch block.
   *
   * @param start the beginning of the exception handler's scope (inclusive).
   * @param end the end of the exception handler's scope (exclusive).
   * @param handler the beginning of the exception handler's code.
   * @param type the internal name of the type of exceptions handled by the handler (see {@link
   *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for "finally"
   *     blocks).
   * @throws IllegalArgumentException if one of the labels has already been visited by this visitor
   *     (by the {@link #visitLabel} method).
   */
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @InternalForm String type) {
    if (mv != null) {
      mv.visitTryCatchBlock(start, end, handler, type);
    }
  }

  /**
   * Visits an annotation on an exception handler type. This method must be called <i>after</i> the
   * {@link #visitTryCatchBlock} for the annotated exception handler. It can be called several times
   * for the same exception handler.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      return mv.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a local variable declaration.
   *
   * @param name the name of a local variable.
   * @param descriptor the type descriptor of this local variable.
   * @param signature the type signature of this local variable. May be {@literal null} if the local
   *     variable type does not use generic types.
   * @param start the first instruction corresponding to the scope of this local variable
   *     (inclusive).
   * @param end the last instruction corresponding to the scope of this local variable (exclusive).
   * @param index the local variable's index.
   * @throws IllegalArgumentException if one of the labels has not already been visited by this
   *     visitor (by the {@link #visitLabel} method).
   */
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    if (mv != null) {
      mv.visitLocalVariable(name, descriptor, signature, start, end, index);
    }
  }

  /**
   * Visits an annotation on a local variable type.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link
   *     TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param start the fist instructions corresponding to the continuous ranges that make the scope
   *     of this local variable (inclusive).
   * @param end the last instructions corresponding to the continuous ranges that make the scope of
   *     this local variable (exclusive). This array must have the same size as the 'start' array.
   * @param index the local variable's index in each range. This array must have the same size as
   *     the 'start' array.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException(REQUIRES_ASM5);
    }
    if (mv != null) {
      return mv.visitLocalVariableAnnotation(
          typeRef, typePath, start, end, index, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a line number declaration.
   *
   * @param line a line number. This number refers to the source file from which the class was
   *     compiled.
   * @param start the first instruction corresponding to this line number.
   * @throws IllegalArgumentException if {@code start} has not already been visited by this visitor
   *     (by the {@link #visitLabel} method).
   */
  public void visitLineNumber(final int line, final Label start) {
    if (mv != null) {
      mv.visitLineNumber(line, start);
    }
  }

  /**
   * Visits the maximum stack size and the maximum number of local variables of the method.
   *
   * @param maxStack maximum stack size of the method.
   * @param maxLocals maximum number of local variables for the method.
   */
  public void visitMaxs(final int maxStack, final int maxLocals) {
    if (mv != null) {
      mv.visitMaxs(maxStack, maxLocals);
    }
  }

  /**
   * Visits the end of the method. This method, which is the last one to be called, is used to
   * inform the visitor that all the annotations and attributes of the method have been visited.
   */
  public void visitEnd() {
    if (mv != null) {
      mv.visitEnd();
    }
  }
}

package org.objectweb.asm;

/**
 * A {@link ModuleVisitor} that generates the corresponding Module, ModulePackages and
 * ModuleMainClass attributes, as defined in the Java Virtual Machine Specification (JVMS).
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25">JVMS
 *     4.7.25</a>
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.26">JVMS
 *     4.7.26</a>
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.27">JVMS
 *     4.7.27</a>
 * @author Remi Forax
 * @author Eric Bruneton
 */
final class ModuleWriter extends ModuleVisitor {

  /** Where the constants used in this AnnotationWriter must be stored. */
  private final SymbolTable symbolTable;

  /** The module_name_index field of the JVMS Module attribute. */
  private final int moduleNameIndex;

  /** The module_flags field of the JVMS Module attribute. */
  private final int moduleFlags;

  /** The module_version_index field of the JVMS Module attribute. */
  private final int moduleVersionIndex;

  /** The requires_count field of the JVMS Module attribute. */
  private int requiresCount;

  /** The binary content of the 'requires' array of the JVMS Module attribute. */
  private final ByteVector requires;

  /** The exports_count field of the JVMS Module attribute. */
  private int exportsCount;

  /** The binary content of the 'exports' array of the JVMS Module attribute. */
  private final ByteVector exports;

  /** The opens_count field of the JVMS Module attribute. */
  private int opensCount;

  /** The binary content of the 'opens' array of the JVMS Module attribute. */
  private final ByteVector opens;

  /** The uses_count field of the JVMS Module attribute. */
  private int usesCount;

  /** The binary content of the 'uses_index' array of the JVMS Module attribute. */
  private final ByteVector usesIndex;

  /** The provides_count field of the JVMS Module attribute. */
  private int providesCount;

  /** The binary content of the 'provides' array of the JVMS Module attribute. */
  private final ByteVector provides;

  /** The provides_count field of the JVMS ModulePackages attribute. */
  private int packageCount;

  /** The binary content of the 'package_index' array of the JVMS ModulePackages attribute. */
  private final ByteVector packageIndex;

  /** The main_class_index field of the JVMS ModuleMainClass attribute, or 0. */
  private int mainClassIndex;

  ModuleWriter(final SymbolTable symbolTable, final int name, final int access, final int version) {
    super(/* latest api = */ Opcodes.ASM9);
    this.symbolTable = symbolTable;
    this.moduleNameIndex = name;
    this.moduleFlags = access;
    this.moduleVersionIndex = version;
    this.requires = new ByteVector();
    this.exports = new ByteVector();
    this.opens = new ByteVector();
    this.usesIndex = new ByteVector();
    this.provides = new ByteVector();
    this.packageIndex = new ByteVector();
  }

  @Override
  public void visitMainClass(final String mainClass) {
    this.mainClassIndex = symbolTable.addConstantClass(mainClass).index;
  }

  @Override
  public void visitPackage(final String packaze) {
    packageIndex.putShort(symbolTable.addConstantPackage(packaze).index);
    packageCount++;
  }

  @Override
  public void visitRequire(final String module, final int access, final String version) {
    requires
        .putShort(symbolTable.addConstantModule(module).index)
        .putShort(access)
        .putShort(version == null ? 0 : symbolTable.addConstantUtf8(version));
    requiresCount++;
  }

  @Override
  public void visitExport(final String packaze, final int access, final String... modules) {
    exports.putShort(symbolTable.addConstantPackage(packaze).index).putShort(access);
    if (modules == null) {
      exports.putShort(0);
    } else {
      exports.putShort(modules.length);
      for (String module : modules) {
        exports.putShort(symbolTable.addConstantModule(module).index);
      }
    }
    exportsCount++;
  }

  @Override
  public void visitOpen(final String packaze, final int access, final String... modules) {
    opens.putShort(symbolTable.addConstantPackage(packaze).index).putShort(access);
    if (modules == null) {
      opens.putShort(0);
    } else {
      opens.putShort(modules.length);
      for (String module : modules) {
        opens.putShort(symbolTable.addConstantModule(module).index);
      }
    }
    opensCount++;
  }

  @Override
  public void visitUse(final String service) {
    usesIndex.putShort(symbolTable.addConstantClass(service).index);
    usesCount++;
  }

  @Override
  public void visitProvide(final String service, final String... providers) {
    provides.putShort(symbolTable.addConstantClass(service).index);
    provides.putShort(providers.length);
    for (String provider : providers) {
      provides.putShort(symbolTable.addConstantClass(provider).index);
    }
    providesCount++;
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  /**
   * Returns the number of Module, ModulePackages and ModuleMainClass attributes generated by this
   * ModuleWriter.
   *
   * @return the number of Module, ModulePackages and ModuleMainClass attributes (between 1 and 3).
   */
  int getAttributeCount() {
    return 1 + (packageCount > 0 ? 1 : 0) + (mainClassIndex > 0 ? 1 : 0);
  }

  /**
   * Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by this
   * ModuleWriter. Also add the names of these attributes in the constant pool.
   *
   * @return the size in bytes of the Module, ModulePackages and ModuleMainClass attributes.
   */
  int computeAttributesSize() {
    symbolTable.addConstantUtf8(Constants.MODULE);
    // 6 attribute header bytes, 6 bytes for name, flags and version, and 5 * 2 bytes for counts.
    int size =
        22 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;
    if (packageCount > 0) {
      symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES);
      // 6 attribute header bytes, and 2 bytes for package_count.
      size += 8 + packageIndex.length;
    }
    if (mainClassIndex > 0) {
      symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS);
      // 6 attribute header bytes, and 2 bytes for main_class_index.
      size += 8;
    }
    return size;
  }

  /**
   * Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter
   * in the given ByteVector.
   *
   * @param output where the attributes must be put.
   */
  void putAttributes(final ByteVector output) {
    // 6 bytes for name, flags and version, and 5 * 2 bytes for counts.
    int moduleAttributeLength =
        16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;
    output
        .putShort(symbolTable.addConstantUtf8(Constants.MODULE))
        .putInt(moduleAttributeLength)
        .putShort(moduleNameIndex)
        .putShort(moduleFlags)
        .putShort(moduleVersionIndex)
        .putShort(requiresCount)
        .putByteArray(requires.data, 0, requires.length)
        .putShort(exportsCount)
        .putByteArray(exports.data, 0, exports.length)
        .putShort(opensCount)
        .putByteArray(opens.data, 0, opens.length)
        .putShort(usesCount)
        .putByteArray(usesIndex.data, 0, usesIndex.length)
        .putShort(providesCount)
        .putByteArray(provides.data, 0, provides.length);
    if (packageCount > 0) {
      output
          .putShort(symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES))
          .putInt(2 + packageIndex.length)
          .putShort(packageCount)
          .putByteArray(packageIndex.data, 0, packageIndex.length);
    }
    if (mainClassIndex > 0) {
      output
          .putShort(symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS))
          .putInt(2)
          .putShort(mainClassIndex);
    }
  }
}

package org.objectweb.asm;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java
 * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the
 * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode
 * instruction encountered.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html">JVMS 4</a>
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
public class ClassReader {

  /**
   * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed
   * nor visited.
   */
  public static final int SKIP_CODE = 1;

  /**
   * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,
   * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set
   * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link
   * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link
   * MethodVisitor#visitParameter} are not called).
   */
  public static final int SKIP_DEBUG = 2;

  /**
   * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
   * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag
   * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames
   * that will be ignored and recomputed from scratch.
   */
  public static final int SKIP_FRAMES = 4;

  /**
   * A flag to expand the stack map frames. By default stack map frames are visited in their
   * original format (i.e. "expanded" for classes whose version is less than V1_6, and "compressed"
   * for the other classes). If this flag is set, stack map frames are always visited in expanded
   * format (this option adds a decompression/compression step in ClassReader and ClassWriter which
   * degrades performance quite a lot).
   */
  public static final int EXPAND_FRAMES = 8;

  /**
   * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode
   * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset
   * reserved for it is not sufficient to store the bytecode offset. In this case the jump
   * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes
   * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing
   * such instructions, in order to replace them with standard instructions. In addition, when this
   * flag is used, goto_w and jsr_w are <i>not</i> converted into goto and jsr, to make sure that
   * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a
   * goto_w in ClassWriter cannot occur.
   */
  static final int EXPAND_ASM_INSNS = 256;

  /** The maximum size of array to allocate. */
  private static final int MAX_BUFFER_SIZE = 1024 * 1024;

  /** The size of the temporary byte array used to read class input streams chunk by chunk. */
  private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;

  /**
   * A byte array containing the JVMS ClassFile structure to be parsed.
   *
   * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will
   *     eventually be deleted.
   */
  @Deprecated
  // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
  public final byte[] b;

  /** The offset in bytes of the ClassFile's access_flags field. */
  public final int header;

  /**
   * A byte array containing the JVMS ClassFile structure to be parsed. <i>The content of this array
   * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
   * not needed by class visitors.</i>
   *
   * <p>NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
   * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
   * ClassFile element offsets within this byte array.
   */
  final byte[] classFileBuffer;

  /**
   * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's
   * constant_pool array, <i>plus one</i>. In other words, the offset of constant pool entry i is
   * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -
   * 1].
   */
  private final int[] cpInfoOffsets;

  /**
   * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
   * multiple parsing of a given CONSTANT_Utf8 constant pool item.
   */
  private final String[] constantUtf8Values;

  /**
   * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This
   * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
   */
  private final ConstantDynamic[] constantDynamicValues;

  /**
   * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array
   * (in the BootstrapMethods attribute).
   *
   * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23">JVMS
   *     4.7.23</a>
   */
  private final int[] bootstrapMethodOffsets;

  /**
   * A conservative estimate of the maximum length of the strings contained in the constant pool of
   * the class.
   */
  private final int maxStringLength;

  // -----------------------------------------------------------------------------------------------
  // Constructors
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link ClassReader} object.
   *
   * @param classFile the JVMS ClassFile structure to be read.
   */
  public ClassReader(final byte[] classFile) {
    this(classFile, 0, classFile.length);
  }

  /**
   * Constructs a new {@link ClassReader} object.
   *
   * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
   * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
   * @param classFileLength the length in bytes of the ClassFile to be read.
   */
  public ClassReader(
      final byte[] classFileBuffer,
      final int classFileOffset,
      final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.
    this(classFileBuffer, classFileOffset, /* checkClassVersion= */ true);
  }

  /**
   * Constructs a new {@link ClassReader} object. <i>This internal constructor must not be exposed
   * as a public API</i>.
   *
   * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
   * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
   * @param checkClassVersion whether to check the class version or not.
   */
  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod")
  ClassReader(
      final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
    this.classFileBuffer = classFileBuffer;
    this.b = classFileBuffer;
    // Check the class' major_version. This field is after the magic and minor_version fields, which
    // use 4 and 2 bytes respectively.
    if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V24) {
      throw new IllegalArgumentException(
          "Unsupported class file major version " + readShort(classFileOffset + 6));
    }
    // Create the constant pool arrays. The constant_pool_count field is after the magic,
    // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.
    int constantPoolCount = readUnsignedShort(classFileOffset + 8);
    cpInfoOffsets = new int[constantPoolCount];
    constantUtf8Values = new String[constantPoolCount];
    // Compute the offset of each constant pool entry, as well as a conservative estimate of the
    // maximum length of the constant pool strings. The first constant pool entry is after the
    // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
    // bytes respectively.
    int currentCpInfoIndex = 1;
    int currentCpInfoOffset = classFileOffset + 10;
    int currentMaxStringLength = 0;
    boolean hasBootstrapMethods = false;
    boolean hasConstantDynamic = false;
    // The offset of the other entries depend on the total size of all the previous entries.
    while (currentCpInfoIndex < constantPoolCount) {
      cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
      int cpInfoSize;
      switch (classFileBuffer[currentCpInfoOffset]) {
        case Symbol.CONSTANT_FIELDREF_TAG:
        case Symbol.CONSTANT_METHODREF_TAG:
        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
        case Symbol.CONSTANT_INTEGER_TAG:
        case Symbol.CONSTANT_FLOAT_TAG:
        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
          cpInfoSize = 5;
          break;
        case Symbol.CONSTANT_DYNAMIC_TAG:
          cpInfoSize = 5;
          hasBootstrapMethods = true;
          hasConstantDynamic = true;
          break;
        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
          cpInfoSize = 5;
          hasBootstrapMethods = true;
          break;
        case Symbol.CONSTANT_LONG_TAG:
        case Symbol.CONSTANT_DOUBLE_TAG:
          cpInfoSize = 9;
          currentCpInfoIndex++;
          break;
        case Symbol.CONSTANT_UTF8_TAG:
          cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);
          if (cpInfoSize > currentMaxStringLength) {
            // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate
            // of the length in characters of the corresponding string, and is much cheaper to
            // compute than this exact length.
            currentMaxStringLength = cpInfoSize;
          }
          break;
        case Symbol.CONSTANT_METHOD_HANDLE_TAG:
          cpInfoSize = 4;
          break;
        case Symbol.CONSTANT_CLASS_TAG:
        case Symbol.CONSTANT_STRING_TAG:
        case Symbol.CONSTANT_METHOD_TYPE_TAG:
        case Symbol.CONSTANT_PACKAGE_TAG:
        case Symbol.CONSTANT_MODULE_TAG:
          cpInfoSize = 3;
          break;
        default:
          throw new IllegalArgumentException();
      }
      currentCpInfoOffset += cpInfoSize;
    }
    maxStringLength = currentMaxStringLength;
    // The Classfile's access_flags field is just after the last constant pool entry.
    header = currentCpInfoOffset;

    // Allocate the cache of ConstantDynamic values, if there is at least one.
    constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;

    // Read the BootstrapMethods attribute, if any (only get the offset of each method).
    bootstrapMethodOffsets =
        hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;
  }

  /**
   * Constructs a new {@link ClassReader} object.
   *
   * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input
   *     stream must contain nothing more than the ClassFile structure itself. It is read from its
   *     current position to its end.
   * @throws IOException if a problem occurs during reading.
   */
  public ClassReader(final InputStream inputStream) throws IOException {
    this(readStream(inputStream, false));
  }

  /**
   * Constructs a new {@link ClassReader} object.
   *
   * @param className the fully qualified name of the class to be read. The ClassFile structure is
   *     retrieved with the current class loader's {@link ClassLoader#getSystemResourceAsStream}.
   * @throws IOException if an exception occurs during reading.
   */
  public ClassReader(final @FullyQualifiedName String className) throws IOException {
    this(
        readStream(
            ClassLoader.getSystemResourceAsStream(className.replace('.', '/') + ".class"), true));
  }

  /**
   * Reads the given input stream and returns its content as a byte array.
   *
   * @param inputStream an input stream.
   * @param close true to close the input stream after reading.
   * @return the content of the given input stream.
   * @throws IOException if a problem occurs during reading.
   */
  @SuppressWarnings("PMD.UseTryWithResources")
  private static byte[] readStream(final InputStream inputStream, final boolean close)
      throws IOException {
    if (inputStream == null) {
      throw new IOException("Class not found");
    }
    int bufferSize = computeBufferSize(inputStream);
    try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
      byte[] data = new byte[bufferSize];
      int bytesRead;
      int readCount = 0;
      while ((bytesRead = inputStream.read(data, 0, bufferSize)) != -1) {
        outputStream.write(data, 0, bytesRead);
        readCount++;
      }
      outputStream.flush();
      if (readCount == 1) {
        return data;
      }
      return outputStream.toByteArray();
    } finally {
      if (close) {
        inputStream.close();
      }
    }
  }

  private static int computeBufferSize(final InputStream inputStream) throws IOException {
    int expectedLength = inputStream.available();
    /*
     * Some implementations can return 0 while holding available data (e.g. new
     * FileInputStream("/proc/a_file")). Also in some pathological cases a very small number might
     * be returned, and in this case we use a default size.
     */
    if (expectedLength < 256) {
      return INPUT_STREAM_DATA_CHUNK_SIZE;
    }
    return Math.min(expectedLength, MAX_BUFFER_SIZE);
  }

  // -----------------------------------------------------------------------------------------------
  // Accessors
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated
   * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.
   *
   * @return the class access flags.
   * @see ClassVisitor#visit(int, int, String, String, String, String[])
   */
  public int getAccess() {
    return readUnsignedShort(header);
  }

  /**
   * Returns the internal name of the class (see {@link Type#getInternalName()}).
   *
   * @return the internal class name.
   * @see ClassVisitor#visit(int, int, String, String, String, String[])
   */
  public @InternalForm String getClassName() {
    // this_class is just after the access_flags field (using 2 bytes).
    return readClass(header + 2, new char[maxStringLength]);
  }

  /**
   * Returns the internal name of the super class (see {@link Type#getInternalName()}). For
   * interfaces, the super class is {@link Object}.
   *
   * @return the internal name of the super class, or {@literal null} for {@link Object} class.
   * @see ClassVisitor#visit(int, int, String, String, String, String[])
   */
  public @InternalForm String getSuperName() {
    // super_class is after the access_flags and this_class fields (2 bytes each).
    return readClass(header + 4, new char[maxStringLength]);
  }

  /**
   * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).
   *
   * @return the internal names of the directly implemented interfaces. Inherited implemented
   *     interfaces are not returned.
   * @see ClassVisitor#visit(int, int, String, String, String, String[])
   */
  public @InternalForm String[] getInterfaces() {
    // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).
    int currentOffset = header + 6;
    int interfacesCount = readUnsignedShort(currentOffset);
    String[] interfaces = new String[interfacesCount];
    if (interfacesCount > 0) {
      char[] charBuffer = new char[maxStringLength];
      for (int i = 0; i < interfacesCount; ++i) {
        currentOffset += 2;
        interfaces[i] = readClass(currentOffset, charBuffer);
      }
    }
    return interfaces;
  }

  // -----------------------------------------------------------------------------------------------
  // Public methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
   * {@link ClassReader}.
   *
   * @param classVisitor the visitor that must visit this class.
   * @param parsingOptions the options to use to parse this class. One or more of {@link
   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
   */
  public void accept(final ClassVisitor classVisitor, final int parsingOptions) {
    accept(classVisitor, new Attribute[0], parsingOptions);
  }

  /**
   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
   * {@link ClassReader}.
   *
   * @param classVisitor the visitor that must visit this class.
   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
   *     be parsed: its byte array value will be passed unchanged to the ClassWriter. <i>This may
   *     corrupt it if this value contains references to the constant pool, or has syntactic or
   *     semantic links with a class element that has been transformed by a class adapter between
   *     the reader and the writer</i>.
   * @param parsingOptions the options to use to parse this class. One or more of {@link
   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
   */
  public void accept(
      final ClassVisitor classVisitor,
      final Attribute[] attributePrototypes,
      final int parsingOptions) {
    Context context = new Context();
    context.attributePrototypes = attributePrototypes;
    context.parsingOptions = parsingOptions;
    context.charBuffer = new char[maxStringLength];

    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.
    char[] charBuffer = context.charBuffer;
    int currentOffset = header;
    int accessFlags = readUnsignedShort(currentOffset);
    String thisClass = readClass(currentOffset + 2, charBuffer);
    String superClass = readClass(currentOffset + 4, charBuffer);
    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];
    currentOffset += 8;
    for (int i = 0; i < interfaces.length; ++i) {
      interfaces[i] = readClass(currentOffset, charBuffer);
      currentOffset += 2;
    }

    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).
    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
    // - The offset of the InnerClasses attribute, or 0.
    int innerClassesOffset = 0;
    // - The offset of the EnclosingMethod attribute, or 0.
    int enclosingMethodOffset = 0;
    // - The string corresponding to the Signature attribute, or null.
    String signature = null;
    // - The string corresponding to the SourceFile attribute, or null.
    String sourceFile = null;
    // - The string corresponding to the SourceDebugExtension attribute, or null.
    String sourceDebugExtension = null;
    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
    int runtimeVisibleAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
    int runtimeInvisibleAnnotationsOffset = 0;
    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
    int runtimeVisibleTypeAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
    int runtimeInvisibleTypeAnnotationsOffset = 0;
    // - The offset of the Module attribute, or 0.
    int moduleOffset = 0;
    // - The offset of the ModulePackages attribute, or 0.
    int modulePackagesOffset = 0;
    // - The string corresponding to the ModuleMainClass attribute, or null.
    String moduleMainClass = null;
    // - The string corresponding to the NestHost attribute, or null.
    String nestHostClass = null;
    // - The offset of the NestMembers attribute, or 0.
    int nestMembersOffset = 0;
    // - The offset of the PermittedSubclasses attribute, or 0
    int permittedSubclassesOffset = 0;
    // - The offset of the Record attribute, or 0.
    int recordOffset = 0;
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
    Attribute attributes = null;

    int currentAttributeOffset = getFirstAttributeOffset();
    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {
      // Read the attribute_info's attribute_name and attribute_length fields.
      String attributeName = readUTF8(currentAttributeOffset, charBuffer);
      int attributeLength = readInt(currentAttributeOffset + 2);
      currentAttributeOffset += 6;
      // The tests are sorted in decreasing frequency order (based on frequencies observed on
      // typical classes).
      if (Constants.SOURCE_FILE.equals(attributeName)) {
        sourceFile = readUTF8(currentAttributeOffset, charBuffer);
      } else if (Constants.INNER_CLASSES.equals(attributeName)) {
        innerClassesOffset = currentAttributeOffset;
      } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {
        enclosingMethodOffset = currentAttributeOffset;
      } else if (Constants.NEST_HOST.equals(attributeName)) {
        nestHostClass = readClass(currentAttributeOffset, charBuffer);
      } else if (Constants.NEST_MEMBERS.equals(attributeName)) {
        nestMembersOffset = currentAttributeOffset;
      } else if (Constants.PERMITTED_SUBCLASSES.equals(attributeName)) {
        permittedSubclassesOffset = currentAttributeOffset;
      } else if (Constants.SIGNATURE.equals(attributeName)) {
        signature = readUTF8(currentAttributeOffset, charBuffer);
      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleAnnotationsOffset = currentAttributeOffset;
      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;
      } else if (Constants.DEPRECATED.equals(attributeName)) {
        accessFlags |= Opcodes.ACC_DEPRECATED;
      } else if (Constants.SYNTHETIC.equals(attributeName)) {
        accessFlags |= Opcodes.ACC_SYNTHETIC;
      } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {
        if (attributeLength > classFileBuffer.length - currentAttributeOffset) {
          throw new IllegalArgumentException();
        }
        sourceDebugExtension =
            readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);
      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;
      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;
      } else if (Constants.RECORD.equals(attributeName)) {
        recordOffset = currentAttributeOffset;
        accessFlags |= Opcodes.ACC_RECORD;
      } else if (Constants.MODULE.equals(attributeName)) {
        moduleOffset = currentAttributeOffset;
      } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {
        moduleMainClass = readClass(currentAttributeOffset, charBuffer);
      } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {
        modulePackagesOffset = currentAttributeOffset;
      } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
        // The BootstrapMethods attribute is read in the constructor.
        Attribute attribute =
            readAttribute(
                attributePrototypes,
                attributeName,
                currentAttributeOffset,
                attributeLength,
                charBuffer,
                -1,
                null);
        attribute.nextAttribute = attributes;
        attributes = attribute;
      }
      currentAttributeOffset += attributeLength;
    }

    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before
    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).
    classVisitor.visit(
        readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);

    // Visit the SourceFile and SourceDebugExtenstion attributes.
    if ((parsingOptions & SKIP_DEBUG) == 0
        && (sourceFile != null || sourceDebugExtension != null)) {
      classVisitor.visitSource(sourceFile, sourceDebugExtension);
    }

    // Visit the Module, ModulePackages and ModuleMainClass attributes.
    if (moduleOffset != 0) {
      readModuleAttributes(
          classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);
    }

    // Visit the NestHost attribute.
    if (nestHostClass != null) {
      classVisitor.visitNestHost(nestHostClass);
    }

    // Visit the EnclosingMethod attribute.
    if (enclosingMethodOffset != 0) {
      String className = readClass(enclosingMethodOffset, charBuffer);
      int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);
      String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);
      String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);
      classVisitor.visitOuterClass(className, name, type);
    }

    // Visit the RuntimeVisibleAnnotations attribute.
    if (runtimeVisibleAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                classVisitor.visitAnnotation(annotationDescriptor, /* visible= */ true),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeInvisibleAnnotations attribute.
    if (runtimeInvisibleAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                classVisitor.visitAnnotation(annotationDescriptor, /* visible= */ false),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeVisibleTypeAnnotations attribute.
    if (runtimeVisibleTypeAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the target_type, target_info and target_path fields.
        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                classVisitor.visitTypeAnnotation(
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible= */ true),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeInvisibleTypeAnnotations attribute.
    if (runtimeInvisibleTypeAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the target_type, target_info and target_path fields.
        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                classVisitor.visitTypeAnnotation(
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible= */ false),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the non standard attributes.
    while (attributes != null) {
      // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.
      Attribute nextAttribute = attributes.nextAttribute;
      attributes.nextAttribute = null;
      classVisitor.visitAttribute(attributes);
      attributes = nextAttribute;
    }

    // Visit the NestedMembers attribute.
    if (nestMembersOffset != 0) {
      int numberOfNestMembers = readUnsignedShort(nestMembersOffset);
      int currentNestMemberOffset = nestMembersOffset + 2;
      while (numberOfNestMembers-- > 0) {
        classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));
        currentNestMemberOffset += 2;
      }
    }

    // Visit the PermittedSubclasses attribute.
    if (permittedSubclassesOffset != 0) {
      int numberOfPermittedSubclasses = readUnsignedShort(permittedSubclassesOffset);
      int currentPermittedSubclassesOffset = permittedSubclassesOffset + 2;
      while (numberOfPermittedSubclasses-- > 0) {
        classVisitor.visitPermittedSubclass(
            readClass(currentPermittedSubclassesOffset, charBuffer));
        currentPermittedSubclassesOffset += 2;
      }
    }

    // Visit the InnerClasses attribute.
    if (innerClassesOffset != 0) {
      int numberOfClasses = readUnsignedShort(innerClassesOffset);
      int currentClassesOffset = innerClassesOffset + 2;
      while (numberOfClasses-- > 0) {
        classVisitor.visitInnerClass(
            readClass(currentClassesOffset, charBuffer),
            readClass(currentClassesOffset + 2, charBuffer),
            readUTF8(currentClassesOffset + 4, charBuffer),
            readUnsignedShort(currentClassesOffset + 6));
        currentClassesOffset += 8;
      }
    }

    // Visit Record components.
    if (recordOffset != 0) {
      int recordComponentsCount = readUnsignedShort(recordOffset);
      recordOffset += 2;
      while (recordComponentsCount-- > 0) {
        recordOffset = readRecordComponent(classVisitor, context, recordOffset);
      }
    }

    // Visit the fields and methods.
    int fieldsCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (fieldsCount-- > 0) {
      currentOffset = readField(classVisitor, context, currentOffset);
    }
    int methodsCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (methodsCount-- > 0) {
      currentOffset = readMethod(classVisitor, context, currentOffset);
    }

    // Visit the end of the class.
    classVisitor.visitEnd();
  }

  // ----------------------------------------------------------------------------------------------
  // Methods to parse modules, fields and methods
  // ----------------------------------------------------------------------------------------------

  /**
   * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.
   *
   * @param classVisitor the current class visitor
   * @param context information about the class being parsed.
   * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's
   *     attribute_name_index and attribute_length fields).
   * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
   *     attribute_info's attribute_name_index and attribute_length fields), or 0.
   * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal
   *     null}.
   */
  private void readModuleAttributes(
      final ClassVisitor classVisitor,
      final Context context,
      final int moduleOffset,
      final int modulePackagesOffset,
      final String moduleMainClass) {
    char[] buffer = context.charBuffer;

    // Read the module_name_index, module_flags and module_version_index fields and visit them.
    int currentOffset = moduleOffset;
    String moduleName = readModule(currentOffset, buffer);
    int moduleFlags = readUnsignedShort(currentOffset + 2);
    String moduleVersion = readUTF8(currentOffset + 4, buffer);
    currentOffset += 6;
    ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);
    if (moduleVisitor == null) {
      return;
    }

    // Visit the ModuleMainClass attribute.
    if (moduleMainClass != null) {
      moduleVisitor.visitMainClass(moduleMainClass);
    }

    // Visit the ModulePackages attribute.
    if (modulePackagesOffset != 0) {
      int packageCount = readUnsignedShort(modulePackagesOffset);
      int currentPackageOffset = modulePackagesOffset + 2;
      while (packageCount-- > 0) {
        moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));
        currentPackageOffset += 2;
      }
    }

    // Read the 'requires_count' and 'requires' fields.
    int requiresCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (requiresCount-- > 0) {
      // Read the requires_index, requires_flags and requires_version fields and visit them.
      String requires = readModule(currentOffset, buffer);
      int requiresFlags = readUnsignedShort(currentOffset + 2);
      String requiresVersion = readUTF8(currentOffset + 4, buffer);
      currentOffset += 6;
      moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);
    }

    // Read the 'exports_count' and 'exports' fields.
    int exportsCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (exportsCount-- > 0) {
      // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields
      // and visit them.
      String exports = readPackage(currentOffset, buffer);
      int exportsFlags = readUnsignedShort(currentOffset + 2);
      int exportsToCount = readUnsignedShort(currentOffset + 4);
      currentOffset += 6;
      String[] exportsTo = null;
      if (exportsToCount != 0) {
        exportsTo = new String[exportsToCount];
        for (int i = 0; i < exportsToCount; ++i) {
          exportsTo[i] = readModule(currentOffset, buffer);
          currentOffset += 2;
        }
      }
      moduleVisitor.visitExport(exports, exportsFlags, exportsTo);
    }

    // Reads the 'opens_count' and 'opens' fields.
    int opensCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (opensCount-- > 0) {
      // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.
      String opens = readPackage(currentOffset, buffer);
      int opensFlags = readUnsignedShort(currentOffset + 2);
      int opensToCount = readUnsignedShort(currentOffset + 4);
      currentOffset += 6;
      String[] opensTo = null;
      if (opensToCount != 0) {
        opensTo = new String[opensToCount];
        for (int i = 0; i < opensToCount; ++i) {
          opensTo[i] = readModule(currentOffset, buffer);
          currentOffset += 2;
        }
      }
      moduleVisitor.visitOpen(opens, opensFlags, opensTo);
    }

    // Read the 'uses_count' and 'uses' fields.
    int usesCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (usesCount-- > 0) {
      moduleVisitor.visitUse(readClass(currentOffset, buffer));
      currentOffset += 2;
    }

    // Read the 'provides_count' and 'provides' fields.
    int providesCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (providesCount-- > 0) {
      // Read the provides_index, provides_with_count and provides_with_index fields and visit them.
      String provides = readClass(currentOffset, buffer);
      int providesWithCount = readUnsignedShort(currentOffset + 2);
      currentOffset += 4;
      String[] providesWith = new String[providesWithCount];
      for (int i = 0; i < providesWithCount; ++i) {
        providesWith[i] = readClass(currentOffset, buffer);
        currentOffset += 2;
      }
      moduleVisitor.visitProvide(provides, providesWith);
    }

    // Visit the end of the module attributes.
    moduleVisitor.visitEnd();
  }

  /**
   * Reads a record component and visit it.
   *
   * @param classVisitor the current class visitor
   * @param context information about the class being parsed.
   * @param recordComponentOffset the offset of the current record component.
   * @return the offset of the first byte following the record component.
   */
  private int readRecordComponent(
      final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {
    char[] charBuffer = context.charBuffer;

    int currentOffset = recordComponentOffset;
    String name = readUTF8(currentOffset, charBuffer);
    String descriptor = readUTF8(currentOffset + 2, charBuffer);
    currentOffset += 4;

    // Read the record component attributes (the variables are ordered as in Section 4.7 of the
    // JVMS).

    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
    // - The string corresponding to the Signature attribute, or null.
    String signature = null;
    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
    int runtimeVisibleAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
    int runtimeInvisibleAnnotationsOffset = 0;
    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
    int runtimeVisibleTypeAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
    int runtimeInvisibleTypeAnnotationsOffset = 0;
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
    Attribute attributes = null;

    int attributesCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (attributesCount-- > 0) {
      // Read the attribute_info's attribute_name and attribute_length fields.
      String attributeName = readUTF8(currentOffset, charBuffer);
      int attributeLength = readInt(currentOffset + 2);
      currentOffset += 6;
      // The tests are sorted in decreasing frequency order (based on frequencies observed on
      // typical classes).
      if (Constants.SIGNATURE.equals(attributeName)) {
        signature = readUTF8(currentOffset, charBuffer);
      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleTypeAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleTypeAnnotationsOffset = currentOffset;
      } else {
        Attribute attribute =
            readAttribute(
                context.attributePrototypes,
                attributeName,
                currentOffset,
                attributeLength,
                charBuffer,
                -1,
                null);
        attribute.nextAttribute = attributes;
        attributes = attribute;
      }
      currentOffset += attributeLength;
    }

    RecordComponentVisitor recordComponentVisitor =
        classVisitor.visitRecordComponent(name, descriptor, signature);
    if (recordComponentVisitor == null) {
      return currentOffset;
    }

    // Visit the RuntimeVisibleAnnotations attribute.
    if (runtimeVisibleAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible= */ true),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeInvisibleAnnotations attribute.
    if (runtimeInvisibleAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible= */ false),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeVisibleTypeAnnotations attribute.
    if (runtimeVisibleTypeAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the target_type, target_info and target_path fields.
        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                recordComponentVisitor.visitTypeAnnotation(
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible= */ true),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeInvisibleTypeAnnotations attribute.
    if (runtimeInvisibleTypeAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the target_type, target_info and target_path fields.
        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                recordComponentVisitor.visitTypeAnnotation(
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible= */ false),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the non standard attributes.
    while (attributes != null) {
      // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.
      Attribute nextAttribute = attributes.nextAttribute;
      attributes.nextAttribute = null;
      recordComponentVisitor.visitAttribute(attributes);
      attributes = nextAttribute;
    }

    // Visit the end of the field.
    recordComponentVisitor.visitEnd();
    return currentOffset;
  }

  /**
   * Reads a JVMS field_info structure and makes the given visitor visit it.
   *
   * @param classVisitor the visitor that must visit the field.
   * @param context information about the class being parsed.
   * @param fieldInfoOffset the start offset of the field_info structure.
   * @return the offset of the first byte following the field_info structure.
   */
  private int readField(
      final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {
    char[] charBuffer = context.charBuffer;

    // Read the access_flags, name_index and descriptor_index fields.
    int currentOffset = fieldInfoOffset;
    int accessFlags = readUnsignedShort(currentOffset);
    String name = readUTF8(currentOffset + 2, charBuffer);
    String descriptor = readUTF8(currentOffset + 4, charBuffer);
    currentOffset += 6;

    // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).
    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
    // - The value corresponding to the ConstantValue attribute, or null.
    Object constantValue = null;
    // - The string corresponding to the Signature attribute, or null.
    String signature = null;
    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
    int runtimeVisibleAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
    int runtimeInvisibleAnnotationsOffset = 0;
    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
    int runtimeVisibleTypeAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
    int runtimeInvisibleTypeAnnotationsOffset = 0;
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
    Attribute attributes = null;

    int attributesCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (attributesCount-- > 0) {
      // Read the attribute_info's attribute_name and attribute_length fields.
      String attributeName = readUTF8(currentOffset, charBuffer);
      int attributeLength = readInt(currentOffset + 2);
      currentOffset += 6;
      // The tests are sorted in decreasing frequency order (based on frequencies observed on
      // typical classes).
      if (Constants.CONSTANT_VALUE.equals(attributeName)) {
        int constantvalueIndex = readUnsignedShort(currentOffset);
        constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);
      } else if (Constants.SIGNATURE.equals(attributeName)) {
        signature = readUTF8(currentOffset, charBuffer);
      } else if (Constants.DEPRECATED.equals(attributeName)) {
        accessFlags |= Opcodes.ACC_DEPRECATED;
      } else if (Constants.SYNTHETIC.equals(attributeName)) {
        accessFlags |= Opcodes.ACC_SYNTHETIC;
      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleTypeAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleTypeAnnotationsOffset = currentOffset;
      } else {
        Attribute attribute =
            readAttribute(
                context.attributePrototypes,
                attributeName,
                currentOffset,
                attributeLength,
                charBuffer,
                -1,
                null);
        attribute.nextAttribute = attributes;
        attributes = attribute;
      }
      currentOffset += attributeLength;
    }

    // Visit the field declaration.
    FieldVisitor fieldVisitor =
        classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);
    if (fieldVisitor == null) {
      return currentOffset;
    }

    // Visit the RuntimeVisibleAnnotations attribute.
    if (runtimeVisibleAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible= */ true),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeInvisibleAnnotations attribute.
    if (runtimeInvisibleAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible= */ false),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeVisibleTypeAnnotations attribute.
    if (runtimeVisibleTypeAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the target_type, target_info and target_path fields.
        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                fieldVisitor.visitTypeAnnotation(
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible= */ true),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeInvisibleTypeAnnotations attribute.
    if (runtimeInvisibleTypeAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the target_type, target_info and target_path fields.
        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                fieldVisitor.visitTypeAnnotation(
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible= */ false),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the non standard attributes.
    while (attributes != null) {
      // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.
      Attribute nextAttribute = attributes.nextAttribute;
      attributes.nextAttribute = null;
      fieldVisitor.visitAttribute(attributes);
      attributes = nextAttribute;
    }

    // Visit the end of the field.
    fieldVisitor.visitEnd();
    return currentOffset;
  }

  /**
   * Reads a JVMS method_info structure and makes the given visitor visit it.
   *
   * @param classVisitor the visitor that must visit the method.
   * @param context information about the class being parsed.
   * @param methodInfoOffset the start offset of the method_info structure.
   * @return the offset of the first byte following the method_info structure.
   */
  private int readMethod(
      final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {
    char[] charBuffer = context.charBuffer;

    // Read the access_flags, name_index and descriptor_index fields.
    int currentOffset = methodInfoOffset;
    context.currentMethodAccessFlags = readUnsignedShort(currentOffset);
    context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);
    context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);
    currentOffset += 6;

    // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).
    // Attribute offsets exclude the attribute_name_index and attribute_length fields.
    // - The offset of the Code attribute, or 0.
    int codeOffset = 0;
    // - The offset of the Exceptions attribute, or 0.
    int exceptionsOffset = 0;
    // - The strings corresponding to the Exceptions attribute, or null.
    String[] exceptions = null;
    // - Whether the method has a Synthetic attribute.
    boolean synthetic = false;
    // - The constant pool index contained in the Signature attribute, or 0.
    int signatureIndex = 0;
    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
    int runtimeVisibleAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
    int runtimeInvisibleAnnotationsOffset = 0;
    // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.
    int runtimeVisibleParameterAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.
    int runtimeInvisibleParameterAnnotationsOffset = 0;
    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
    int runtimeVisibleTypeAnnotationsOffset = 0;
    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
    int runtimeInvisibleTypeAnnotationsOffset = 0;
    // - The offset of the AnnotationDefault attribute, or 0.
    int annotationDefaultOffset = 0;
    // - The offset of the MethodParameters attribute, or 0.
    int methodParametersOffset = 0;
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
    Attribute attributes = null;

    int attributesCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (attributesCount-- > 0) {
      // Read the attribute_info's attribute_name and attribute_length fields.
      String attributeName = readUTF8(currentOffset, charBuffer);
      int attributeLength = readInt(currentOffset + 2);
      currentOffset += 6;
      // The tests are sorted in decreasing frequency order (based on frequencies observed on
      // typical classes).
      if (Constants.CODE.equals(attributeName)) {
        if ((context.parsingOptions & SKIP_CODE) == 0) {
          codeOffset = currentOffset;
        }
      } else if (Constants.EXCEPTIONS.equals(attributeName)) {
        exceptionsOffset = currentOffset;
        exceptions = new String[readUnsignedShort(exceptionsOffset)];
        int currentExceptionOffset = exceptionsOffset + 2;
        for (int i = 0; i < exceptions.length; ++i) {
          exceptions[i] = readClass(currentExceptionOffset, charBuffer);
          currentExceptionOffset += 2;
        }
      } else if (Constants.SIGNATURE.equals(attributeName)) {
        signatureIndex = readUnsignedShort(currentOffset);
      } else if (Constants.DEPRECATED.equals(attributeName)) {
        context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;
      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleTypeAnnotationsOffset = currentOffset;
      } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {
        annotationDefaultOffset = currentOffset;
      } else if (Constants.SYNTHETIC.equals(attributeName)) {
        synthetic = true;
        context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;
      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleTypeAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {
        runtimeVisibleParameterAnnotationsOffset = currentOffset;
      } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {
        runtimeInvisibleParameterAnnotationsOffset = currentOffset;
      } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {
        methodParametersOffset = currentOffset;
      } else {
        Attribute attribute =
            readAttribute(
                context.attributePrototypes,
                attributeName,
                currentOffset,
                attributeLength,
                charBuffer,
                -1,
                null);
        attribute.nextAttribute = attributes;
        attributes = attribute;
      }
      currentOffset += attributeLength;
    }

    // Visit the method declaration.
    MethodVisitor methodVisitor =
        classVisitor.visitMethod(
            context.currentMethodAccessFlags,
            context.currentMethodName,
            context.currentMethodDescriptor,
            signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer),
            exceptions);
    if (methodVisitor == null) {
      return currentOffset;
    }

    // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method
    // adapter between the reader and the writer. In this case, it might be possible to copy
    // the method attributes directly into the writer. If so, return early without visiting
    // the content of these attributes.
    if (methodVisitor instanceof MethodWriter) {
      MethodWriter methodWriter = (MethodWriter) methodVisitor;
      if (methodWriter.canCopyMethodAttributes(
          this,
          synthetic,
          (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0,
          readUnsignedShort(methodInfoOffset + 4),
          signatureIndex,
          exceptionsOffset)) {
        methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);
        return currentOffset;
      }
    }

    // Visit the MethodParameters attribute.
    if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {
      int parametersCount = readByte(methodParametersOffset);
      int currentParameterOffset = methodParametersOffset + 1;
      while (parametersCount-- > 0) {
        // Read the name_index and access_flags fields and visit them.
        methodVisitor.visitParameter(
            readUTF8(currentParameterOffset, charBuffer),
            readUnsignedShort(currentParameterOffset + 2));
        currentParameterOffset += 4;
      }
    }

    // Visit the AnnotationDefault attribute.
    if (annotationDefaultOffset != 0) {
      AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();
      readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);
      if (annotationVisitor != null) {
        annotationVisitor.visitEnd();
      }
    }

    // Visit the RuntimeVisibleAnnotations attribute.
    if (runtimeVisibleAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */ true),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeInvisibleAnnotations attribute.
    if (runtimeInvisibleAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */ false),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeVisibleTypeAnnotations attribute.
    if (runtimeVisibleTypeAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the target_type, target_info and target_path fields.
        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                methodVisitor.visitTypeAnnotation(
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible= */ true),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeInvisibleTypeAnnotations attribute.
    if (runtimeInvisibleTypeAnnotationsOffset != 0) {
      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
      while (numAnnotations-- > 0) {
        // Parse the target_type, target_info and target_path fields.
        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
        currentAnnotationOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentAnnotationOffset =
            readElementValues(
                methodVisitor.visitTypeAnnotation(
                    context.currentTypeAnnotationTarget,
                    context.currentTypeAnnotationTargetPath,
                    annotationDescriptor,
                    /* visible= */ false),
                currentAnnotationOffset,
                /* named= */ true,
                charBuffer);
      }
    }

    // Visit the RuntimeVisibleParameterAnnotations attribute.
    if (runtimeVisibleParameterAnnotationsOffset != 0) {
      readParameterAnnotations(
          methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible= */ true);
    }

    // Visit the RuntimeInvisibleParameterAnnotations attribute.
    if (runtimeInvisibleParameterAnnotationsOffset != 0) {
      readParameterAnnotations(
          methodVisitor, context, runtimeInvisibleParameterAnnotationsOffset, /* visible= */ false);
    }

    // Visit the non standard attributes.
    while (attributes != null) {
      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.
      Attribute nextAttribute = attributes.nextAttribute;
      attributes.nextAttribute = null;
      methodVisitor.visitAttribute(attributes);
      attributes = nextAttribute;
    }

    // Visit the Code attribute.
    if (codeOffset != 0) {
      methodVisitor.visitCode();
      readCode(methodVisitor, context, codeOffset);
    }

    // Visit the end of the method.
    methodVisitor.visitEnd();
    return currentOffset;
  }

  // ----------------------------------------------------------------------------------------------
  // Methods to parse a Code attribute
  // ----------------------------------------------------------------------------------------------

  /**
   * Reads a JVMS 'Code' attribute and makes the given visitor visit it.
   *
   * @param methodVisitor the visitor that must visit the Code attribute.
   * @param context information about the class being parsed.
   * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding
   *     its attribute_name_index and attribute_length fields.
   */
  private void readCode(
      final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
    int currentOffset = codeOffset;

    // Read the max_stack, max_locals and code_length fields.
    final byte[] classBuffer = classFileBuffer;
    final char[] charBuffer = context.charBuffer;
    final int maxStack = readUnsignedShort(currentOffset);
    final int maxLocals = readUnsignedShort(currentOffset + 2);
    final int codeLength = readInt(currentOffset + 4);
    currentOffset += 8;
    if (codeLength > classFileBuffer.length - currentOffset) {
      throw new IllegalArgumentException();
    }

    // Read the bytecode 'code' array to create a label for each referenced instruction.
    final int bytecodeStartOffset = currentOffset;
    final int bytecodeEndOffset = currentOffset + codeLength;
    final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];
    while (currentOffset < bytecodeEndOffset) {
      final int bytecodeOffset = currentOffset - bytecodeStartOffset;
      final int opcode = classBuffer[currentOffset] & 0xFF;
      switch (opcode) {
        case Opcodes.NOP:
        case Opcodes.ACONST_NULL:
        case Opcodes.ICONST_M1:
        case Opcodes.ICONST_0:
        case Opcodes.ICONST_1:
        case Opcodes.ICONST_2:
        case Opcodes.ICONST_3:
        case Opcodes.ICONST_4:
        case Opcodes.ICONST_5:
        case Opcodes.LCONST_0:
        case Opcodes.LCONST_1:
        case Opcodes.FCONST_0:
        case Opcodes.FCONST_1:
        case Opcodes.FCONST_2:
        case Opcodes.DCONST_0:
        case Opcodes.DCONST_1:
        case Opcodes.IALOAD:
        case Opcodes.LALOAD:
        case Opcodes.FALOAD:
        case Opcodes.DALOAD:
        case Opcodes.AALOAD:
        case Opcodes.BALOAD:
        case Opcodes.CALOAD:
        case Opcodes.SALOAD:
        case Opcodes.IASTORE:
        case Opcodes.LASTORE:
        case Opcodes.FASTORE:
        case Opcodes.DASTORE:
        case Opcodes.AASTORE:
        case Opcodes.BASTORE:
        case Opcodes.CASTORE:
        case Opcodes.SASTORE:
        case Opcodes.POP:
        case Opcodes.POP2:
        case Opcodes.DUP:
        case Opcodes.DUP_X1:
        case Opcodes.DUP_X2:
        case Opcodes.DUP2:
        case Opcodes.DUP2_X1:
        case Opcodes.DUP2_X2:
        case Opcodes.SWAP:
        case Opcodes.IADD:
        case Opcodes.LADD:
        case Opcodes.FADD:
        case Opcodes.DADD:
        case Opcodes.ISUB:
        case Opcodes.LSUB:
        case Opcodes.FSUB:
        case Opcodes.DSUB:
        case Opcodes.IMUL:
        case Opcodes.LMUL:
        case Opcodes.FMUL:
        case Opcodes.DMUL:
        case Opcodes.IDIV:
        case Opcodes.LDIV:
        case Opcodes.FDIV:
        case Opcodes.DDIV:
        case Opcodes.IREM:
        case Opcodes.LREM:
        case Opcodes.FREM:
        case Opcodes.DREM:
        case Opcodes.INEG:
        case Opcodes.LNEG:
        case Opcodes.FNEG:
        case Opcodes.DNEG:
        case Opcodes.ISHL:
        case Opcodes.LSHL:
        case Opcodes.ISHR:
        case Opcodes.LSHR:
        case Opcodes.IUSHR:
        case Opcodes.LUSHR:
        case Opcodes.IAND:
        case Opcodes.LAND:
        case Opcodes.IOR:
        case Opcodes.LOR:
        case Opcodes.IXOR:
        case Opcodes.LXOR:
        case Opcodes.I2L:
        case Opcodes.I2F:
        case Opcodes.I2D:
        case Opcodes.L2I:
        case Opcodes.L2F:
        case Opcodes.L2D:
        case Opcodes.F2I:
        case Opcodes.F2L:
        case Opcodes.F2D:
        case Opcodes.D2I:
        case Opcodes.D2L:
        case Opcodes.D2F:
        case Opcodes.I2B:
        case Opcodes.I2C:
        case Opcodes.I2S:
        case Opcodes.LCMP:
        case Opcodes.FCMPL:
        case Opcodes.FCMPG:
        case Opcodes.DCMPL:
        case Opcodes.DCMPG:
        case Opcodes.IRETURN:
        case Opcodes.LRETURN:
        case Opcodes.FRETURN:
        case Opcodes.DRETURN:
        case Opcodes.ARETURN:
        case Opcodes.RETURN:
        case Opcodes.ARRAYLENGTH:
        case Opcodes.ATHROW:
        case Opcodes.MONITORENTER:
        case Opcodes.MONITOREXIT:
        case Constants.ILOAD_0:
        case Constants.ILOAD_1:
        case Constants.ILOAD_2:
        case Constants.ILOAD_3:
        case Constants.LLOAD_0:
        case Constants.LLOAD_1:
        case Constants.LLOAD_2:
        case Constants.LLOAD_3:
        case Constants.FLOAD_0:
        case Constants.FLOAD_1:
        case Constants.FLOAD_2:
        case Constants.FLOAD_3:
        case Constants.DLOAD_0:
        case Constants.DLOAD_1:
        case Constants.DLOAD_2:
        case Constants.DLOAD_3:
        case Constants.ALOAD_0:
        case Constants.ALOAD_1:
        case Constants.ALOAD_2:
        case Constants.ALOAD_3:
        case Constants.ISTORE_0:
        case Constants.ISTORE_1:
        case Constants.ISTORE_2:
        case Constants.ISTORE_3:
        case Constants.LSTORE_0:
        case Constants.LSTORE_1:
        case Constants.LSTORE_2:
        case Constants.LSTORE_3:
        case Constants.FSTORE_0:
        case Constants.FSTORE_1:
        case Constants.FSTORE_2:
        case Constants.FSTORE_3:
        case Constants.DSTORE_0:
        case Constants.DSTORE_1:
        case Constants.DSTORE_2:
        case Constants.DSTORE_3:
        case Constants.ASTORE_0:
        case Constants.ASTORE_1:
        case Constants.ASTORE_2:
        case Constants.ASTORE_3:
          currentOffset += 1;
          break;
        case Opcodes.IFEQ:
        case Opcodes.IFNE:
        case Opcodes.IFLT:
        case Opcodes.IFGE:
        case Opcodes.IFGT:
        case Opcodes.IFLE:
        case Opcodes.IF_ICMPEQ:
        case Opcodes.IF_ICMPNE:
        case Opcodes.IF_ICMPLT:
        case Opcodes.IF_ICMPGE:
        case Opcodes.IF_ICMPGT:
        case Opcodes.IF_ICMPLE:
        case Opcodes.IF_ACMPEQ:
        case Opcodes.IF_ACMPNE:
        case Opcodes.GOTO:
        case Opcodes.JSR:
        case Opcodes.IFNULL:
        case Opcodes.IFNONNULL:
          createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);
          currentOffset += 3;
          break;
        case Constants.ASM_IFEQ:
        case Constants.ASM_IFNE:
        case Constants.ASM_IFLT:
        case Constants.ASM_IFGE:
        case Constants.ASM_IFGT:
        case Constants.ASM_IFLE:
        case Constants.ASM_IF_ICMPEQ:
        case Constants.ASM_IF_ICMPNE:
        case Constants.ASM_IF_ICMPLT:
        case Constants.ASM_IF_ICMPGE:
        case Constants.ASM_IF_ICMPGT:
        case Constants.ASM_IF_ICMPLE:
        case Constants.ASM_IF_ACMPEQ:
        case Constants.ASM_IF_ACMPNE:
        case Constants.ASM_GOTO:
        case Constants.ASM_JSR:
        case Constants.ASM_IFNULL:
        case Constants.ASM_IFNONNULL:
          createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);
          currentOffset += 3;
          break;
        case Constants.GOTO_W:
        case Constants.JSR_W:
        case Constants.ASM_GOTO_W:
          createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);
          currentOffset += 5;
          break;
        case Constants.WIDE:
          switch (classBuffer[currentOffset + 1] & 0xFF) {
            case Opcodes.ILOAD:
            case Opcodes.FLOAD:
            case Opcodes.ALOAD:
            case Opcodes.LLOAD:
            case Opcodes.DLOAD:
            case Opcodes.ISTORE:
            case Opcodes.FSTORE:
            case Opcodes.ASTORE:
            case Opcodes.LSTORE:
            case Opcodes.DSTORE:
            case Opcodes.RET:
              currentOffset += 4;
              break;
            case Opcodes.IINC:
              currentOffset += 6;
              break;
            default:
              throw new IllegalArgumentException();
          }
          break;
        case Opcodes.TABLESWITCH:
          // Skip 0 to 3 padding bytes.
          currentOffset += 4 - (bytecodeOffset & 3);
          // Read the default label and the number of table entries.
          createLabel(bytecodeOffset + readInt(currentOffset), labels);
          int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;
          currentOffset += 12;
          // Read the table labels.
          while (numTableEntries-- > 0) {
            createLabel(bytecodeOffset + readInt(currentOffset), labels);
            currentOffset += 4;
          }
          break;
        case Opcodes.LOOKUPSWITCH:
          // Skip 0 to 3 padding bytes.
          currentOffset += 4 - (bytecodeOffset & 3);
          // Read the default label and the number of switch cases.
          createLabel(bytecodeOffset + readInt(currentOffset), labels);
          int numSwitchCases = readInt(currentOffset + 4);
          currentOffset += 8;
          // Read the switch labels.
          while (numSwitchCases-- > 0) {
            createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);
            currentOffset += 8;
          }
          break;
        case Opcodes.ILOAD:
        case Opcodes.LLOAD:
        case Opcodes.FLOAD:
        case Opcodes.DLOAD:
        case Opcodes.ALOAD:
        case Opcodes.ISTORE:
        case Opcodes.LSTORE:
        case Opcodes.FSTORE:
        case Opcodes.DSTORE:
        case Opcodes.ASTORE:
        case Opcodes.RET:
        case Opcodes.BIPUSH:
        case Opcodes.NEWARRAY:
        case Opcodes.LDC:
          currentOffset += 2;
          break;
        case Opcodes.SIPUSH:
        case Constants.LDC_W:
        case Constants.LDC2_W:
        case Opcodes.GETSTATIC:
        case Opcodes.PUTSTATIC:
        case Opcodes.GETFIELD:
        case Opcodes.PUTFIELD:
        case Opcodes.INVOKEVIRTUAL:
        case Opcodes.INVOKESPECIAL:
        case Opcodes.INVOKESTATIC:
        case Opcodes.NEW:
        case Opcodes.ANEWARRAY:
        case Opcodes.CHECKCAST:
        case Opcodes.INSTANCEOF:
        case Opcodes.IINC:
          currentOffset += 3;
          break;
        case Opcodes.INVOKEINTERFACE:
        case Opcodes.INVOKEDYNAMIC:
          currentOffset += 5;
          break;
        case Opcodes.MULTIANEWARRAY:
          currentOffset += 4;
          break;
        default:
          throw new IllegalArgumentException();
      }
    }

    // Read the 'exception_table_length' and 'exception_table' field to create a label for each
    // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.
    int exceptionTableLength = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (exceptionTableLength-- > 0) {
      Label start = createLabel(readUnsignedShort(currentOffset), labels);
      Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);
      Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);
      String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);
      currentOffset += 8;
      methodVisitor.visitTryCatchBlock(start, end, handler, catchType);
    }

    // Read the Code attributes to create a label for each referenced instruction (the variables
    // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the
    // attribute_name_index and attribute_length fields.
    // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.
    // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is
    // updated after each stack_map_frame is read.
    int stackMapFrameOffset = 0;
    // - The end offset of the StackMap[Table] attribute, or 0.
    int stackMapTableEndOffset = 0;
    // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.
    boolean compressedFrames = true;
    // - The offset of the LocalVariableTable attribute, or 0.
    int localVariableTableOffset = 0;
    // - The offset of the LocalVariableTypeTable attribute, or 0.
    int localVariableTypeTableOffset = 0;
    // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations
    // attribute, or null.
    int[] visibleTypeAnnotationOffsets = null;
    // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations
    // attribute, or null.
    int[] invisibleTypeAnnotationOffsets = null;
    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
    Attribute attributes = null;

    int attributesCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (attributesCount-- > 0) {
      // Read the attribute_info's attribute_name and attribute_length fields.
      String attributeName = readUTF8(currentOffset, charBuffer);
      int attributeLength = readInt(currentOffset + 2);
      currentOffset += 6;
      if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {
        if ((context.parsingOptions & SKIP_DEBUG) == 0) {
          localVariableTableOffset = currentOffset;
          // Parse the attribute to find the corresponding (debug only) labels.
          int currentLocalVariableTableOffset = currentOffset;
          int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);
          currentLocalVariableTableOffset += 2;
          while (localVariableTableLength-- > 0) {
            int startPc = readUnsignedShort(currentLocalVariableTableOffset);
            createDebugLabel(startPc, labels);
            int length = readUnsignedShort(currentLocalVariableTableOffset + 2);
            createDebugLabel(startPc + length, labels);
            // Skip the name_index, descriptor_index and index fields (2 bytes each).
            currentLocalVariableTableOffset += 10;
          }
        }
      } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {
        localVariableTypeTableOffset = currentOffset;
        // Here we do not extract the labels corresponding to the attribute content. We assume they
        // are the same or a subset of those of the LocalVariableTable attribute.
      } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {
        if ((context.parsingOptions & SKIP_DEBUG) == 0) {
          // Parse the attribute to find the corresponding (debug only) labels.
          int currentLineNumberTableOffset = currentOffset;
          int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);
          currentLineNumberTableOffset += 2;
          while (lineNumberTableLength-- > 0) {
            int startPc = readUnsignedShort(currentLineNumberTableOffset);
            int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);
            currentLineNumberTableOffset += 4;
            createDebugLabel(startPc, labels);
            labels[startPc].addLineNumber(lineNumber);
          }
        }
      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        visibleTypeAnnotationOffsets =
            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */ true);
        // Here we do not extract the labels corresponding to the attribute content. This would
        // require a full parsing of the attribute, which would need to be repeated when parsing
        // the bytecode instructions (see below). Instead, the content of the attribute is read one
        // type annotation at a time (i.e. after a type annotation has been visited, the next type
        // annotation is read), and the labels it contains are also extracted one annotation at a
        // time. This assumes that type annotations are ordered by increasing bytecode offset.
      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
        invisibleTypeAnnotationOffsets =
            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */ false);
        // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.
      } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {
        if ((context.parsingOptions & SKIP_FRAMES) == 0) {
          stackMapFrameOffset = currentOffset + 2;
          stackMapTableEndOffset = currentOffset + attributeLength;
        }
        // Here we do not extract the labels corresponding to the attribute content. This would
        // require a full parsing of the attribute, which would need to be repeated when parsing
        // the bytecode instructions (see below). Instead, the content of the attribute is read one
        // frame at a time (i.e. after a frame has been visited, the next frame is read), and the
        // labels it contains are also extracted one frame at a time. Thanks to the ordering of
        // frames, having only a "one frame lookahead" is not a problem, i.e. it is not possible to
        // see an offset smaller than the offset of the current instruction and for which no Label
        // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map
        // table without a full decoding (see below).
      } else if ("StackMap".equals(attributeName)) {
        if ((context.parsingOptions & SKIP_FRAMES) == 0) {
          stackMapFrameOffset = currentOffset + 2;
          stackMapTableEndOffset = currentOffset + attributeLength;
          compressedFrames = false;
        }
        // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,
        // although this is not guaranteed by the attribute format. This allows an incremental
        // extraction of the labels corresponding to this attribute (see the comment above for the
        // StackMapTable attribute).
      } else {
        Attribute attribute =
            readAttribute(
                context.attributePrototypes,
                attributeName,
                currentOffset,
                attributeLength,
                charBuffer,
                codeOffset,
                labels);
        attribute.nextAttribute = attributes;
        attributes = attribute;
      }
      currentOffset += attributeLength;
    }

    // Initialize the context fields related to stack map frames, and generate the first
    // (implicit) stack map frame, if needed.
    final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;
    if (stackMapFrameOffset != 0) {
      // The bytecode offset of the first explicit frame is not offset_delta + 1 but only
      // offset_delta. Setting the implicit frame offset to -1 allows us to use of the
      // "offset_delta + 1" rule in all cases.
      context.currentFrameOffset = -1;
      context.currentFrameType = 0;
      context.currentFrameLocalCount = 0;
      context.currentFrameLocalCountDelta = 0;
      context.currentFrameLocalTypes = new Object[maxLocals];
      context.currentFrameStackCount = 0;
      context.currentFrameStackTypes = new Object[maxStack];
      if (expandFrames) {
        computeImplicitFrame(context);
      }
      // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the
      // stack map table, we look for 3 consecutive bytes that "look like" an UNINITIALIZED type
      // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).
      // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
      // and the only consequence will be the creation of an unneeded label. This is better than
      // creating a label for each NEW instruction, and faster than fully decoding the whole stack
      // map table.
      for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {
        if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {
          int potentialBytecodeOffset = readUnsignedShort(offset + 1);
          if (potentialBytecodeOffset >= 0
              && potentialBytecodeOffset < codeLength
              && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF)
                  == Opcodes.NEW) {
            createLabel(potentialBytecodeOffset, labels);
          }
        }
      }
    }
    if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {
      // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method
      // does not currently have any frame. These inserted frames must be computed by simulating the
      // effect of the bytecode instructions, one by one, starting from the implicit first frame.
      // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To
      // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is
      // computed in MethodWriter).
      methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);
    }

    // Visit the bytecode instructions. First, introduce state variables for the incremental parsing
    // of the type annotations.

    // Index of the next runtime visible type annotation to read (in the
    // visibleTypeAnnotationOffsets array).
    int currentVisibleTypeAnnotationIndex = 0;
    // The bytecode offset of the next runtime visible type annotation to read, or -1.
    int currentVisibleTypeAnnotationBytecodeOffset =
        getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);
    // Index of the next runtime invisible type annotation to read (in the
    // invisibleTypeAnnotationOffsets array).
    int currentInvisibleTypeAnnotationIndex = 0;
    // The bytecode offset of the next runtime invisible type annotation to read, or -1.
    int currentInvisibleTypeAnnotationBytecodeOffset =
        getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);

    // Whether a F_INSERT stack map frame must be inserted before the current instruction.
    boolean insertFrame = false;

    // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr
    // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific
    // instructions).
    final int wideJumpOpcodeDelta =
        (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;

    currentOffset = bytecodeStartOffset;
    while (currentOffset < bytecodeEndOffset) {
      final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;
      readBytecodeInstructionOffset(currentBytecodeOffset);

      // Visit the label and the line number(s) for this bytecode offset, if any.
      Label currentLabel = labels[currentBytecodeOffset];
      if (currentLabel != null) {
        currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);
      }

      // Visit the stack map frame for this bytecode offset, if any.
      while (stackMapFrameOffset != 0
          && (context.currentFrameOffset == currentBytecodeOffset
              || context.currentFrameOffset == -1)) {
        // If there is a stack map frame for this offset, make methodVisitor visit it, and read the
        // next stack map frame if there is one.
        if (context.currentFrameOffset != -1) {
          if (!compressedFrames || expandFrames) {
            methodVisitor.visitFrame(
                Opcodes.F_NEW,
                context.currentFrameLocalCount,
                context.currentFrameLocalTypes,
                context.currentFrameStackCount,
                context.currentFrameStackTypes);
          } else {
            methodVisitor.visitFrame(
                context.currentFrameType,
                context.currentFrameLocalCountDelta,
                context.currentFrameLocalTypes,
                context.currentFrameStackCount,
                context.currentFrameStackTypes);
          }
          // Since there is already a stack map frame for this bytecode offset, there is no need to
          // insert a new one.
          insertFrame = false;
        }
        if (stackMapFrameOffset < stackMapTableEndOffset) {
          stackMapFrameOffset =
              readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);
        } else {
          stackMapFrameOffset = 0;
        }
      }

      // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to
      // true during the previous iteration. The actual frame content is computed in MethodWriter.
      if (insertFrame) {
        if ((context.parsingOptions & EXPAND_FRAMES) != 0) {
          methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);
        }
        insertFrame = false;
      }

      // Visit the instruction at this bytecode offset.
      int opcode = classBuffer[currentOffset] & 0xFF;
      switch (opcode) {
        case Opcodes.NOP:
        case Opcodes.ACONST_NULL:
        case Opcodes.ICONST_M1:
        case Opcodes.ICONST_0:
        case Opcodes.ICONST_1:
        case Opcodes.ICONST_2:
        case Opcodes.ICONST_3:
        case Opcodes.ICONST_4:
        case Opcodes.ICONST_5:
        case Opcodes.LCONST_0:
        case Opcodes.LCONST_1:
        case Opcodes.FCONST_0:
        case Opcodes.FCONST_1:
        case Opcodes.FCONST_2:
        case Opcodes.DCONST_0:
        case Opcodes.DCONST_1:
        case Opcodes.IALOAD:
        case Opcodes.LALOAD:
        case Opcodes.FALOAD:
        case Opcodes.DALOAD:
        case Opcodes.AALOAD:
        case Opcodes.BALOAD:
        case Opcodes.CALOAD:
        case Opcodes.SALOAD:
        case Opcodes.IASTORE:
        case Opcodes.LASTORE:
        case Opcodes.FASTORE:
        case Opcodes.DASTORE:
        case Opcodes.AASTORE:
        case Opcodes.BASTORE:
        case Opcodes.CASTORE:
        case Opcodes.SASTORE:
        case Opcodes.POP:
        case Opcodes.POP2:
        case Opcodes.DUP:
        case Opcodes.DUP_X1:
        case Opcodes.DUP_X2:
        case Opcodes.DUP2:
        case Opcodes.DUP2_X1:
        case Opcodes.DUP2_X2:
        case Opcodes.SWAP:
        case Opcodes.IADD:
        case Opcodes.LADD:
        case Opcodes.FADD:
        case Opcodes.DADD:
        case Opcodes.ISUB:
        case Opcodes.LSUB:
        case Opcodes.FSUB:
        case Opcodes.DSUB:
        case Opcodes.IMUL:
        case Opcodes.LMUL:
        case Opcodes.FMUL:
        case Opcodes.DMUL:
        case Opcodes.IDIV:
        case Opcodes.LDIV:
        case Opcodes.FDIV:
        case Opcodes.DDIV:
        case Opcodes.IREM:
        case Opcodes.LREM:
        case Opcodes.FREM:
        case Opcodes.DREM:
        case Opcodes.INEG:
        case Opcodes.LNEG:
        case Opcodes.FNEG:
        case Opcodes.DNEG:
        case Opcodes.ISHL:
        case Opcodes.LSHL:
        case Opcodes.ISHR:
        case Opcodes.LSHR:
        case Opcodes.IUSHR:
        case Opcodes.LUSHR:
        case Opcodes.IAND:
        case Opcodes.LAND:
        case Opcodes.IOR:
        case Opcodes.LOR:
        case Opcodes.IXOR:
        case Opcodes.LXOR:
        case Opcodes.I2L:
        case Opcodes.I2F:
        case Opcodes.I2D:
        case Opcodes.L2I:
        case Opcodes.L2F:
        case Opcodes.L2D:
        case Opcodes.F2I:
        case Opcodes.F2L:
        case Opcodes.F2D:
        case Opcodes.D2I:
        case Opcodes.D2L:
        case Opcodes.D2F:
        case Opcodes.I2B:
        case Opcodes.I2C:
        case Opcodes.I2S:
        case Opcodes.LCMP:
        case Opcodes.FCMPL:
        case Opcodes.FCMPG:
        case Opcodes.DCMPL:
        case Opcodes.DCMPG:
        case Opcodes.IRETURN:
        case Opcodes.LRETURN:
        case Opcodes.FRETURN:
        case Opcodes.DRETURN:
        case Opcodes.ARETURN:
        case Opcodes.RETURN:
        case Opcodes.ARRAYLENGTH:
        case Opcodes.ATHROW:
        case Opcodes.MONITORENTER:
        case Opcodes.MONITOREXIT:
          methodVisitor.visitInsn(opcode);
          currentOffset += 1;
          break;
        case Constants.ILOAD_0:
        case Constants.ILOAD_1:
        case Constants.ILOAD_2:
        case Constants.ILOAD_3:
        case Constants.LLOAD_0:
        case Constants.LLOAD_1:
        case Constants.LLOAD_2:
        case Constants.LLOAD_3:
        case Constants.FLOAD_0:
        case Constants.FLOAD_1:
        case Constants.FLOAD_2:
        case Constants.FLOAD_3:
        case Constants.DLOAD_0:
        case Constants.DLOAD_1:
        case Constants.DLOAD_2:
        case Constants.DLOAD_3:
        case Constants.ALOAD_0:
        case Constants.ALOAD_1:
        case Constants.ALOAD_2:
        case Constants.ALOAD_3:
          opcode -= Constants.ILOAD_0;
          methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);
          currentOffset += 1;
          break;
        case Constants.ISTORE_0:
        case Constants.ISTORE_1:
        case Constants.ISTORE_2:
        case Constants.ISTORE_3:
        case Constants.LSTORE_0:
        case Constants.LSTORE_1:
        case Constants.LSTORE_2:
        case Constants.LSTORE_3:
        case Constants.FSTORE_0:
        case Constants.FSTORE_1:
        case Constants.FSTORE_2:
        case Constants.FSTORE_3:
        case Constants.DSTORE_0:
        case Constants.DSTORE_1:
        case Constants.DSTORE_2:
        case Constants.DSTORE_3:
        case Constants.ASTORE_0:
        case Constants.ASTORE_1:
        case Constants.ASTORE_2:
        case Constants.ASTORE_3:
          opcode -= Constants.ISTORE_0;
          methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);
          currentOffset += 1;
          break;
        case Opcodes.IFEQ:
        case Opcodes.IFNE:
        case Opcodes.IFLT:
        case Opcodes.IFGE:
        case Opcodes.IFGT:
        case Opcodes.IFLE:
        case Opcodes.IF_ICMPEQ:
        case Opcodes.IF_ICMPNE:
        case Opcodes.IF_ICMPLT:
        case Opcodes.IF_ICMPGE:
        case Opcodes.IF_ICMPGT:
        case Opcodes.IF_ICMPLE:
        case Opcodes.IF_ACMPEQ:
        case Opcodes.IF_ACMPNE:
        case Opcodes.GOTO:
        case Opcodes.JSR:
        case Opcodes.IFNULL:
        case Opcodes.IFNONNULL:
          methodVisitor.visitJumpInsn(
              opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);
          currentOffset += 3;
          break;
        case Constants.GOTO_W:
        case Constants.JSR_W:
          methodVisitor.visitJumpInsn(
              opcode - wideJumpOpcodeDelta,
              labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
          currentOffset += 5;
          break;
        case Constants.ASM_IFEQ:
        case Constants.ASM_IFNE:
        case Constants.ASM_IFLT:
        case Constants.ASM_IFGE:
        case Constants.ASM_IFGT:
        case Constants.ASM_IFLE:
        case Constants.ASM_IF_ICMPEQ:
        case Constants.ASM_IF_ICMPNE:
        case Constants.ASM_IF_ICMPLT:
        case Constants.ASM_IF_ICMPGE:
        case Constants.ASM_IF_ICMPGT:
        case Constants.ASM_IF_ICMPLE:
        case Constants.ASM_IF_ACMPEQ:
        case Constants.ASM_IF_ACMPNE:
        case Constants.ASM_GOTO:
        case Constants.ASM_JSR:
        case Constants.ASM_IFNULL:
        case Constants.ASM_IFNONNULL:
          {
            // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO
            // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,
            // where IFNOTxxx is the "opposite" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and
            // where <L> designates the instruction just after the GOTO_W.
            // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and
            // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.
            opcode =
                opcode < Constants.ASM_IFNULL
                    ? opcode - Constants.ASM_OPCODE_DELTA
                    : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;
            Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];
            if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {
              // Replace GOTO with GOTO_W and JSR with JSR_W.
              methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);
            } else {
              // Compute the "opposite" of opcode. This can be done by flipping the least
              // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ
              // (with a pre and post offset by 1).
              opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;
              Label endif = createLabel(currentBytecodeOffset + 3, labels);
              methodVisitor.visitJumpInsn(opcode, endif);
              methodVisitor.visitJumpInsn(Constants.GOTO_W, target);
              // endif designates the instruction just after GOTO_W, and is visited as part of the
              // next instruction. Since it is a jump target, we need to insert a frame here.
              insertFrame = true;
            }
            currentOffset += 3;
            break;
          }
        case Constants.ASM_GOTO_W:
          // Replace ASM_GOTO_W with GOTO_W.
          methodVisitor.visitJumpInsn(
              Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
          // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns
          // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame
          // here.
          insertFrame = true;
          currentOffset += 5;
          break;
        case Constants.WIDE:
          opcode = classBuffer[currentOffset + 1] & 0xFF;
          if (opcode == Opcodes.IINC) {
            methodVisitor.visitIincInsn(
                readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));
            currentOffset += 6;
          } else {
            methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));
            currentOffset += 4;
          }
          break;
        case Opcodes.TABLESWITCH:
          {
            // Skip 0 to 3 padding bytes.
            currentOffset += 4 - (currentBytecodeOffset & 3);
            // Read the instruction.
            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
            int low = readInt(currentOffset + 4);
            int high = readInt(currentOffset + 8);
            currentOffset += 12;
            Label[] table = new Label[high - low + 1];
            for (int i = 0; i < table.length; ++i) {
              table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];
              currentOffset += 4;
            }
            methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);
            break;
          }
        case Opcodes.LOOKUPSWITCH:
          {
            // Skip 0 to 3 padding bytes.
            currentOffset += 4 - (currentBytecodeOffset & 3);
            // Read the instruction.
            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
            int numPairs = readInt(currentOffset + 4);
            currentOffset += 8;
            int[] keys = new int[numPairs];
            Label[] values = new Label[numPairs];
            for (int i = 0; i < numPairs; ++i) {
              keys[i] = readInt(currentOffset);
              values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];
              currentOffset += 8;
            }
            methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);
            break;
          }
        case Opcodes.ILOAD:
        case Opcodes.LLOAD:
        case Opcodes.FLOAD:
        case Opcodes.DLOAD:
        case Opcodes.ALOAD:
        case Opcodes.ISTORE:
        case Opcodes.LSTORE:
        case Opcodes.FSTORE:
        case Opcodes.DSTORE:
        case Opcodes.ASTORE:
        case Opcodes.RET:
          methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);
          currentOffset += 2;
          break;
        case Opcodes.BIPUSH:
        case Opcodes.NEWARRAY:
          methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);
          currentOffset += 2;
          break;
        case Opcodes.SIPUSH:
          methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));
          currentOffset += 3;
          break;
        case Opcodes.LDC:
          methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));
          currentOffset += 2;
          break;
        case Constants.LDC_W:
        case Constants.LDC2_W:
          methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));
          currentOffset += 3;
          break;
        case Opcodes.GETSTATIC:
        case Opcodes.PUTSTATIC:
        case Opcodes.GETFIELD:
        case Opcodes.PUTFIELD:
        case Opcodes.INVOKEVIRTUAL:
        case Opcodes.INVOKESPECIAL:
        case Opcodes.INVOKESTATIC:
        case Opcodes.INVOKEINTERFACE:
          {
            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
            String owner = readClass(cpInfoOffset, charBuffer);
            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
            if (opcode < Opcodes.INVOKEVIRTUAL) {
              methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
            } else {
              boolean isInterface =
                  classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
              methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
            }
            if (opcode == Opcodes.INVOKEINTERFACE) {
              currentOffset += 5;
            } else {
              currentOffset += 3;
            }
            break;
          }
        case Opcodes.INVOKEDYNAMIC:
          {
            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
            int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];
            Handle handle =
                (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
            Object[] bootstrapMethodArguments =
                new Object[readUnsignedShort(bootstrapMethodOffset + 2)];
            bootstrapMethodOffset += 4;
            for (int i = 0; i < bootstrapMethodArguments.length; i++) {
              bootstrapMethodArguments[i] =
                  readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
              bootstrapMethodOffset += 2;
            }
            methodVisitor.visitInvokeDynamicInsn(
                name, descriptor, handle, bootstrapMethodArguments);
            currentOffset += 5;
            break;
          }
        case Opcodes.NEW:
        case Opcodes.ANEWARRAY:
        case Opcodes.CHECKCAST:
        case Opcodes.INSTANCEOF:
          methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
          currentOffset += 3;
          break;
        case Opcodes.IINC:
          methodVisitor.visitIincInsn(
              classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);
          currentOffset += 3;
          break;
        case Opcodes.MULTIANEWARRAY:
          methodVisitor.visitMultiANewArrayInsn(
              readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);
          currentOffset += 4;
          break;
        default:
          throw new AssertionError();
      }

      // Visit the runtime visible instruction annotations, if any.
      while (visibleTypeAnnotationOffsets != null
          && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length
          && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {
        if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {
          // Parse the target_type, target_info and target_path fields.
          int currentAnnotationOffset =
              readTypeAnnotationTarget(
                  context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);
          // Parse the type_index field.
          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
          currentAnnotationOffset += 2;
          // Parse num_element_value_pairs and element_value_pairs and visit these values.
          readElementValues(
              methodVisitor.visitInsnAnnotation(
                  context.currentTypeAnnotationTarget,
                  context.currentTypeAnnotationTargetPath,
                  annotationDescriptor,
                  /* visible= */ true),
              currentAnnotationOffset,
              /* named= */ true,
              charBuffer);
        }
        currentVisibleTypeAnnotationBytecodeOffset =
            getTypeAnnotationBytecodeOffset(
                visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);
      }

      // Visit the runtime invisible instruction annotations, if any.
      while (invisibleTypeAnnotationOffsets != null
          && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length
          && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {
        if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {
          // Parse the target_type, target_info and target_path fields.
          int currentAnnotationOffset =
              readTypeAnnotationTarget(
                  context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);
          // Parse the type_index field.
          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
          currentAnnotationOffset += 2;
          // Parse num_element_value_pairs and element_value_pairs and visit these values.
          readElementValues(
              methodVisitor.visitInsnAnnotation(
                  context.currentTypeAnnotationTarget,
                  context.currentTypeAnnotationTargetPath,
                  annotationDescriptor,
                  /* visible= */ false),
              currentAnnotationOffset,
              /* named= */ true,
              charBuffer);
        }
        currentInvisibleTypeAnnotationBytecodeOffset =
            getTypeAnnotationBytecodeOffset(
                invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);
      }
    }
    if (labels[codeLength] != null) {
      methodVisitor.visitLabel(labels[codeLength]);
    }

    // Visit LocalVariableTable and LocalVariableTypeTable attributes.
    if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {
      // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.
      int[] typeTable = null;
      if (localVariableTypeTableOffset != 0) {
        typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];
        currentOffset = localVariableTypeTableOffset + 2;
        int typeTableIndex = typeTable.length;
        while (typeTableIndex > 0) {
          // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.
          typeTable[--typeTableIndex] = currentOffset + 6;
          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);
          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);
          currentOffset += 10;
        }
      }
      int localVariableTableLength = readUnsignedShort(localVariableTableOffset);
      currentOffset = localVariableTableOffset + 2;
      while (localVariableTableLength-- > 0) {
        int startPc = readUnsignedShort(currentOffset);
        int length = readUnsignedShort(currentOffset + 2);
        String name = readUTF8(currentOffset + 4, charBuffer);
        String descriptor = readUTF8(currentOffset + 6, charBuffer);
        int index = readUnsignedShort(currentOffset + 8);
        currentOffset += 10;
        String signature = null;
        if (typeTable != null) {
          for (int i = 0; i < typeTable.length; i += 3) {
            if (typeTable[i] == startPc && typeTable[i + 1] == index) {
              signature = readUTF8(typeTable[i + 2], charBuffer);
              break;
            }
          }
        }
        methodVisitor.visitLocalVariable(
            name, descriptor, signature, labels[startPc], labels[startPc + length], index);
      }
    }

    // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.
    if (visibleTypeAnnotationOffsets != null) {
      for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {
        int targetType = readByte(typeAnnotationOffset);
        if (targetType == TypeReference.LOCAL_VARIABLE
            || targetType == TypeReference.RESOURCE_VARIABLE) {
          // Parse the target_type, target_info and target_path fields.
          currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);
          // Parse the type_index field.
          String annotationDescriptor = readUTF8(currentOffset, charBuffer);
          currentOffset += 2;
          // Parse num_element_value_pairs and element_value_pairs and visit these values.
          readElementValues(
              methodVisitor.visitLocalVariableAnnotation(
                  context.currentTypeAnnotationTarget,
                  context.currentTypeAnnotationTargetPath,
                  context.currentLocalVariableAnnotationRangeStarts,
                  context.currentLocalVariableAnnotationRangeEnds,
                  context.currentLocalVariableAnnotationRangeIndices,
                  annotationDescriptor,
                  /* visible= */ true),
              currentOffset,
              /* named= */ true,
              charBuffer);
        }
      }
    }

    // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.
    if (invisibleTypeAnnotationOffsets != null) {
      for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {
        int targetType = readByte(typeAnnotationOffset);
        if (targetType == TypeReference.LOCAL_VARIABLE
            || targetType == TypeReference.RESOURCE_VARIABLE) {
          // Parse the target_type, target_info and target_path fields.
          currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);
          // Parse the type_index field.
          String annotationDescriptor = readUTF8(currentOffset, charBuffer);
          currentOffset += 2;
          // Parse num_element_value_pairs and element_value_pairs and visit these values.
          readElementValues(
              methodVisitor.visitLocalVariableAnnotation(
                  context.currentTypeAnnotationTarget,
                  context.currentTypeAnnotationTargetPath,
                  context.currentLocalVariableAnnotationRangeStarts,
                  context.currentLocalVariableAnnotationRangeEnds,
                  context.currentLocalVariableAnnotationRangeIndices,
                  annotationDescriptor,
                  /* visible= */ false),
              currentOffset,
              /* named= */ true,
              charBuffer);
        }
      }
    }

    // Visit the non standard attributes.
    while (attributes != null) {
      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.
      Attribute nextAttribute = attributes.nextAttribute;
      attributes.nextAttribute = null;
      methodVisitor.visitAttribute(attributes);
      attributes = nextAttribute;
    }

    // Visit the max stack and max locals values.
    methodVisitor.visitMaxs(maxStack, maxLocals);
  }

  /**
   * Handles the bytecode offset of the next instruction to be visited in {@link
   * #accept(ClassVisitor,int)}. This method is called just before the instruction and before its
   * associated label and stack map frame, if any. The default implementation of this method does
   * nothing. Subclasses can override this method to store the argument in a mutable field, for
   * instance, so that {@link MethodVisitor} instances can get the bytecode offset of each visited
   * instruction (if so, the usual concurrency issues related to mutable data should be addressed).
   *
   * @param bytecodeOffset the bytecode offset of the next instruction to be visited.
   */
  protected void readBytecodeInstructionOffset(final int bytecodeOffset) {
    // Do nothing by default.
  }

  /**
   * Returns the label corresponding to the given bytecode offset. The default implementation of
   * this method creates a label for the given offset if it has not been already created.
   *
   * @param bytecodeOffset a bytecode offset in a method.
   * @param labels the already created labels, indexed by their offset. If a label already exists
   *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new
   *     label in this array.
   * @return a non null Label, which must be equal to labels[bytecodeOffset].
   */
  protected Label readLabel(final int bytecodeOffset, final Label[] labels) {
    if (labels[bytecodeOffset] == null) {
      labels[bytecodeOffset] = new Label();
    }
    return labels[bytecodeOffset];
  }

  /**
   * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode
   * offset. The label is created with a call to {@link #readLabel} and its {@link
   * Label#FLAG_DEBUG_ONLY} flag is cleared.
   *
   * @param bytecodeOffset a bytecode offset in a method.
   * @param labels the already created labels, indexed by their offset.
   * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.
   */
  private Label createLabel(final int bytecodeOffset, final Label[] labels) {
    Label label = readLabel(bytecodeOffset, labels);
    label.flags &= ~Label.FLAG_DEBUG_ONLY;
    return label;
  }

  /**
   * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already
   * existing label for the given bytecode offset (otherwise does nothing). The label is created
   * with a call to {@link #readLabel}.
   *
   * @param bytecodeOffset a bytecode offset in a method.
   * @param labels the already created labels, indexed by their offset.
   */
  private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {
    if (labels[bytecodeOffset] == null) {
      readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;
    }
  }

  // ----------------------------------------------------------------------------------------------
  // Methods to parse annotations, type annotations and parameter annotations
  // ----------------------------------------------------------------------------------------------

  /**
   * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation
   * entry it contains, to find the corresponding labels, and to visit the try catch block
   * annotations.
   *
   * @param methodVisitor the method visitor to be used to visit the try catch block annotations.
   * @param context information about the class being parsed.
   * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations
   *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.
   * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,
   *     false it is a RuntimeInvisibleTypeAnnotations attribute.
   * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's
   *     'annotations' array field.
   */
  private int[] readTypeAnnotations(
      final MethodVisitor methodVisitor,
      final Context context,
      final int runtimeTypeAnnotationsOffset,
      final boolean visible) {
    char[] charBuffer = context.charBuffer;
    int currentOffset = runtimeTypeAnnotationsOffset;
    // Read the num_annotations field and create an array to store the type_annotation offsets.
    int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];
    currentOffset += 2;
    // Parse the 'annotations' array field.
    for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {
      typeAnnotationsOffsets[i] = currentOffset;
      // Parse the type_annotation's target_type and the target_info fields. The size of the
      // target_info field depends on the value of target_type.
      int targetType = readInt(currentOffset);
      switch (targetType >>> 24) {
        case TypeReference.LOCAL_VARIABLE:
        case TypeReference.RESOURCE_VARIABLE:
          // A localvar_target has a variable size, which depends on the value of their table_length
          // field. It also references bytecode offsets, for which we need labels.
          int tableLength = readUnsignedShort(currentOffset + 1);
          currentOffset += 3;
          while (tableLength-- > 0) {
            int startPc = readUnsignedShort(currentOffset);
            int length = readUnsignedShort(currentOffset + 2);
            // Skip the index field (2 bytes).
            currentOffset += 6;
            createLabel(startPc, context.currentMethodLabels);
            createLabel(startPc + length, context.currentMethodLabels);
          }
          break;
        case TypeReference.CAST:
        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
          currentOffset += 4;
          break;
        case TypeReference.CLASS_EXTENDS:
        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
        case TypeReference.THROWS:
        case TypeReference.EXCEPTION_PARAMETER:
        case TypeReference.INSTANCEOF:
        case TypeReference.NEW:
        case TypeReference.CONSTRUCTOR_REFERENCE:
        case TypeReference.METHOD_REFERENCE:
          currentOffset += 3;
          break;
        case TypeReference.CLASS_TYPE_PARAMETER:
        case TypeReference.METHOD_TYPE_PARAMETER:
        case TypeReference.METHOD_FORMAL_PARAMETER:
        case TypeReference.FIELD:
        case TypeReference.METHOD_RETURN:
        case TypeReference.METHOD_RECEIVER:
        default:
          // TypeReference type which can't be used in Code attribute, or which is unknown.
          throw new IllegalArgumentException();
      }
      // Parse the rest of the type_annotation structure, starting with the target_path structure
      // (whose size depends on its path_length field).
      int pathLength = readByte(currentOffset);
      if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {
        // Parse the target_path structure and create a corresponding TypePath.
        TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
        currentOffset += 1 + 2 * pathLength;
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentOffset, charBuffer);
        currentOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentOffset =
            readElementValues(
                methodVisitor.visitTryCatchAnnotation(
                    targetType & 0xFFFFFF00, path, annotationDescriptor, visible),
                currentOffset,
                /* named= */ true,
                charBuffer);
      } else {
        // We don't want to visit the other target_type annotations, so we just skip them (which
        // requires some parsing because the element_value_pairs array has a variable size). First,
        // skip the target_path structure:
        currentOffset += 3 + 2 * pathLength;
        // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them
        // with a null AnnotationVisitor).
        currentOffset =
            readElementValues(
                /* annotationVisitor= */ null, currentOffset, /* named= */ true, charBuffer);
      }
    }
    return typeAnnotationsOffsets;
  }

  /**
   * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or
   * -1 if there is no such type_annotation of if it does not have a bytecode offset.
   *
   * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a
   *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.
   * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.
   * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1
   *     if there is no such type_annotation of if it does not have a bytecode offset.
   */
  private int getTypeAnnotationBytecodeOffset(
      final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {
    if (typeAnnotationOffsets == null
        || typeAnnotationIndex >= typeAnnotationOffsets.length
        || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {
      return -1;
    }
    return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);
  }

  /**
   * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info
   * and target_path (the result is stored in the given context), and returns the start offset of
   * the rest of the type_annotation structure.
   *
   * @param context information about the class being parsed. This is where the extracted
   *     target_type and target_path must be stored.
   * @param typeAnnotationOffset the start offset of a type_annotation structure.
   * @return the start offset of the rest of the type_annotation structure.
   */
  private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {
    int currentOffset = typeAnnotationOffset;
    // Parse and store the target_type structure.
    int targetType = readInt(typeAnnotationOffset);
    switch (targetType >>> 24) {
      case TypeReference.CLASS_TYPE_PARAMETER:
      case TypeReference.METHOD_TYPE_PARAMETER:
      case TypeReference.METHOD_FORMAL_PARAMETER:
        targetType &= 0xFFFF0000;
        currentOffset += 2;
        break;
      case TypeReference.FIELD:
      case TypeReference.METHOD_RETURN:
      case TypeReference.METHOD_RECEIVER:
        targetType &= 0xFF000000;
        currentOffset += 1;
        break;
      case TypeReference.LOCAL_VARIABLE:
      case TypeReference.RESOURCE_VARIABLE:
        targetType &= 0xFF000000;
        int tableLength = readUnsignedShort(currentOffset + 1);
        currentOffset += 3;
        context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];
        context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];
        context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];
        for (int i = 0; i < tableLength; ++i) {
          int startPc = readUnsignedShort(currentOffset);
          int length = readUnsignedShort(currentOffset + 2);
          int index = readUnsignedShort(currentOffset + 4);
          currentOffset += 6;
          context.currentLocalVariableAnnotationRangeStarts[i] =
              createLabel(startPc, context.currentMethodLabels);
          context.currentLocalVariableAnnotationRangeEnds[i] =
              createLabel(startPc + length, context.currentMethodLabels);
          context.currentLocalVariableAnnotationRangeIndices[i] = index;
        }
        break;
      case TypeReference.CAST:
      case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
      case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
      case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
      case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
        targetType &= 0xFF0000FF;
        currentOffset += 4;
        break;
      case TypeReference.CLASS_EXTENDS:
      case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
      case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
      case TypeReference.THROWS:
      case TypeReference.EXCEPTION_PARAMETER:
        targetType &= 0xFFFFFF00;
        currentOffset += 3;
        break;
      case TypeReference.INSTANCEOF:
      case TypeReference.NEW:
      case TypeReference.CONSTRUCTOR_REFERENCE:
      case TypeReference.METHOD_REFERENCE:
        targetType &= 0xFF000000;
        currentOffset += 3;
        break;
      default:
        throw new IllegalArgumentException();
    }
    context.currentTypeAnnotationTarget = targetType;
    // Parse and store the target_path structure.
    int pathLength = readByte(currentOffset);
    context.currentTypeAnnotationTargetPath =
        pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
    // Return the start offset of the rest of the type_annotation structure.
    return currentOffset + 1 + 2 * pathLength;
  }

  /**
   * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.
   *
   * @param methodVisitor the visitor that must visit the parameter annotations.
   * @param context information about the class being parsed.
   * @param runtimeParameterAnnotationsOffset the start offset of a
   *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's
   *     attribute_name_index and attribute_length fields.
   * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations
   *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.
   */
  private void readParameterAnnotations(
      final MethodVisitor methodVisitor,
      final Context context,
      final int runtimeParameterAnnotationsOffset,
      final boolean visible) {
    int currentOffset = runtimeParameterAnnotationsOffset;
    int numParameters = classFileBuffer[currentOffset++] & 0xFF;
    methodVisitor.visitAnnotableParameterCount(numParameters, visible);
    char[] charBuffer = context.charBuffer;
    for (int i = 0; i < numParameters; ++i) {
      int numAnnotations = readUnsignedShort(currentOffset);
      currentOffset += 2;
      while (numAnnotations-- > 0) {
        // Parse the type_index field.
        String annotationDescriptor = readUTF8(currentOffset, charBuffer);
        currentOffset += 2;
        // Parse num_element_value_pairs and element_value_pairs and visit these values.
        currentOffset =
            readElementValues(
                methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible),
                currentOffset,
                /* named= */ true,
                charBuffer);
      }
    }
  }

  /**
   * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit
   * them. This method can also be used to read the values of the JVMS 'array_value' field of an
   * annotation's 'element_value'.
   *
   * @param annotationVisitor the visitor that must visit the values.
   * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index
   *     field) or of an 'array_value' structure.
   * @param named if the annotation values are named or not. This should be true to parse the values
   *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an
   *     annotation's element_value.
   * @param charBuffer the buffer used to read strings in the constant pool.
   * @return the end offset of the JVMS 'annotation' or 'array_value' structure.
   */
  private int readElementValues(
      final AnnotationVisitor annotationVisitor,
      final int annotationOffset,
      final boolean named,
      final char[] charBuffer) {
    int currentOffset = annotationOffset;
    // Read the num_element_value_pairs field (or num_values field for an array_value).
    int numElementValuePairs = readUnsignedShort(currentOffset);
    currentOffset += 2;
    if (named) {
      // Parse the element_value_pairs array.
      while (numElementValuePairs-- > 0) {
        String elementName = readUTF8(currentOffset, charBuffer);
        currentOffset =
            readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);
      }
    } else {
      // Parse the array_value array.
      while (numElementValuePairs-- > 0) {
        currentOffset =
            readElementValue(annotationVisitor, currentOffset, /* elementName= */ null, charBuffer);
      }
    }
    if (annotationVisitor != null) {
      annotationVisitor.visitEnd();
    }
    return currentOffset;
  }

  /**
   * Reads a JVMS 'element_value' structure and makes the given visitor visit it.
   *
   * @param annotationVisitor the visitor that must visit the element_value structure.
   * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value
   *     structure to be read.
   * @param elementName the name of the element_value structure to be read, or {@literal null}.
   * @param charBuffer the buffer used to read strings in the constant pool.
   * @return the end offset of the JVMS 'element_value' structure.
   */
  private int readElementValue(
      final AnnotationVisitor annotationVisitor,
      final int elementValueOffset,
      final String elementName,
      final char[] charBuffer) {
    int currentOffset = elementValueOffset;
    if (annotationVisitor == null) {
      switch (classFileBuffer[currentOffset] & 0xFF) {
        case 'e': // enum_const_value
          return currentOffset + 5;
        case '@': // annotation_value
          return readElementValues(null, currentOffset + 3, /* named= */ true, charBuffer);
        case '[': // array_value
          return readElementValues(null, currentOffset + 1, /* named= */ false, charBuffer);
        default:
          return currentOffset + 3;
      }
    }
    switch (classFileBuffer[currentOffset++] & 0xFF) {
      case 'B': // const_value_index, CONSTANT_Integer
        annotationVisitor.visit(
            elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
        currentOffset += 2;
        break;
      case 'C': // const_value_index, CONSTANT_Integer
        annotationVisitor.visit(
            elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
        currentOffset += 2;
        break;
      case 'D': // const_value_index, CONSTANT_Double
      case 'F': // const_value_index, CONSTANT_Float
      case 'I': // const_value_index, CONSTANT_Integer
      case 'J': // const_value_index, CONSTANT_Long
        annotationVisitor.visit(
            elementName, readConst(readUnsignedShort(currentOffset), charBuffer));
        currentOffset += 2;
        break;
      case 'S': // const_value_index, CONSTANT_Integer
        annotationVisitor.visit(
            elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
        currentOffset += 2;
        break;

      case 'Z': // const_value_index, CONSTANT_Integer
        annotationVisitor.visit(
            elementName,
            readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0
                ? Boolean.FALSE
                : Boolean.TRUE);
        currentOffset += 2;
        break;
      case 's': // const_value_index, CONSTANT_Utf8
        annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));
        currentOffset += 2;
        break;
      case 'e': // enum_const_value
        annotationVisitor.visitEnum(
            elementName,
            readUTF8(currentOffset, charBuffer),
            readUTF8(currentOffset + 2, charBuffer));
        currentOffset += 4;
        break;
      case 'c': // class_info
        annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));
        currentOffset += 2;
        break;
      case '@': // annotation_value
        currentOffset =
            readElementValues(
                annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)),
                currentOffset + 2,
                true,
                charBuffer);
        break;
      case '[': // array_value
        int numValues = readUnsignedShort(currentOffset);
        currentOffset += 2;
        if (numValues == 0) {
          return readElementValues(
              annotationVisitor.visitArray(elementName),
              currentOffset - 2,
              /* named= */ false,
              charBuffer);
        }
        switch (classFileBuffer[currentOffset] & 0xFF) {
          case 'B':
            byte[] byteValues = new byte[numValues];
            for (int i = 0; i < numValues; i++) {
              byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
              currentOffset += 3;
            }
            annotationVisitor.visit(elementName, byteValues);
            break;
          case 'Z':
            boolean[] booleanValues = new boolean[numValues];
            for (int i = 0; i < numValues; i++) {
              booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;
              currentOffset += 3;
            }
            annotationVisitor.visit(elementName, booleanValues);
            break;
          case 'S':
            short[] shortValues = new short[numValues];
            for (int i = 0; i < numValues; i++) {
              shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
              currentOffset += 3;
            }
            annotationVisitor.visit(elementName, shortValues);
            break;
          case 'C':
            char[] charValues = new char[numValues];
            for (int i = 0; i < numValues; i++) {
              charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
              currentOffset += 3;
            }
            annotationVisitor.visit(elementName, charValues);
            break;
          case 'I':
            int[] intValues = new int[numValues];
            for (int i = 0; i < numValues; i++) {
              intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
              currentOffset += 3;
            }
            annotationVisitor.visit(elementName, intValues);
            break;
          case 'J':
            long[] longValues = new long[numValues];
            for (int i = 0; i < numValues; i++) {
              longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
              currentOffset += 3;
            }
            annotationVisitor.visit(elementName, longValues);
            break;
          case 'F':
            float[] floatValues = new float[numValues];
            for (int i = 0; i < numValues; i++) {
              floatValues[i] =
                  Float.intBitsToFloat(
                      readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));
              currentOffset += 3;
            }
            annotationVisitor.visit(elementName, floatValues);
            break;
          case 'D':
            double[] doubleValues = new double[numValues];
            for (int i = 0; i < numValues; i++) {
              doubleValues[i] =
                  Double.longBitsToDouble(
                      readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));
              currentOffset += 3;
            }
            annotationVisitor.visit(elementName, doubleValues);
            break;
          default:
            currentOffset =
                readElementValues(
                    annotationVisitor.visitArray(elementName),
                    currentOffset - 2,
                    /* named= */ false,
                    charBuffer);
            break;
        }
        break;
      default:
        throw new IllegalArgumentException();
    }
    return currentOffset;
  }

  // ----------------------------------------------------------------------------------------------
  // Methods to parse stack map frames
  // ----------------------------------------------------------------------------------------------

  /**
   * Computes the implicit frame of the method currently being parsed (as defined in the given
   * {@link Context}) and stores it in the given context.
   *
   * @param context information about the class being parsed.
   */
  private void computeImplicitFrame(final Context context) {
    String methodDescriptor = context.currentMethodDescriptor;
    Object[] locals = context.currentFrameLocalTypes;
    int numLocal = 0;
    if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {
      if ("<init>".equals(context.currentMethodName)) {
        locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;
      } else {
        locals[numLocal++] = readClass(header + 2, context.charBuffer);
      }
    }
    // Parse the method descriptor, one argument type descriptor at each iteration. Start by
    // skipping the first method descriptor character, which is always '('.
    int currentMethodDescritorOffset = 1;
    while (true) {
      int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;
      switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {
        case 'Z':
        case 'C':
        case 'B':
        case 'S':
        case 'I':
          locals[numLocal++] = Opcodes.INTEGER;
          break;
        case 'F':
          locals[numLocal++] = Opcodes.FLOAT;
          break;
        case 'J':
          locals[numLocal++] = Opcodes.LONG;
          break;
        case 'D':
          locals[numLocal++] = Opcodes.DOUBLE;
          break;
        case '[':
          while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {
            ++currentMethodDescritorOffset;
          }
          if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {
            ++currentMethodDescritorOffset;
            while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {
              ++currentMethodDescritorOffset;
            }
          }
          locals[numLocal++] =
              methodDescriptor.substring(
                  currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);
          break;
        case 'L':
          while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {
            ++currentMethodDescritorOffset;
          }
          locals[numLocal++] =
              methodDescriptor.substring(
                  currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);
          break;
        default:
          context.currentFrameLocalCount = numLocal;
          return;
      }
    }
  }

  /**
   * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}
   * object. This method can also be used to read a full_frame structure, excluding its frame_type
   * field (this is used to parse the legacy StackMap attributes).
   *
   * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the
   *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure
   *     (excluding its frame_type field).
   * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'
   *     structure without its frame_type field.
   * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
   * @param context where the parsed stack map frame must be stored.
   * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.
   */
  private int readStackMapFrame(
      final int stackMapFrameOffset,
      final boolean compressed,
      final boolean expand,
      final Context context) {
    int currentOffset = stackMapFrameOffset;
    final char[] charBuffer = context.charBuffer;
    final Label[] labels = context.currentMethodLabels;
    int frameType;
    if (compressed) {
      // Read the frame_type field.
      frameType = classFileBuffer[currentOffset++] & 0xFF;
    } else {
      frameType = Frame.FULL_FRAME;
      context.currentFrameOffset = -1;
    }
    int offsetDelta;
    context.currentFrameLocalCountDelta = 0;
    if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {
      offsetDelta = frameType;
      context.currentFrameType = Opcodes.F_SAME;
      context.currentFrameStackCount = 0;
    } else if (frameType < Frame.RESERVED) {
      offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;
      currentOffset =
          readVerificationTypeInfo(
              currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
      context.currentFrameType = Opcodes.F_SAME1;
      context.currentFrameStackCount = 1;
    } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
      offsetDelta = readUnsignedShort(currentOffset);
      currentOffset += 2;
      if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
        currentOffset =
            readVerificationTypeInfo(
                currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
        context.currentFrameType = Opcodes.F_SAME1;
        context.currentFrameStackCount = 1;
      } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {
        context.currentFrameType = Opcodes.F_CHOP;
        context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;
        context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;
        context.currentFrameStackCount = 0;
      } else if (frameType == Frame.SAME_FRAME_EXTENDED) {
        context.currentFrameType = Opcodes.F_SAME;
        context.currentFrameStackCount = 0;
      } else if (frameType < Frame.FULL_FRAME) {
        int local = expand ? context.currentFrameLocalCount : 0;
        for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {
          currentOffset =
              readVerificationTypeInfo(
                  currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);
        }
        context.currentFrameType = Opcodes.F_APPEND;
        context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;
        context.currentFrameLocalCount += context.currentFrameLocalCountDelta;
        context.currentFrameStackCount = 0;
      } else {
        final int numberOfLocals = readUnsignedShort(currentOffset);
        currentOffset += 2;
        context.currentFrameType = Opcodes.F_FULL;
        context.currentFrameLocalCountDelta = numberOfLocals;
        context.currentFrameLocalCount = numberOfLocals;
        for (int local = 0; local < numberOfLocals; ++local) {
          currentOffset =
              readVerificationTypeInfo(
                  currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);
        }
        final int numberOfStackItems = readUnsignedShort(currentOffset);
        currentOffset += 2;
        context.currentFrameStackCount = numberOfStackItems;
        for (int stack = 0; stack < numberOfStackItems; ++stack) {
          currentOffset =
              readVerificationTypeInfo(
                  currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);
        }
      }
    } else {
      throw new IllegalArgumentException();
    }
    context.currentFrameOffset += offsetDelta + 1;
    createLabel(context.currentFrameOffset, labels);
    return currentOffset;
  }

  /**
   * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given
   * array.
   *
   * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to
   *     read.
   * @param frame the array where the parsed type must be stored.
   * @param index the index in 'frame' where the parsed type must be stored.
   * @param charBuffer the buffer used to read strings in the constant pool.
   * @param labels the labels of the method currently being parsed, indexed by their offset. If the
   *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is
   *     stored in this array if it does not already exist.
   * @return the end offset of the JVMS 'verification_type_info' structure.
   */
  private int readVerificationTypeInfo(
      final int verificationTypeInfoOffset,
      final Object[] frame,
      final int index,
      final char[] charBuffer,
      final Label[] labels) {
    int currentOffset = verificationTypeInfoOffset;
    int tag = classFileBuffer[currentOffset++] & 0xFF;
    switch (tag) {
      case Frame.ITEM_TOP:
        frame[index] = Opcodes.TOP;
        break;
      case Frame.ITEM_INTEGER:
        frame[index] = Opcodes.INTEGER;
        break;
      case Frame.ITEM_FLOAT:
        frame[index] = Opcodes.FLOAT;
        break;
      case Frame.ITEM_DOUBLE:
        frame[index] = Opcodes.DOUBLE;
        break;
      case Frame.ITEM_LONG:
        frame[index] = Opcodes.LONG;
        break;
      case Frame.ITEM_NULL:
        frame[index] = Opcodes.NULL;
        break;
      case Frame.ITEM_UNINITIALIZED_THIS:
        frame[index] = Opcodes.UNINITIALIZED_THIS;
        break;
      case Frame.ITEM_OBJECT:
        frame[index] = readClass(currentOffset, charBuffer);
        currentOffset += 2;
        break;
      case Frame.ITEM_UNINITIALIZED:
        frame[index] = createLabel(readUnsignedShort(currentOffset), labels);
        currentOffset += 2;
        break;
      default:
        throw new IllegalArgumentException();
    }
    return currentOffset;
  }

  // ----------------------------------------------------------------------------------------------
  // Methods to parse attributes
  // ----------------------------------------------------------------------------------------------

  /**
   * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array
   * field entry.
   *
   * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array
   *     field entry.
   */
  final int getFirstAttributeOffset() {
    // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
    // each), as well as the interfaces array field (2 bytes per interface).
    int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;

    // Read the fields_count field.
    int fieldsCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    // Skip the 'fields' array field.
    while (fieldsCount-- > 0) {
      // Invariant: currentOffset is the offset of a field_info structure.
      // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the
      // attributes_count field.
      int attributesCount = readUnsignedShort(currentOffset + 6);
      currentOffset += 8;
      // Skip the 'attributes' array field.
      while (attributesCount-- > 0) {
        // Invariant: currentOffset is the offset of an attribute_info structure.
        // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip
        // this many bytes, plus 6 for the attribute_name_index and attribute_length fields
        // (yielding the total size of the attribute_info structure).
        currentOffset += 6 + readInt(currentOffset + 2);
      }
    }

    // Skip the methods_count and 'methods' fields, using the same method as above.
    int methodsCount = readUnsignedShort(currentOffset);
    currentOffset += 2;
    while (methodsCount-- > 0) {
      int attributesCount = readUnsignedShort(currentOffset + 6);
      currentOffset += 8;
      while (attributesCount-- > 0) {
        currentOffset += 6 + readInt(currentOffset + 2);
      }
    }

    // Skip the ClassFile's attributes_count field.
    return currentOffset + 2;
  }

  /**
   * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
   *
   * @param maxStringLength a conservative estimate of the maximum length of the strings contained
   *     in the constant pool of the class.
   * @return the offsets of the bootstrap methods.
   */
  private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
    char[] charBuffer = new char[maxStringLength];
    int currentAttributeOffset = getFirstAttributeOffset();
    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {
      // Read the attribute_info's attribute_name and attribute_length fields.
      String attributeName = readUTF8(currentAttributeOffset, charBuffer);
      int attributeLength = readInt(currentAttributeOffset + 2);
      currentAttributeOffset += 6;
      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
        // Read the num_bootstrap_methods field and create an array of this size.
        int[] result = new int[readUnsignedShort(currentAttributeOffset)];
        // Compute and store the offset of each 'bootstrap_methods' array field entry.
        int currentBootstrapMethodOffset = currentAttributeOffset + 2;
        for (int j = 0; j < result.length; ++j) {
          result[j] = currentBootstrapMethodOffset;
          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),
          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).
          currentBootstrapMethodOffset +=
              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;
        }
        return result;
      }
      currentAttributeOffset += attributeLength;
    }
    throw new IllegalArgumentException();
  }

  /**
   * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.
   *
   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
   *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
   * @param type the type of the attribute.
   * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.
   *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).
   * @param charBuffer the buffer to be used to read strings in the constant pool.
   * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link
   *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6
   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read
   *     is not a code attribute.
   * @return the attribute that has been read.
   */
  private Attribute readAttribute(
      final Attribute[] attributePrototypes,
      final String type,
      final int offset,
      final int length,
      final char[] charBuffer,
      final int codeAttributeOffset,
      final Label[] labels) {
    for (Attribute attributePrototype : attributePrototypes) {
      if (attributePrototype.type.equals(type)) {
        return attributePrototype.read(
            this, offset, length, charBuffer, codeAttributeOffset, labels);
      }
    }
    return new Attribute(type).read(this, offset, length, null, -1, null);
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods: low level parsing
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the number of entries in the class's constant pool table.
   *
   * @return the number of entries in the class's constant pool table.
   */
  public int getItemCount() {
    return cpInfoOffsets.length;
  }

  /**
   * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a
   * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,
   * and is normally not needed by class generators or adapters.</i>
   *
   * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool
   *     table.
   * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'
   *     structure, plus one.
   */
  public int getItem(final int constantPoolEntryIndex) {
    return cpInfoOffsets[constantPoolEntryIndex];
  }

  /**
   * Returns a conservative estimate of the maximum length of the strings contained in the class's
   * constant pool table.
   *
   * @return a conservative estimate of the maximum length of the strings contained in the class's
   *     constant pool table.
   */
  public int getMaxStringLength() {
    return maxStringLength;
  }

  /**
   * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param offset the start offset of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public int readByte(final int offset) {
    return classFileBuffer[offset] & 0xFF;
  }

  /**
   * Reads several bytes in this {@link ClassReader}. <i>This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param offset the start offset of the bytes to be read in this {@link ClassReader}.
   * @param length the number of bytes to read.
   * @return the read bytes.
   */
  public byte[] readBytes(final int offset, final int length) {
    byte[] result = new byte[length];
    System.arraycopy(classFileBuffer, offset, result, 0, length);
    return result;
  }

  /**
   * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for
   * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param offset the start index of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public int readUnsignedShort(final int offset) {
    byte[] classBuffer = classFileBuffer;
    return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);
  }

  /**
   * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param offset the start offset of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public short readShort(final int offset) {
    byte[] classBuffer = classFileBuffer;
    return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));
  }

  /**
   * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param offset the start offset of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public int readInt(final int offset) {
    byte[] classBuffer = classFileBuffer;
    return ((classBuffer[offset] & 0xFF) << 24)
        | ((classBuffer[offset + 1] & 0xFF) << 16)
        | ((classBuffer[offset + 2] & 0xFF) << 8)
        | (classBuffer[offset + 3] & 0xFF);
  }

  /**
   * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param offset the start offset of the value to be read in this {@link ClassReader}.
   * @return the read value.
   */
  public long readLong(final int offset) {
    long l1 = readInt(offset);
    long l0 = readInt(offset + 4) & 0xFFFFFFFFL;
    return (l1 << 32) | l0;
  }

  /**
   * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.</i>
   *
   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
   *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.
   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Utf8 entry.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  public String readUTF8(final int offset, final char[] charBuffer) {
    int constantPoolEntryIndex = readUnsignedShort(offset);
    if (offset == 0 || constantPoolEntryIndex == 0) {
      return null;
    }
    return readUtf(constantPoolEntryIndex, charBuffer);
  }

  /**
   * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.
   *
   * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool
   *     table.
   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Utf8 entry.
   */
  final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {
    String value = constantUtf8Values[constantPoolEntryIndex];
    if (value != null) {
      return value;
    }
    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
    return constantUtf8Values[constantPoolEntryIndex] =
        readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);
  }

  /**
   * Reads an UTF8 string in {@link #classFileBuffer}.
   *
   * @param utfOffset the start offset of the UTF8 string to be read.
   * @param utfLength the length of the UTF8 string to be read.
   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified UTF8 string.
   */
  private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
    int currentOffset = utfOffset;
    int endOffset = currentOffset + utfLength;
    int strLength = 0;
    byte[] classBuffer = classFileBuffer;
    while (currentOffset < endOffset) {
      int currentByte = classBuffer[currentOffset++];
      if ((currentByte & 0x80) == 0) {
        charBuffer[strLength++] = (char) (currentByte & 0x7F);
      } else if ((currentByte & 0xE0) == 0xC0) {
        charBuffer[strLength++] =
            (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));
      } else {
        charBuffer[strLength++] =
            (char)
                (((currentByte & 0xF) << 12)
                    + ((classBuffer[currentOffset++] & 0x3F) << 6)
                    + (classBuffer[currentOffset++] & 0x3F));
      }
    }
    return new String(charBuffer, 0, strLength);
  }

  /**
   * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
   * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended
   * for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.</i>
   *
   * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose
   *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
   *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.
   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified constant pool entry.
   */
  private String readStringish(final int offset, final char[] charBuffer) {
    // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry
    // designated by the first two bytes of this cp_info.
    return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);
  }

  /**
   * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.</i>
   *
   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
   *     value is the index of a CONSTANT_Class entry in class's constant pool table.
   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Class entry.
   */
  public String readClass(final int offset, final char[] charBuffer) {
    return readStringish(offset, charBuffer);
  }

  /**
   * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.</i>
   *
   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
   *     value is the index of a CONSTANT_Module entry in class's constant pool table.
   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Module entry.
   */
  public String readModule(final int offset, final char[] charBuffer) {
    return readStringish(offset, charBuffer);
  }

  /**
   * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.</i>
   *
   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
   *     value is the index of a CONSTANT_Package entry in class's constant pool table.
   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the String corresponding to the specified CONSTANT_Package entry.
   */
  public String readPackage(final int offset, final char[] charBuffer) {
    return readStringish(offset, charBuffer);
  }

  /**
   * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.
   *
   * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant
   *     pool table.
   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.
   */
  private ConstantDynamic readConstantDynamic(
      final int constantPoolEntryIndex, final char[] charBuffer) {
    ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];
    if (constantDynamic != null) {
      return constantDynamic;
    }
    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];
    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];
    bootstrapMethodOffset += 4;
    for (int i = 0; i < bootstrapMethodArguments.length; i++) {
      bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
      bootstrapMethodOffset += 2;
    }
    return constantDynamicValues[constantPoolEntryIndex] =
        new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
  }

  /**
   * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is
   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
   * adapters.</i>
   *
   * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
   *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
   *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.
   * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
   *     large. It is not automatically resized.
   * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},
   *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
   *     constant pool entry.
   */
  public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
    switch (classFileBuffer[cpInfoOffset - 1]) {
      case Symbol.CONSTANT_INTEGER_TAG:
        return readInt(cpInfoOffset);
      case Symbol.CONSTANT_FLOAT_TAG:
        return Float.intBitsToFloat(readInt(cpInfoOffset));
      case Symbol.CONSTANT_LONG_TAG:
        return readLong(cpInfoOffset);
      case Symbol.CONSTANT_DOUBLE_TAG:
        return Double.longBitsToDouble(readLong(cpInfoOffset));
      case Symbol.CONSTANT_CLASS_TAG:
        return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));
      case Symbol.CONSTANT_STRING_TAG:
        return readUTF8(cpInfoOffset, charBuffer);
      case Symbol.CONSTANT_METHOD_TYPE_TAG:
        return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));
      case Symbol.CONSTANT_METHOD_HANDLE_TAG:
        int referenceKind = readByte(cpInfoOffset);
        int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];
        int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];
        String owner = readClass(referenceCpInfoOffset, charBuffer);
        String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
        String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
        boolean isInterface =
            classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
        return new Handle(referenceKind, owner, name, descriptor, isInterface);
      case Symbol.CONSTANT_DYNAMIC_TAG:
        return readConstantDynamic(constantPoolEntryIndex, charBuffer);
      default:
        throw new IllegalArgumentException();
    }
  }
}

package org.objectweb.asm;

/**
 * A visitor to visit a Java module. The methods of this class must be called in the following
 * order: ( {@code visitMainClass} | ( {@code visitPackage} | {@code visitRequire} | {@code
 * visitExport} | {@code visitOpen} | {@code visitUse} | {@code visitProvide} )* ) {@code visitEnd}.
 *
 * @author Remi Forax
 * @author Eric Bruneton
 */
public abstract class ModuleVisitor {
  /**
   * The ASM API version implemented by this visitor. The value of this field must be one of {@link
   * Opcodes#ASM6} or {@link Opcodes#ASM7}.
   */
  protected final int api;

  /**
   * The module visitor to which this visitor must delegate method calls. May be {@literal null}.
   */
  protected ModuleVisitor mv;

  /**
   * Constructs a new {@link ModuleVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM6}
   *     or {@link Opcodes#ASM7}.
   */
  protected ModuleVisitor(final int api) {
    this(api, null);
  }

  /**
   * Constructs a new {@link ModuleVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM6}
   *     or {@link Opcodes#ASM7}.
   * @param moduleVisitor the module visitor to which this visitor must delegate method calls. May
   *     be null.
   */
  protected ModuleVisitor(final int api, final ModuleVisitor moduleVisitor) {
    if (api != Opcodes.ASM9
        && api != Opcodes.ASM8
        && api != Opcodes.ASM7
        && api != Opcodes.ASM6
        && api != Opcodes.ASM5
        && api != Opcodes.ASM4
        && api != Opcodes.ASM10_EXPERIMENTAL) {
      throw new IllegalArgumentException("Unsupported api " + api);
    }
    if (api == Opcodes.ASM10_EXPERIMENTAL) {
      Constants.checkAsmExperimental(this);
    }
    this.api = api;
    this.mv = moduleVisitor;
  }

  /**
   * The module visitor to which this visitor must delegate method calls. May be {@literal null}.
   *
   * @return the module visitor to which this visitor must delegate method calls, or {@literal
   *     null}.
   */
  public ModuleVisitor getDelegate() {
    return mv;
  }

  /**
   * Visit the main class of the current module.
   *
   * @param mainClass the internal name of the main class of the current module (see {@link
   *     Type#getInternalName()}).
   */
  public void visitMainClass(final @InternalForm String mainClass) {
    if (mv != null) {
      mv.visitMainClass(mainClass);
    }
  }

  /**
   * Visit a package of the current module.
   *
   * @param packaze the internal name of a package (see {@link Type#getInternalName()}).
   */
  public void visitPackage(final String packaze) {
    if (mv != null) {
      mv.visitPackage(packaze);
    }
  }

  /**
   * Visits a dependence of the current module.
   *
   * @param module the fully qualified name (using dots) of the dependence.
   * @param access the access flag of the dependence among {@code ACC_TRANSITIVE}, {@code
   *     ACC_STATIC_PHASE}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   * @param version the module version at compile time, or {@literal null}.
   */
  public void visitRequire(final String module, final int access, final String version) {
    if (mv != null) {
      mv.visitRequire(module, access, version);
    }
  }

  /**
   * Visit an exported package of the current module.
   *
   * @param packaze the internal name of the exported package (see {@link Type#getInternalName()}).
   * @param access the access flag of the exported package, valid values are among {@code
   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   * @param modules the fully qualified names (using dots) of the modules that can access the public
   *     classes of the exported package, or {@literal null}.
   */
  public void visitExport(final String packaze, final int access, final String... modules) {
    if (mv != null) {
      mv.visitExport(packaze, access, modules);
    }
  }

  /**
   * Visit an open package of the current module.
   *
   * @param packaze the internal name of the opened package (see {@link Type#getInternalName()}).
   * @param access the access flag of the opened package, valid values are among {@code
   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   * @param modules the fully qualified names (using dots) of the modules that can use deep
   *     reflection to the classes of the open package, or {@literal null}.
   */
  public void visitOpen(final String packaze, final int access, final String... modules) {
    if (mv != null) {
      mv.visitOpen(packaze, access, modules);
    }
  }

  /**
   * Visit a service used by the current module. The name must be the internal name of an interface
   * or a class.
   *
   * @param service the internal name of the service (see {@link Type#getInternalName()}).
   */
  public void visitUse(final @InternalForm String service) {
    if (mv != null) {
      mv.visitUse(service);
    }
  }

  /**
   * Visit an implementation of a service.
   *
   * @param service the internal name of the service (see {@link Type#getInternalName()}).
   * @param providers the internal names (see {@link Type#getInternalName()}) of the implementations
   *     of the service (there is at least one provider).
   */
  public void visitProvide(final @InternalForm String service, final String... providers) {
    if (mv != null) {
      mv.visitProvide(service, providers);
    }
  }

  /**
   * Visits the end of the module. This method, which is the last one to be called, is used to
   * inform the visitor that everything have been visited.
   */
  public void visitEnd() {
    if (mv != null) {
      mv.visitEnd();
    }
  }
}

package org.objectweb.asm;

/**
 * A non standard class, field, method or Code attribute, as defined in the Java Virtual Machine
 * Specification (JVMS).
 *
 * @see <a href= "https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7">JVMS
 *     4.7</a>
 * @see <a href= "https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3">JVMS
 *     4.7.3</a>
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
public class Attribute {

  /** The type of this attribute, also called its name in the JVMS. */
  public final String type;

  /**
   * The raw content of this attribute, as returned by {@link
   * #write(ClassWriter,byte[],int,int,int)}. The 6 header bytes of the attribute
   * (attribute_name_index and attribute_length) are <i>not</i> included.
   */
  private ByteVector cachedContent;

  /**
   * The next attribute in this attribute list (Attribute instances can be linked via this field to
   * store a list of class, field, method or Code attributes). May be {@literal null}.
   */
  Attribute nextAttribute;

  /**
   * Constructs a new empty attribute.
   *
   * @param type the type of the attribute.
   */
  protected Attribute(final String type) {
    this.type = type;
  }

  /**
   * Returns {@literal true} if this type of attribute is unknown. This means that the attribute
   * content can't be parsed to extract constant pool references, labels, etc. Instead, the
   * attribute content is read as an opaque byte array, and written back as is. This can lead to
   * invalid attributes, if the content actually contains constant pool references, labels, or other
   * symbolic references that need to be updated when there are changes to the constant pool, the
   * method bytecode, etc. The default implementation of this method always returns {@literal true}.
   *
   * @return {@literal true} if this type of attribute is unknown.
   */
  public boolean isUnknown() {
    return true;
  }

  /**
   * Returns {@literal true} if this type of attribute is a Code attribute.
   *
   * @return {@literal true} if this type of attribute is a Code attribute.
   */
  public boolean isCodeAttribute() {
    return false;
  }

  /**
   * Returns the labels corresponding to this attribute.
   *
   * @return the labels corresponding to this attribute, or {@literal null} if this attribute is not
   *     a Code attribute that contains labels.
   * @deprecated no longer used by ASM.
   */
  @Deprecated
  protected Label[] getLabels() {
    return new Label[0];
  }

  /**
   * Reads a {@link #type} attribute. This method must return a <i>new</i> {@link Attribute} object,
   * of type {@link #type}, corresponding to the 'length' bytes starting at 'offset', in the given
   * ClassReader.
   *
   * @param classReader the class that contains the attribute to be read.
   * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6
   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).
   * @param charBuffer the buffer to be used to call the ClassReader methods requiring a
   *     'charBuffer' parameter.
   * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute
   *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6
   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read
   *     is not a Code attribute. Labels defined in the attribute must be created and added to this
   *     array, if not already present, by calling the {@link #readLabel} method (do not create
   *     {@link Label} instances directly).
   * @return a <i>new</i> {@link Attribute} object corresponding to the specified bytes.
   */
  protected Attribute read(
      final ClassReader classReader,
      final int offset,
      final int length,
      final char[] charBuffer,
      final int codeAttributeOffset,
      final Label[] labels) {
    Attribute attribute = new Attribute(type);
    attribute.cachedContent = new ByteVector(classReader.readBytes(offset, length));
    return attribute;
  }

  /**
   * Reads an attribute with the same {@link #type} as the given attribute. This method returns a
   * new {@link Attribute} object, corresponding to the 'length' bytes starting at 'offset', in the
   * given ClassReader.
   *
   * @param attribute The attribute prototype that is used for reading.
   * @param classReader the class that contains the attribute to be read.
   * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6
   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).
   * @param charBuffer the buffer to be used to call the ClassReader methods requiring a
   *     'charBuffer' parameter.
   * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute
   *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6
   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
   *     account here.
   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read
   *     is not a Code attribute. Labels defined in the attribute are added to this array, if not
   *     already present.
   * @return a new {@link Attribute} object corresponding to the specified bytes.
   */
  public static Attribute read(
      final Attribute attribute,
      final ClassReader classReader,
      final int offset,
      final int length,
      final char[] charBuffer,
      final int codeAttributeOffset,
      final Label[] labels) {
    return attribute.read(classReader, offset, length, charBuffer, codeAttributeOffset, labels);
  }

  /**
   * Returns the label corresponding to the given bytecode offset by calling {@link
   * ClassReader#readLabel}. This creates and adds the label to the given array if it is not already
   * present. Note that this created label may be a {@link Label} subclass instance, if the given
   * ClassReader overrides {@link ClassReader#readLabel}. Hence {@link #read(ClassReader, int, int,
   * char[], int, Label[])} must not manually create {@link Label} instances.
   *
   * @param bytecodeOffset a bytecode offset in a method.
   * @param labels the already created labels, indexed by their offset. If a label already exists
   *     for bytecodeOffset this method does not create a new one. Otherwise it stores the new label
   *     in this array.
   * @return a label for the given bytecode offset.
   */
  public static Label readLabel(
      final ClassReader classReader, final int bytecodeOffset, final Label[] labels) {
    return classReader.readLabel(bytecodeOffset, labels);
  }

  /**
   * Calls {@link #write(ClassWriter,byte[],int,int,int)} if it has not already been called and
   * returns its result or its (cached) previous result.
   *
   * @param classWriter the class to which this attribute must be added. This parameter can be used
   *     to add the items that corresponds to this attribute to the constant pool of this class.
   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}
   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code
   *     attribute.
   * @param codeLength the length of the bytecode of the method corresponding to this code
   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'
   *     field of the Code attribute.
   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or
   *     -1 if this attribute is not a Code attribute.
   * @param maxLocals the maximum number of local variables of the method corresponding to this code
   *     attribute, or -1 if this attribute is not a Code attribute.
   * @return the byte array form of this attribute.
   */
  private ByteVector maybeWrite(
      final ClassWriter classWriter,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    if (cachedContent == null) {
      cachedContent = write(classWriter, code, codeLength, maxStack, maxLocals);
    }
    return cachedContent;
  }

  /**
   * Returns the byte array form of the content of this attribute. The 6 header bytes
   * (attribute_name_index and attribute_length) must <i>not</i> be added in the returned
   * ByteVector.
   *
   * <p>This method is only invoked once to compute the binary form of this attribute. Subsequent
   * changes to the attribute after it was written for the first time will not be considered.
   *
   * @param classWriter the class to which this attribute must be added. This parameter can be used
   *     to add the items that corresponds to this attribute to the constant pool of this class.
   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}
   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code
   *     attribute.
   * @param codeLength the length of the bytecode of the method corresponding to this code
   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'
   *     field of the Code attribute.
   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or
   *     -1 if this attribute is not a Code attribute.
   * @param maxLocals the maximum number of local variables of the method corresponding to this code
   *     attribute, or -1 if this attribute is not a Code attribute.
   * @return the byte array form of this attribute.
   */
  protected ByteVector write(
      final ClassWriter classWriter,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    return cachedContent;
  }

  /**
   * Returns the byte array form of the content of the given attribute. The 6 header bytes
   * (attribute_name_index and attribute_length) are <i>not</i> added in the returned byte array.
   *
   * @param attribute The attribute that should be written.
   * @param classWriter the class to which this attribute must be added. This parameter can be used
   *     to add the items that corresponds to this attribute to the constant pool of this class.
   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}
   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code
   *     attribute.
   * @param codeLength the length of the bytecode of the method corresponding to this code
   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'
   *     field of the Code attribute.
   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or
   *     -1 if this attribute is not a Code attribute.
   * @param maxLocals the maximum number of local variables of the method corresponding to this code
   *     attribute, or -1 if this attribute is not a Code attribute.
   * @return the byte array form of this attribute.
   */
  public static byte[] write(
      final Attribute attribute,
      final ClassWriter classWriter,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    ByteVector content = attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals);
    byte[] result = new byte[content.length];
    System.arraycopy(content.data, 0, result, 0, content.length);
    return result;
  }

  /**
   * Returns the number of attributes of the attribute list that begins with this attribute.
   *
   * @return the number of attributes of the attribute list that begins with this attribute.
   */
  final int getAttributeCount() {
    int count = 0;
    Attribute attribute = this;
    while (attribute != null) {
      count += 1;
      attribute = attribute.nextAttribute;
    }
    return count;
  }

  /**
   * Returns the total size in bytes of all the attributes in the attribute list that begins with
   * this attribute. This size includes the 6 header bytes (attribute_name_index and
   * attribute_length) per attribute. Also adds the attribute type names to the constant pool.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @return the size of all the attributes in this attribute list. This size includes the size of
   *     the attribute headers.
   */
  final int computeAttributesSize(final SymbolTable symbolTable) {
    final byte[] code = null;
    final int codeLength = 0;
    final int maxStack = -1;
    final int maxLocals = -1;
    return computeAttributesSize(symbolTable, code, codeLength, maxStack, maxLocals);
  }

  /**
   * Returns the total size in bytes of all the attributes in the attribute list that begins with
   * this attribute. This size includes the 6 header bytes (attribute_name_index and
   * attribute_length) per attribute. Also adds the attribute type names to the constant pool.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param code the bytecode of the method corresponding to these Code attributes, or {@literal
   *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code
   *     attribute.
   * @param codeLength the length of the bytecode of the method corresponding to these code
   *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of
   *     the Code attribute.
   * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or
   *     -1 if they are not Code attributes.
   * @param maxLocals the maximum number of local variables of the method corresponding to these
   *     Code attributes, or -1 if they are not Code attribute.
   * @return the size of all the attributes in this attribute list. This size includes the size of
   *     the attribute headers.
   */
  final int computeAttributesSize(
      final SymbolTable symbolTable,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    final ClassWriter classWriter = symbolTable.classWriter;
    int size = 0;
    Attribute attribute = this;
    while (attribute != null) {
      symbolTable.addConstantUtf8(attribute.type);
      size += 6 + attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals).length;
      attribute = attribute.nextAttribute;
    }
    return size;
  }

  /**
   * Returns the total size in bytes of all the attributes that correspond to the given field,
   * method or class access flags and signature. This size includes the 6 header bytes
   * (attribute_name_index and attribute_length) per attribute. Also adds the attribute type names
   * to the constant pool.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param accessFlags some field, method or class access flags.
   * @param signatureIndex the constant pool index of a field, method of class signature.
   * @return the size of all the attributes in bytes. This size includes the size of the attribute
   *     headers.
   */
  static int computeAttributesSize(
      final SymbolTable symbolTable, final int accessFlags, final int signatureIndex) {
    int size = 0;
    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0
        && symbolTable.getMajorVersion() < Opcodes.V1_5) {
      // Synthetic attributes always use 6 bytes.
      symbolTable.addConstantUtf8(Constants.SYNTHETIC);
      size += 6;
    }
    if (signatureIndex != 0) {
      // Signature attributes always use 8 bytes.
      symbolTable.addConstantUtf8(Constants.SIGNATURE);
      size += 8;
    }
    // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead.
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      // Deprecated attributes always use 6 bytes.
      symbolTable.addConstantUtf8(Constants.DEPRECATED);
      size += 6;
    }
    return size;
  }

  /**
   * Puts all the attributes of the attribute list that begins with this attribute, in the given
   * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per
   * attribute.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param output where the attributes must be written.
   */
  final void putAttributes(final SymbolTable symbolTable, final ByteVector output) {
    final byte[] code = null;
    final int codeLength = 0;
    final int maxStack = -1;
    final int maxLocals = -1;
    putAttributes(symbolTable, code, codeLength, maxStack, maxLocals, output);
  }

  /**
   * Puts all the attributes of the attribute list that begins with this attribute, in the given
   * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per
   * attribute.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param code the bytecode of the method corresponding to these Code attributes, or {@literal
   *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code
   *     attribute.
   * @param codeLength the length of the bytecode of the method corresponding to these code
   *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of
   *     the Code attribute.
   * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or
   *     -1 if they are not Code attributes.
   * @param maxLocals the maximum number of local variables of the method corresponding to these
   *     Code attributes, or -1 if they are not Code attribute.
   * @param output where the attributes must be written.
   */
  final void putAttributes(
      final SymbolTable symbolTable,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals,
      final ByteVector output) {
    final ClassWriter classWriter = symbolTable.classWriter;
    Attribute attribute = this;
    while (attribute != null) {
      ByteVector attributeContent =
          attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals);
      // Put attribute_name_index and attribute_length.
      output.putShort(symbolTable.addConstantUtf8(attribute.type)).putInt(attributeContent.length);
      output.putByteArray(attributeContent.data, 0, attributeContent.length);
      attribute = attribute.nextAttribute;
    }
  }

  /**
   * Puts all the attributes that correspond to the given field, method or class access flags and
   * signature, in the given byte vector. This includes the 6 header bytes (attribute_name_index and
   * attribute_length) per attribute.
   *
   * @param symbolTable where the constants used in the attributes must be stored.
   * @param accessFlags some field, method or class access flags.
   * @param signatureIndex the constant pool index of a field, method of class signature.
   * @param output where the attributes must be written.
   */
  static void putAttributes(
      final SymbolTable symbolTable,
      final int accessFlags,
      final int signatureIndex,
      final ByteVector output) {
    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0
        && symbolTable.getMajorVersion() < Opcodes.V1_5) {
      output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);
    }
    if (signatureIndex != 0) {
      output
          .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))
          .putInt(2)
          .putShort(signatureIndex);
    }
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);
    }
  }

  /** A set of attribute prototypes (attributes with the same type are considered equal). */
  static final class Set {

    private static final int SIZE_INCREMENT = 6;

    private int size;
    private Attribute[] data = new Attribute[SIZE_INCREMENT];

    void addAttributes(final Attribute attributeList) {
      Attribute attribute = attributeList;
      while (attribute != null) {
        if (!contains(attribute)) {
          add(attribute);
        }
        attribute = attribute.nextAttribute;
      }
    }

    Attribute[] toArray() {
      Attribute[] result = new Attribute[size];
      System.arraycopy(data, 0, result, 0, size);
      return result;
    }

    private boolean contains(final Attribute attribute) {
      for (int i = 0; i < size; ++i) {
        if (data[i].type.equals(attribute.type)) {
          return true;
        }
      }
      return false;
    }

    private void add(final Attribute attribute) {
      if (size >= data.length) {
        Attribute[] newData = new Attribute[data.length + SIZE_INCREMENT];
        System.arraycopy(data, 0, newData, 0, size);
        data = newData;
      }
      data[size++] = attribute;
    }
  }
}

package org.objectweb.asm;

/**
 * Exception thrown when the constant pool of a class produced by a {@link ClassWriter} is too
 * large.
 *
 * @author Jason Zaugg
 */
public final class ClassTooLargeException extends IndexOutOfBoundsException {
  private static final long serialVersionUID = 160715609518896765L;

  private final String className;
  private final int constantPoolCount;

  /**
   * Constructs a new {@link ClassTooLargeException}.
   *
   * @param className the internal name of the class (see {@link
   *     org.objectweb.asm.Type#getInternalName()}).
   * @param constantPoolCount the number of constant pool items of the class.
   */
  public ClassTooLargeException(final @InternalForm String className, final int constantPoolCount) {
    super("Class too large: " + className);
    this.className = className;
    this.constantPoolCount = constantPoolCount;
  }

  /**
   * Returns the internal name of the class (see {@link org.objectweb.asm.Type#getInternalName()}).
   *
   * @return the internal name of the class.
   */
  public @InternalForm String getClassName() {
    return className;
  }

  /**
   * Returns the number of constant pool items of the class.
   *
   * @return the number of constant pool items of the class.
   */
  public int getConstantPoolCount() {
    return constantPoolCount;
  }
}

package org.objectweb.asm;

/**
 * An edge in the control flow graph of a method. Each node of this graph is a basic block,
 * represented with the Label corresponding to its first instruction. Each edge goes from one node
 * to another, i.e. from one basic block to another (called the predecessor and successor blocks,
 * respectively). An edge corresponds either to a jump or ret instruction or to an exception
 * handler.
 *
 * @see Label
 * @author Eric Bruneton
 */
final class Edge {

  /**
   * A control flow graph edge corresponding to a jump or ret instruction. Only used with {@link
   * ClassWriter#COMPUTE_FRAMES}.
   */
  static final int JUMP = 0;

  /**
   * A control flow graph edge corresponding to an exception handler. Only used with {@link
   * ClassWriter#COMPUTE_MAXS}.
   */
  static final int EXCEPTION = 0x7FFFFFFF;

  /**
   * Information about this control flow graph edge.
   *
   * <ul>
   *   <li>If {@link ClassWriter#COMPUTE_MAXS} is used, this field contains either a stack size
   *       delta (for an edge corresponding to a jump instruction), or the value EXCEPTION (for an
   *       edge corresponding to an exception handler). The stack size delta is the stack size just
   *       after the jump instruction, minus the stack size at the beginning of the predecessor
   *       basic block, i.e. the one containing the jump instruction.
   *   <li>If {@link ClassWriter#COMPUTE_FRAMES} is used, this field contains either the value JUMP
   *       (for an edge corresponding to a jump instruction), or the index, in the {@link
   *       ClassWriter} type table, of the exception type that is handled (for an edge corresponding
   *       to an exception handler).
   * </ul>
   */
  final int info;

  /** The successor block of this control flow graph edge. */
  final Label successor;

  /**
   * The next edge in the list of outgoing edges of a basic block. See {@link Label#outgoingEdges}.
   */
  Edge nextEdge;

  /**
   * Constructs a new Edge.
   *
   * @param info see {@link #info}.
   * @param successor see {@link #successor}.
   * @param nextEdge see {@link #nextEdge}.
   */
  Edge(final int info, final Label successor, final Edge nextEdge) {
    this.info = info;
    this.successor = successor;
    this.nextEdge = nextEdge;
  }
}

package org.objectweb.asm;

/**
 * A position in the bytecode of a method. Labels are used for jump, goto, and switch instructions,
 * and for try catch blocks. A label designates the <i>instruction</i> that is just after. Note
 * however that there can be other elements between a label and the instruction it designates (such
 * as other labels, stack map frames, line numbers, etc.).
 *
 * @author Eric Bruneton
 */
public class Label {

  /**
   * A flag indicating that a label is only used for debug attributes. Such a label is not the start
   * of a basic block, the target of a jump instruction, or an exception handler. It can be safely
   * ignored in control flow graph analysis algorithms (for optimization purposes).
   */
  static final int FLAG_DEBUG_ONLY = 1;

  /**
   * A flag indicating that a label is the target of a jump instruction, or the start of an
   * exception handler.
   */
  static final int FLAG_JUMP_TARGET = 2;

  /** A flag indicating that the bytecode offset of a label is known. */
  static final int FLAG_RESOLVED = 4;

  /** A flag indicating that a label corresponds to a reachable basic block. */
  static final int FLAG_REACHABLE = 8;

  /**
   * A flag indicating that the basic block corresponding to a label ends with a subroutine call. By
   * construction in {@link MethodWriter#visitJumpInsn}, labels with this flag set have at least two
   * outgoing edges:
   *
   * <ul>
   *   <li>the first one corresponds to the instruction that follows the jsr instruction in the
   *       bytecode, i.e. where execution continues when it returns from the jsr call. This is a
   *       virtual control flow edge, since execution never goes directly from the jsr to the next
   *       instruction. Instead, it goes to the subroutine and eventually returns to the instruction
   *       following the jsr. This virtual edge is used to compute the real outgoing edges of the
   *       basic blocks ending with a ret instruction, in {@link #addSubroutineRetSuccessors}.
   *   <li>the second one corresponds to the target of the jsr instruction,
   * </ul>
   */
  static final int FLAG_SUBROUTINE_CALLER = 16;

  /**
   * A flag indicating that the basic block corresponding to a label is the start of a subroutine.
   */
  static final int FLAG_SUBROUTINE_START = 32;

  /** A flag indicating that the basic block corresponding to a label is the end of a subroutine. */
  static final int FLAG_SUBROUTINE_END = 64;

  /** A flag indicating that this label has at least one associated line number. */
  static final int FLAG_LINE_NUMBER = 128;

  /**
   * The number of elements to add to the {@link #otherLineNumbers} array when it needs to be
   * resized to store a new source line number.
   */
  static final int LINE_NUMBERS_CAPACITY_INCREMENT = 4;

  /**
   * The number of elements to add to the {@link #forwardReferences} array when it needs to be
   * resized to store a new forward reference.
   */
  static final int FORWARD_REFERENCES_CAPACITY_INCREMENT = 6;

  /**
   * The bit mask to extract the type of a forward reference to this label. The extracted type is
   * either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link #FORWARD_REFERENCE_TYPE_WIDE}.
   *
   * @see #forwardReferences
   */
  static final int FORWARD_REFERENCE_TYPE_MASK = 0xF0000000;

  /**
   * The type of forward references stored with two bytes in the bytecode. This is the case, for
   * instance, of a forward reference from an ifnull instruction.
   */
  static final int FORWARD_REFERENCE_TYPE_SHORT = 0x10000000;

  /**
   * The type of forward references stored in four bytes in the bytecode. This is the case, for
   * instance, of a forward reference from a lookupswitch instruction.
   */
  static final int FORWARD_REFERENCE_TYPE_WIDE = 0x20000000;

  /**
   * The type of forward references stored in two bytes in the <i>stack map table</i>. This is the
   * case of the labels of {@link Frame#ITEM_UNINITIALIZED} stack map frame elements, when the NEW
   * instruction is after the &lt;init&gt; constructor call (in bytecode offset order).
   */
  static final int FORWARD_REFERENCE_TYPE_STACK_MAP = 0x30000000;

  /**
   * The bit mask to extract the 'handle' of a forward reference to this label. The extracted handle
   * is the bytecode offset where the forward reference value is stored (using either 2 or 4 bytes,
   * as indicated by the {@link #FORWARD_REFERENCE_TYPE_MASK}).
   *
   * @see #forwardReferences
   */
  static final int FORWARD_REFERENCE_HANDLE_MASK = 0x0FFFFFFF;

  /**
   * A sentinel element used to indicate the end of a list of labels.
   *
   * @see #nextListElement
   */
  static final Label EMPTY_LIST = new Label();

  /**
   * A user managed state associated with this label. Warning: this field is used by the ASM tree
   * package. In order to use it with the ASM tree package you must override the getLabelNode method
   * in MethodNode.
   */
  public Object info;

  /**
   * The type and status of this label or its corresponding basic block. Must be zero or more of
   * {@link #FLAG_DEBUG_ONLY}, {@link #FLAG_JUMP_TARGET}, {@link #FLAG_RESOLVED}, {@link
   * #FLAG_REACHABLE}, {@link #FLAG_SUBROUTINE_CALLER}, {@link #FLAG_SUBROUTINE_START}, {@link
   * #FLAG_SUBROUTINE_END}.
   */
  short flags;

  /**
   * The source line number corresponding to this label, if {@link #FLAG_LINE_NUMBER} is set. If
   * there are several source line numbers corresponding to this label, the first one is stored in
   * this field, and the remaining ones are stored in {@link #otherLineNumbers}.
   */
  private short lineNumber;

  /**
   * The source line numbers corresponding to this label, in addition to {@link #lineNumber}, or
   * null. The first element of this array is the number n of source line numbers it contains, which
   * are stored between indices 1 and n (inclusive).
   */
  private int[] otherLineNumbers;

  /**
   * The offset of this label in the bytecode of its method, in bytes. This value is set if and only
   * if the {@link #FLAG_RESOLVED} flag is set.
   */
  int bytecodeOffset;

  /**
   * The forward references to this label. The first element is the number of forward references,
   * times 2 (this corresponds to the index of the last element actually used in this array). Then,
   * each forward reference is described with two consecutive integers noted
   * 'sourceInsnBytecodeOffset' and 'reference':
   *
   * <ul>
   *   <li>'sourceInsnBytecodeOffset' is the bytecode offset of the instruction that contains the
   *       forward reference,
   *   <li>'reference' contains the type and the offset in the bytecode where the forward reference
   *       value must be stored, which can be extracted with {@link #FORWARD_REFERENCE_TYPE_MASK}
   *       and {@link #FORWARD_REFERENCE_HANDLE_MASK}.
   * </ul>
   *
   * <p>For instance, for an ifnull instruction at bytecode offset x, 'sourceInsnBytecodeOffset' is
   * equal to x, and 'reference' is of type {@link #FORWARD_REFERENCE_TYPE_SHORT} with value x + 1
   * (because the ifnull instruction uses a 2 bytes bytecode offset operand stored one byte after
   * the start of the instruction itself). For the default case of a lookupswitch instruction at
   * bytecode offset x, 'sourceInsnBytecodeOffset' is equal to x, and 'reference' is of type {@link
   * #FORWARD_REFERENCE_TYPE_WIDE} with value between x + 1 and x + 4 (because the lookupswitch
   * instruction uses a 4 bytes bytecode offset operand stored one to four bytes after the start of
   * the instruction itself).
   */
  private int[] forwardReferences;

  // -----------------------------------------------------------------------------------------------

  // Fields for the control flow and data flow graph analysis algorithms (used to compute the
  // maximum stack size or the stack map frames). A control flow graph contains one node per "basic
  // block", and one edge per "jump" from one basic block to another. Each node (i.e., each basic
  // block) is represented with the Label object that corresponds to the first instruction of this
  // basic block. Each node also stores the list of its successors in the graph, as a linked list of
  // Edge objects.
  //
  // The control flow analysis algorithms used to compute the maximum stack size or the stack map
  // frames are similar and use two steps. The first step, during the visit of each instruction,
  // builds information about the state of the local variables and the operand stack at the end of
  // each basic block, called the "output frame", <i>relatively</i> to the frame state at the
  // beginning of the basic block, which is called the "input frame", and which is <i>unknown</i>
  // during this step. The second step, in {@link MethodWriter#computeAllFrames} and {@link
  // MethodWriter#computeMaxStackAndLocal}, is a fix point algorithm
  // that computes information about the input frame of each basic block, from the input state of
  // the first basic block (known from the method signature), and by the using the previously
  // computed relative output frames.
  //
  // The algorithm used to compute the maximum stack size only computes the relative output and
  // absolute input stack heights, while the algorithm used to compute stack map frames computes
  // relative output frames and absolute input frames.

  /**
   * The number of elements in the input stack of the basic block corresponding to this label. This
   * field is computed in {@link MethodWriter#computeMaxStackAndLocal}.
   */
  short inputStackSize;

  /**
   * The number of elements in the output stack, at the end of the basic block corresponding to this
   * label. This field is only computed for basic blocks that end with a RET instruction.
   */
  short outputStackSize;

  /**
   * The maximum height reached by the output stack, relatively to the top of the input stack, in
   * the basic block corresponding to this label. This maximum is always positive or {@literal
   * null}.
   */
  short outputStackMax;

  /**
   * The id of the subroutine to which this basic block belongs, or 0. If the basic block belongs to
   * several subroutines, this is the id of the "oldest" subroutine that contains it (with the
   * convention that a subroutine calling another one is "older" than the callee). This field is
   * computed in {@link MethodWriter#computeMaxStackAndLocal}, if the method contains JSR
   * instructions.
   */
  short subroutineId;

  /**
   * The input and output stack map frames of the basic block corresponding to this label. This
   * field is only used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} or {@link
   * MethodWriter#COMPUTE_INSERTED_FRAMES} option is used.
   */
  Frame frame;

  /**
   * The successor of this label, in the order they are visited in {@link MethodVisitor#visitLabel}.
   * This linked list does not include labels used for debug info only. If the {@link
   * MethodWriter#COMPUTE_ALL_FRAMES} or {@link MethodWriter#COMPUTE_INSERTED_FRAMES} option is used
   * then it does not contain either successive labels that denote the same bytecode offset (in this
   * case only the first label appears in this list).
   */
  Label nextBasicBlock;

  /**
   * The outgoing edges of the basic block corresponding to this label, in the control flow graph of
   * its method. These edges are stored in a linked list of {@link Edge} objects, linked to each
   * other by their {@link Edge#nextEdge} field.
   */
  Edge outgoingEdges;

  /**
   * The next element in the list of labels to which this label belongs, or {@literal null} if it
   * does not belong to any list. All lists of labels must end with the {@link #EMPTY_LIST}
   * sentinel, in order to ensure that this field is null if and only if this label does not belong
   * to a list of labels. Note that there can be several lists of labels at the same time, but that
   * a label can belong to at most one list at a time (unless some lists share a common tail, but
   * this is not used in practice).
   *
   * <p>List of labels are used in {@link MethodWriter#computeAllFrames} and {@link
   * MethodWriter#computeMaxStackAndLocal} to compute stack map frames and the maximum stack size,
   * respectively, as well as in {@link #markSubroutine} and {@link #addSubroutineRetSuccessors} to
   * compute the basic blocks belonging to subroutines and their outgoing edges. Outside of these
   * methods, this field should be null (this property is a precondition and a postcondition of
   * these methods).
   */
  Label nextListElement;

  // -----------------------------------------------------------------------------------------------
  // Constructor and accessors
  // -----------------------------------------------------------------------------------------------

  /** Constructs a new label. */
  public Label() {
    // Nothing to do.
  }

  /**
   * Returns the bytecode offset corresponding to this label. This offset is computed from the start
   * of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is
   * normally not needed by class generators or adapters.</i>
   *
   * @return the bytecode offset corresponding to this label.
   * @throws IllegalStateException if this label is not resolved yet.
   */
  public int getOffset() {
    if ((flags & FLAG_RESOLVED) == 0) {
      throw new IllegalStateException("Label offset position has not been resolved yet");
    }
    return bytecodeOffset;
  }

  /**
   * Returns the "canonical" {@link Label} instance corresponding to this label's bytecode offset,
   * if known, otherwise the label itself. The canonical instance is the first label (in the order
   * of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It
   * cannot be known for labels which have not been visited yet.
   *
   * <p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option
   * is used.</i>
   *
   * @return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This
   *     corresponds to the "canonical" label instance described above thanks to the way the label
   *     frame is set in {@link MethodWriter#visitLabel}.
   */
  final Label getCanonicalInstance() {
    return frame == null ? this : frame.owner;
  }

  // -----------------------------------------------------------------------------------------------
  // Methods to manage line numbers
  // -----------------------------------------------------------------------------------------------

  /**
   * Adds a source line number corresponding to this label.
   *
   * @param lineNumber a source line number (which should be strictly positive).
   */
  final void addLineNumber(final int lineNumber) {
    if ((flags & FLAG_LINE_NUMBER) == 0) {
      flags |= FLAG_LINE_NUMBER;
      this.lineNumber = (short) lineNumber;
    } else {
      if (otherLineNumbers == null) {
        otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT];
      }
      int otherLineNumberIndex = ++otherLineNumbers[0];
      if (otherLineNumberIndex >= otherLineNumbers.length) {
        int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];
        System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length);
        otherLineNumbers = newLineNumbers;
      }
      otherLineNumbers[otherLineNumberIndex] = lineNumber;
    }
  }

  /**
   * Makes the given visitor visit this label and its source line numbers, if applicable.
   *
   * @param methodVisitor a method visitor.
   * @param visitLineNumbers whether to visit of the label's source line numbers, if any.
   */
  final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {
    methodVisitor.visitLabel(this);
    if (visitLineNumbers && (flags & FLAG_LINE_NUMBER) != 0) {
      methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this);
      if (otherLineNumbers != null) {
        for (int i = 1; i <= otherLineNumbers[0]; ++i) {
          methodVisitor.visitLineNumber(otherLineNumbers[i], this);
        }
      }
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Methods to compute offsets and to manage forward references
  // -----------------------------------------------------------------------------------------------

  /**
   * Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label
   * is known, the relative bytecode offset between the label and the instruction referencing it is
   * computed and written directly. Otherwise, a null relative offset is written and a new forward
   * reference is declared for this label.
   *
   * @param code the bytecode of the method. This is where the reference is appended.
   * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the
   *     reference to be appended.
   * @param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).
   */
  final void put(
      final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {
    if ((flags & FLAG_RESOLVED) == 0) {
      if (wideReference) {
        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length);
        code.putInt(-1);
      } else {
        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length);
        code.putShort(-1);
      }
    } else {
      if (wideReference) {
        code.putInt(bytecodeOffset - sourceInsnBytecodeOffset);
      } else {
        code.putShort(bytecodeOffset - sourceInsnBytecodeOffset);
      }
    }
  }

  /**
   * Puts a reference to this label in the <i>stack map table</i> of a method. If the bytecode
   * offset of the label is known, it is written directly. Otherwise, a null relative offset is
   * written and a new forward reference is declared for this label.
   *
   * @param stackMapTableEntries the stack map table where the label offset must be added.
   */
  final void put(final ByteVector stackMapTableEntries) {
    if ((flags & FLAG_RESOLVED) == 0) {
      addForwardReference(0, FORWARD_REFERENCE_TYPE_STACK_MAP, stackMapTableEntries.length);
    }
    stackMapTableEntries.putShort(bytecodeOffset);
  }

  /**
   * Adds a forward reference to this label. This method must be called only for a true forward
   * reference, i.e. only if this label is not resolved yet. For backward references, the relative
   * bytecode offset of the reference can be, and must be, computed and stored directly.
   *
   * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the
   *     reference stored at referenceHandle.
   * @param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link
   *     #FORWARD_REFERENCE_TYPE_WIDE}.
   * @param referenceHandle the offset in the bytecode where the forward reference value must be
   *     stored.
   */
  private void addForwardReference(
      final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {
    if (forwardReferences == null) {
      forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];
    }
    int lastElementIndex = forwardReferences[0];
    if (lastElementIndex + 2 >= forwardReferences.length) {
      int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT];
      System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length);
      forwardReferences = newValues;
    }
    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset;
    forwardReferences[++lastElementIndex] = referenceType | referenceHandle;
    forwardReferences[0] = lastElementIndex;
  }

  /**
   * Sets the bytecode offset of this label to the given value and resolves the forward references
   * to this label, if any. This method must be called when this label is added to the bytecode of
   * the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that
   * where left in the bytecode (and optionally in the stack map table) by each forward reference
   * previously added to this label.
   *
   * @param code the bytecode of the method.
   * @param stackMapTableEntries the 'entries' array of the StackMapTable code attribute of the
   *     method. Maybe {@literal null}.
   * @param bytecodeOffset the bytecode offset of this label.
   * @return {@literal true} if a blank that was left for this label was too small to store the
   *     offset. In such a case the corresponding jump instruction is replaced with an equivalent
   *     ASM specific instruction using an unsigned two bytes offset. These ASM specific
   *     instructions are later replaced with standard bytecode instructions with wider offsets (4
   *     bytes instead of 2), in ClassReader.
   */
  final boolean resolve(
      final byte[] code, final ByteVector stackMapTableEntries, final int bytecodeOffset) {
    this.flags |= FLAG_RESOLVED;
    this.bytecodeOffset = bytecodeOffset;
    if (forwardReferences == null) {
      return false;
    }
    boolean hasAsmInstructions = false;
    for (int i = forwardReferences[0]; i > 0; i -= 2) {
      final int sourceInsnBytecodeOffset = forwardReferences[i - 1];
      final int reference = forwardReferences[i];
      final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset;
      int handle = reference & FORWARD_REFERENCE_HANDLE_MASK;
      if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {
        if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {
          // Change the opcode of the jump instruction, in order to be able to find it later in
          // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except
          // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to
          // 65535, which is sufficient since the size of a method is limited to 65535 bytes).
          int opcode = code[sourceInsnBytecodeOffset] & 0xFF;
          if (opcode < Opcodes.IFNULL) {
            // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR.
            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA);
          } else {
            // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL.
            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA);
          }
          hasAsmInstructions = true;
        }
        code[handle++] = (byte) (relativeOffset >>> 8);
        code[handle] = (byte) relativeOffset;
      } else if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_WIDE) {
        code[handle++] = (byte) (relativeOffset >>> 24);
        code[handle++] = (byte) (relativeOffset >>> 16);
        code[handle++] = (byte) (relativeOffset >>> 8);
        code[handle] = (byte) relativeOffset;
      } else {
        stackMapTableEntries.data[handle++] = (byte) (bytecodeOffset >>> 8);
        stackMapTableEntries.data[handle] = (byte) bytecodeOffset;
      }
    }
    return hasAsmInstructions;
  }

  // -----------------------------------------------------------------------------------------------
  // Methods related to subroutines
  // -----------------------------------------------------------------------------------------------

  /**
   * Finds the basic blocks that belong to the subroutine starting with the basic block
   * corresponding to this label, and marks these blocks as belonging to this subroutine. This
   * method follows the control flow graph to find all the blocks that are reachable from the
   * current basic block WITHOUT following any jsr target.
   *
   * <p>Note: a precondition and postcondition of this method is that all labels must have a null
   * {@link #nextListElement}.
   *
   * @param subroutineId the id of the subroutine starting with the basic block corresponding to
   *     this label.
   */
  final void markSubroutine(final short subroutineId) {
    // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks
    // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from
    // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the
    // control flow graph to the list of blocks to process (if not already done).
    Label listOfBlocksToProcess = this;
    listOfBlocksToProcess.nextListElement = EMPTY_LIST;
    while (listOfBlocksToProcess != EMPTY_LIST) {
      // Remove a basic block from the list of blocks to process.
      Label basicBlock = listOfBlocksToProcess;
      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;
      basicBlock.nextListElement = null;

      // If it is not already marked as belonging to a subroutine, mark it as belonging to
      // subroutineId and add its successors to the list of blocks to process (unless already done).
      if (basicBlock.subroutineId == 0) {
        basicBlock.subroutineId = subroutineId;
        listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);
      }
    }
  }

  /**
   * Finds the basic blocks that end a subroutine starting with the basic block corresponding to
   * this label and, for each one of them, adds an outgoing edge to the basic block following the
   * given subroutine call. In other words, completes the control flow graph by adding the edges
   * corresponding to the return from this subroutine, when called from the given caller basic
   * block.
   *
   * <p>Note: a precondition and postcondition of this method is that all labels must have a null
   * {@link #nextListElement}.
   *
   * @param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to
   *     this label. This label is supposed to correspond to the start of a subroutine.
   */
  final void addSubroutineRetSuccessors(final Label subroutineCaller) {
    // Data flow algorithm: put this basic block in a list blocks to process (which are blocks
    // belonging to a subroutine starting with this label) and, while there are blocks to process,
    // remove one from the list, put it in a list of blocks that have been processed, add a return
    // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks
    // in the control flow graph to the list of blocks to process (if not already done).
    Label listOfProcessedBlocks = EMPTY_LIST;
    Label listOfBlocksToProcess = this;
    listOfBlocksToProcess.nextListElement = EMPTY_LIST;
    while (listOfBlocksToProcess != EMPTY_LIST) {
      // Move a basic block from the list of blocks to process to the list of processed blocks.
      Label basicBlock = listOfBlocksToProcess;
      listOfBlocksToProcess = basicBlock.nextListElement;
      basicBlock.nextListElement = listOfProcessedBlocks;
      listOfProcessedBlocks = basicBlock;

      // Add an edge from this block to the successor of the caller basic block, if this block is
      // the end of a subroutine and if this block and subroutineCaller do not belong to the same
      // subroutine.
      if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0
          && basicBlock.subroutineId != subroutineCaller.subroutineId) {
        basicBlock.outgoingEdges =
            new Edge(
                basicBlock.outputStackSize,
                // By construction, the first outgoing edge of a basic block that ends with a jsr
                // instruction leads to the jsr continuation block, i.e. where execution continues
                // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}).
                subroutineCaller.outgoingEdges.successor,
                basicBlock.outgoingEdges);
      }
      // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does
      // not push basic blocks which are already in a list. Here this means either in the list of
      // blocks to process, or in the list of already processed blocks. This second list is
      // important to make sure we don't reprocess an already processed block.
      listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);
    }
    // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null,
    // so that this method can be called again with a different subroutine or subroutine caller.
    while (listOfProcessedBlocks != EMPTY_LIST) {
      Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement;
      listOfProcessedBlocks.nextListElement = null;
      listOfProcessedBlocks = newListOfProcessedBlocks;
    }
  }

  /**
   * Adds the successors of this label in the method's control flow graph (except those
   * corresponding to a jsr target, and those already in a list of labels) to the given list of
   * blocks to process, and returns the new list.
   *
   * @param listOfLabelsToProcess a list of basic blocks to process, linked together with their
   *     {@link #nextListElement} field.
   * @return the new list of blocks to process.
   */
  private Label pushSuccessors(final Label listOfLabelsToProcess) {
    Label newListOfLabelsToProcess = listOfLabelsToProcess;
    Edge outgoingEdge = outgoingEdges;
    while (outgoingEdge != null) {
      // By construction, the second outgoing edge of a basic block that ends with a jsr instruction
      // leads to the jsr target (see {@link #FLAG_SUBROUTINE_CALLER}).
      boolean isJsrTarget =
          (flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && outgoingEdge == outgoingEdges.nextEdge;
      if (!isJsrTarget && outgoingEdge.successor.nextListElement == null) {
        // Add this successor to the list of blocks to process, if it does not already belong to a
        // list of labels.
        outgoingEdge.successor.nextListElement = newListOfLabelsToProcess;
        newListOfLabelsToProcess = outgoingEdge.successor;
      }
      outgoingEdge = outgoingEdge.nextEdge;
    }
    return newListOfLabelsToProcess;
  }

  // -----------------------------------------------------------------------------------------------
  // Overridden Object methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns a string representation of this label.
   *
   * @return a string representation of this label.
   */
  @Override
  public String toString() {
    return "L" + System.identityHashCode(this);
  }
}


package org.objectweb.asm;

/**
 * The path to a type argument, wildcard bound, array element type, or static inner type within an
 * enclosing type.
 *
 * @author Eric Bruneton
 */
public final class TypePath {

  /** A type path step that steps into the element type of an array type. See {@link #getStep}. */
  public static final int ARRAY_ELEMENT = 0;

  /** A type path step that steps into the nested type of a class type. See {@link #getStep}. */
  public static final int INNER_TYPE = 1;

  /** A type path step that steps into the bound of a wildcard type. See {@link #getStep}. */
  public static final int WILDCARD_BOUND = 2;

  /** A type path step that steps into a type argument of a generic type. See {@link #getStep}. */
  public static final int TYPE_ARGUMENT = 3;

  /**
   * The byte array where the 'type_path' structure - as defined in the Java Virtual Machine
   * Specification (JVMS) - corresponding to this TypePath is stored. The first byte of the
   * structure in this array is given by {@link #typePathOffset}.
   *
   * @see <a
   *     href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.2">JVMS
   *     4.7.20.2</a>
   */
  private final byte[] typePathContainer;

  /** The offset of the first byte of the type_path JVMS structure in {@link #typePathContainer}. */
  private final int typePathOffset;

  /**
   * Constructs a new TypePath.
   *
   * @param typePathContainer a byte array containing a type_path JVMS structure.
   * @param typePathOffset the offset of the first byte of the type_path structure in
   *     typePathContainer.
   */
  TypePath(final byte[] typePathContainer, final int typePathOffset) {
    this.typePathContainer = typePathContainer;
    this.typePathOffset = typePathOffset;
  }

  /**
   * Returns the length of this path, i.e. its number of steps.
   *
   * @return the length of this path.
   */
  public int getLength() {
    // path_length is stored in the first byte of a type_path.
    return typePathContainer[typePathOffset];
  }

  /**
   * Returns the value of the given step of this path.
   *
   * @param index an index between 0 and {@link #getLength()}, exclusive.
   * @return one of {@link #ARRAY_ELEMENT}, {@link #INNER_TYPE}, {@link #WILDCARD_BOUND}, or {@link
   *     #TYPE_ARGUMENT}.
   */
  public int getStep(final int index) {
    // Returns the type_path_kind of the path element of the given index.
    return typePathContainer[typePathOffset + 2 * index + 1];
  }

  /**
   * Returns the index of the type argument that the given step is stepping into. This method should
   * only be used for steps whose value is {@link #TYPE_ARGUMENT}.
   *
   * @param index an index between 0 and {@link #getLength()}, exclusive.
   * @return the index of the type argument that the given step is stepping into.
   */
  public int getStepArgument(final int index) {
    // Returns the type_argument_index of the path element of the given index.
    return typePathContainer[typePathOffset + 2 * index + 2];
  }

  /**
   * Converts a type path in string form, in the format used by {@link #toString()}, into a TypePath
   * object.
   *
   * @param typePath a type path in string form, in the format used by {@link #toString()}. May be
   *     {@literal null} or empty.
   * @return the corresponding TypePath object, or {@literal null} if the path is empty.
   */
  public static TypePath fromString(final String typePath) {
    if (typePath == null || typePath.length() == 0) {
      return null;
    }
    int typePathLength = typePath.length();
    ByteVector output = new ByteVector(typePathLength);
    output.putByte(0);
    int typePathIndex = 0;
    while (typePathIndex < typePathLength) {
      char c = typePath.charAt(typePathIndex++);
      if (c == '[') {
        output.put11(ARRAY_ELEMENT, 0);
      } else if (c == '.') {
        output.put11(INNER_TYPE, 0);
      } else if (c == '*') {
        output.put11(WILDCARD_BOUND, 0);
      } else if (c >= '0' && c <= '9') {
        int typeArg = c - '0';
        while (typePathIndex < typePathLength) {
          c = typePath.charAt(typePathIndex++);
          if (c >= '0' && c <= '9') {
            typeArg = typeArg * 10 + c - '0';
          } else if (c == ';') {
            break;
          } else {
            throw new IllegalArgumentException();
          }
        }
        output.put11(TYPE_ARGUMENT, typeArg);
      } else {
        throw new IllegalArgumentException();
      }
    }
    output.data[0] = (byte) (output.length / 2);
    return new TypePath(output.data, 0);
  }

  /**
   * Returns a string representation of this type path. {@link #ARRAY_ELEMENT} steps are represented
   * with '[', {@link #INNER_TYPE} steps with '.', {@link #WILDCARD_BOUND} steps with '*' and {@link
   * #TYPE_ARGUMENT} steps with their type argument index in decimal form followed by ';'.
   */
  @Override
  public String toString() {
    int length = getLength();
    StringBuilder result = new StringBuilder(length * 2);
    for (int i = 0; i < length; ++i) {
      switch (getStep(i)) {
        case ARRAY_ELEMENT:
          result.append('[');
          break;
        case INNER_TYPE:
          result.append('.');
          break;
        case WILDCARD_BOUND:
          result.append('*');
          break;
        case TYPE_ARGUMENT:
          result.append(getStepArgument(i)).append(';');
          break;
        default:
          throw new AssertionError();
      }
    }
    return result.toString();
  }

  /**
   * Puts the type_path JVMS structure corresponding to the given TypePath into the given
   * ByteVector.
   *
   * @param typePath a TypePath instance, or {@literal null} for empty paths.
   * @param output where the type path must be put.
   */
  static void put(final TypePath typePath, final ByteVector output) {
    if (typePath == null) {
      output.putByte(0);
    } else {
      int length = typePath.typePathContainer[typePath.typePathOffset] * 2 + 1;
      output.putByteArray(typePath.typePathContainer, typePath.typePathOffset, length);
    }
  }
}

package org.objectweb.asm;

import java.util.Arrays;

/**
 * A constant whose value is computed at runtime, with a bootstrap method.
 *
 * @author Remi Forax
 */
public final class ConstantDynamic {

  /** The constant name (can be arbitrary). */
  private final String name;

  /** The constant type (must be a field descriptor). */
  private final String descriptor;

  /** The bootstrap method to use to compute the constant value at runtime. */
  private final Handle bootstrapMethod;

  /**
   * The arguments to pass to the bootstrap method, in order to compute the constant value at
   * runtime.
   */
  private final Object[] bootstrapMethodArguments;

  /**
   * Constructs a new {@link ConstantDynamic}.
   *
   * @param name the constant name (can be arbitrary).
   * @param descriptor the constant type (must be a field descriptor).
   * @param bootstrapMethod the bootstrap method to use to compute the constant value at runtime.
   * @param bootstrapMethodArguments the arguments to pass to the bootstrap method, in order to
   *     compute the constant value at runtime.
   */
  public ConstantDynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethod,
      final Object... bootstrapMethodArguments) {
    this.name = name;
    this.descriptor = descriptor;
    this.bootstrapMethod = bootstrapMethod;
    this.bootstrapMethodArguments = bootstrapMethodArguments;
  }

  /**
   * Returns the name of this constant.
   *
   * @return the name of this constant.
   */
  public String getName() {
    return name;
  }

  /**
   * Returns the type of this constant.
   *
   * @return the type of this constant, as a field descriptor.
   */
  public String getDescriptor() {
    return descriptor;
  }

  /**
   * Returns the bootstrap method used to compute the value of this constant.
   *
   * @return the bootstrap method used to compute the value of this constant.
   */
  public Handle getBootstrapMethod() {
    return bootstrapMethod;
  }

  /**
   * Returns the number of arguments passed to the bootstrap method, in order to compute the value
   * of this constant.
   *
   * @return the number of arguments passed to the bootstrap method, in order to compute the value
   *     of this constant.
   */
  public int getBootstrapMethodArgumentCount() {
    return bootstrapMethodArguments.length;
  }

  /**
   * Returns an argument passed to the bootstrap method, in order to compute the value of this
   * constant.
   *
   * @param index an argument index, between 0 and {@link #getBootstrapMethodArgumentCount()}
   *     (exclusive).
   * @return the argument passed to the bootstrap method, with the given index.
   */
  public Object getBootstrapMethodArgument(final int index) {
    return bootstrapMethodArguments[index];
  }

  /**
   * Returns the arguments to pass to the bootstrap method, in order to compute the value of this
   * constant. WARNING: this array must not be modified, and must not be returned to the user.
   *
   * @return the arguments to pass to the bootstrap method, in order to compute the value of this
   *     constant.
   */
  Object[] getBootstrapMethodArgumentsUnsafe() {
    return bootstrapMethodArguments;
  }

  /**
   * Returns the size of this constant.
   *
   * @return the size of this constant, i.e., 2 for {@code long} and {@code double}, 1 otherwise.
   */
  public int getSize() {
    char firstCharOfDescriptor = descriptor.charAt(0);
    return (firstCharOfDescriptor == 'J' || firstCharOfDescriptor == 'D') ? 2 : 1;
  }

  @Override
  public boolean equals(final Object object) {
    if (object == this) {
      return true;
    }
    if (!(object instanceof ConstantDynamic)) {
      return false;
    }
    ConstantDynamic constantDynamic = (ConstantDynamic) object;
    return name.equals(constantDynamic.name)
        && descriptor.equals(constantDynamic.descriptor)
        && bootstrapMethod.equals(constantDynamic.bootstrapMethod)
        && Arrays.equals(bootstrapMethodArguments, constantDynamic.bootstrapMethodArguments);
  }

  @Override
  public int hashCode() {
    return name.hashCode()
        ^ Integer.rotateLeft(descriptor.hashCode(), 8)
        ^ Integer.rotateLeft(bootstrapMethod.hashCode(), 16)
        ^ Integer.rotateLeft(Arrays.hashCode(bootstrapMethodArguments), 24);
  }

  @Override
  public String toString() {
    return name
        + " : "
        + descriptor
        + ' '
        + bootstrapMethod
        + ' '
        + Arrays.toString(bootstrapMethodArguments);
  }
}

package org.objectweb.asm;

/**
 * A {@link ClassVisitor} that generates a corresponding ClassFile structure, as defined in the Java
 * Virtual Machine Specification (JVMS). It can be used alone, to generate a Java class "from
 * scratch", or with one or more {@link ClassReader} and adapter {@link ClassVisitor} to generate a
 * modified class from one or more existing Java classes.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html">JVMS 4</a>
 * @author Eric Bruneton
 */
public class ClassWriter extends ClassVisitor {

  /**
   * A flag to automatically compute the maximum stack size and the maximum number of local
   * variables of methods. If this flag is set, then the arguments of the {@link
   * MethodVisitor#visitMaxs} method of the {@link MethodVisitor} returned by the {@link
   * #visitMethod} method will be ignored, and computed automatically from the signature and the
   * bytecode of each method.
   *
   * <p><b>Note:</b> for classes whose version is {@link Opcodes#V1_7} of more, this option requires
   * valid stack map frames. The maximum stack size is then computed from these frames, and from the
   * bytecode instructions in between. If stack map frames are not present or must be recomputed,
   * used {@link #COMPUTE_FRAMES} instead.
   *
   * @see #ClassWriter(int)
   */
  public static final int COMPUTE_MAXS = 1;

  /**
   * A flag to automatically compute the stack map frames of methods from scratch. If this flag is
   * set, then the calls to the {@link MethodVisitor#visitFrame} method are ignored, and the stack
   * map frames are recomputed from the methods bytecode. The arguments of the {@link
   * MethodVisitor#visitMaxs} method are also ignored and recomputed from the bytecode. In other
   * words, {@link #COMPUTE_FRAMES} implies {@link #COMPUTE_MAXS}.
   *
   * @see #ClassWriter(int)
   */
  public static final int COMPUTE_FRAMES = 2;

  /**
   * The flags passed to the constructor. Must be zero or more of {@link #COMPUTE_MAXS} and {@link
   * #COMPUTE_FRAMES}.
   */
  private final int flags;

  // Note: fields are ordered as in the ClassFile structure, and those related to attributes are
  // ordered as in Section 4.7 of the JVMS.

  /**
   * The minor_version and major_version fields of the JVMS ClassFile structure. minor_version is
   * stored in the 16 most significant bits, and major_version in the 16 least significant bits.
   */
  private int version;

  /** The symbol table for this class (contains the constant_pool and the BootstrapMethods). */
  private final SymbolTable symbolTable;

  /**
   * The access_flags field of the JVMS ClassFile structure. This field can contain ASM specific
   * access flags, such as {@link Opcodes#ACC_DEPRECATED} or {@link Opcodes#ACC_RECORD}, which are
   * removed when generating the ClassFile structure.
   */
  private int accessFlags;

  /** The this_class field of the JVMS ClassFile structure. */
  private int thisClass;

  /** The super_class field of the JVMS ClassFile structure. */
  private int superClass;

  /** The interface_count field of the JVMS ClassFile structure. */
  private int interfaceCount;

  /** The 'interfaces' array of the JVMS ClassFile structure. */
  private int[] interfaces;

  /**
   * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their
   * {@link FieldWriter#fv} field. This field stores the first element of this list.
   */
  private FieldWriter firstField;

  /**
   * The fields of this class, stored in a linked list of {@link FieldWriter} linked via their
   * {@link FieldWriter#fv} field. This field stores the last element of this list.
   */
  private FieldWriter lastField;

  /**
   * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their
   * {@link MethodWriter#mv} field. This field stores the first element of this list.
   */
  private MethodWriter firstMethod;

  /**
   * The methods of this class, stored in a linked list of {@link MethodWriter} linked via their
   * {@link MethodWriter#mv} field. This field stores the last element of this list.
   */
  private MethodWriter lastMethod;

  /** The number_of_classes field of the InnerClasses attribute, or 0. */
  private int numberOfInnerClasses;

  /** The 'classes' array of the InnerClasses attribute, or {@literal null}. */
  private ByteVector innerClasses;

  /** The class_index field of the EnclosingMethod attribute, or 0. */
  private int enclosingClassIndex;

  /** The method_index field of the EnclosingMethod attribute. */
  private int enclosingMethodIndex;

  /** The signature_index field of the Signature attribute, or 0. */
  private int signatureIndex;

  /** The source_file_index field of the SourceFile attribute, or 0. */
  private int sourceFileIndex;

  /** The debug_extension field of the SourceDebugExtension attribute, or {@literal null}. */
  private ByteVector debugExtension;

  /**
   * The last runtime visible annotation of this class. The previous ones can be accessed with the
   * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeVisibleAnnotation;

  /**
   * The last runtime invisible annotation of this class. The previous ones can be accessed with the
   * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeInvisibleAnnotation;

  /**
   * The last runtime visible type annotation of this class. The previous ones can be accessed with
   * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeVisibleTypeAnnotation;

  /**
   * The last runtime invisible type annotation of this class. The previous ones can be accessed
   * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;

  /** The Module attribute of this class, or {@literal null}. */
  private ModuleWriter moduleWriter;

  /** The host_class_index field of the NestHost attribute, or 0. */
  private int nestHostClassIndex;

  /** The number_of_classes field of the NestMembers attribute, or 0. */
  private int numberOfNestMemberClasses;

  /** The 'classes' array of the NestMembers attribute, or {@literal null}. */
  private ByteVector nestMemberClasses;

  /** The number_of_classes field of the PermittedSubclasses attribute, or 0. */
  private int numberOfPermittedSubclasses;

  /** The 'classes' array of the PermittedSubclasses attribute, or {@literal null}. */
  private ByteVector permittedSubclasses;

  /**
   * The record components of this class, stored in a linked list of {@link RecordComponentWriter}
   * linked via their {@link RecordComponentWriter#delegate} field. This field stores the first
   * element of this list.
   */
  private RecordComponentWriter firstRecordComponent;

  /**
   * The record components of this class, stored in a linked list of {@link RecordComponentWriter}
   * linked via their {@link RecordComponentWriter#delegate} field. This field stores the last
   * element of this list.
   */
  private RecordComponentWriter lastRecordComponent;

  /**
   * The first non standard attribute of this class. The next ones can be accessed with the {@link
   * Attribute#nextAttribute} field. May be {@literal null}.
   *
   * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.
   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link
   * #toByteArray} method writes the attributes in the order defined by this list, i.e. in the
   * reverse order specified by the user.
   */
  private Attribute firstAttribute;

  /**
   * Indicates what must be automatically computed in {@link MethodWriter}. Must be one of {@link
   * MethodWriter#COMPUTE_NOTHING}, {@link MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL}, {@link
   * MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link
   * MethodWriter#COMPUTE_INSERTED_FRAMES}, or {@link MethodWriter#COMPUTE_ALL_FRAMES}.
   */
  private int compute;

  // -----------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link ClassWriter} object.
   *
   * @param flags option flags that can be used to modify the default behavior of this class. Must
   *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.
   */
  public ClassWriter(final int flags) {
    this(null, flags);
  }

  /**
   * Constructs a new {@link ClassWriter} object and enables optimizations for "mostly add" bytecode
   * transformations. These optimizations are the following:
   *
   * <ul>
   *   <li>The constant pool and bootstrap methods from the original class are copied as is in the
   *       new class, which saves time. New constant pool entries and new bootstrap methods will be
   *       added at the end if necessary, but unused constant pool entries or bootstrap methods
   *       <i>won't be removed</i>.
   *   <li>Methods that are not transformed are copied as is in the new class, directly from the
   *       original class bytecode (i.e. without emitting visit events for all the method
   *       instructions), which saves a <i>lot</i> of time. Untransformed methods are detected by
   *       the fact that the {@link ClassReader} receives {@link MethodVisitor} objects that come
   *       from a {@link ClassWriter} (and not from any other {@link ClassVisitor} instance).
   * </ul>
   *
   * @param classReader the {@link ClassReader} used to read the original class. It will be used to
   *     copy the entire constant pool and bootstrap methods from the original class and also to
   *     copy other fragments of original bytecode where applicable.
   * @param flags option flags that can be used to modify the default behavior of this class. Must
   *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}. <i>These option flags
   *     do not affect methods that are copied as is in the new class. This means that neither the
   *     maximum stack size nor the stack frames will be computed for these methods</i>.
   */
  public ClassWriter(final ClassReader classReader, final int flags) {
    super(/* latest api = */ Opcodes.ASM9);
    this.flags = flags;
    symbolTable = classReader == null ? new SymbolTable(this) : new SymbolTable(this, classReader);
    setFlags(flags);
  }

  // -----------------------------------------------------------------------------------------------
  // Accessors
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns true if all the given flags were passed to the constructor.
   *
   * @param flags some option flags. Must be zero or more of {@link #COMPUTE_MAXS} and {@link
   *     #COMPUTE_FRAMES}.
   * @return true if all the given flags, or more, were passed to the constructor.
   */
  public boolean hasFlags(final int flags) {
    return (this.flags & flags) == flags;
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the ClassVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public final void visit(
      final int version,
      final int access,
      final String name,
      final String signature,
      final String superName,
      final String[] interfaces) {
    this.version = version;
    this.accessFlags = access;
    this.thisClass = symbolTable.setMajorVersionAndClassName(version & 0xFFFF, name);
    if (signature != null) {
      this.signatureIndex = symbolTable.addConstantUtf8(signature);
    }
    this.superClass = superName == null ? 0 : symbolTable.addConstantClass(superName).index;
    if (interfaces != null && interfaces.length > 0) {
      interfaceCount = interfaces.length;
      this.interfaces = new int[interfaceCount];
      for (int i = 0; i < interfaceCount; ++i) {
        this.interfaces[i] = symbolTable.addConstantClass(interfaces[i]).index;
      }
    }
    if (compute == MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL && (version & 0xFFFF) >= Opcodes.V1_7) {
      compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;
    }
  }

  @Override
  public final void visitSource(final String file, final String debug) {
    if (file != null) {
      sourceFileIndex = symbolTable.addConstantUtf8(file);
    }
    if (debug != null) {
      debugExtension = new ByteVector().encodeUtf8(debug, 0, Integer.MAX_VALUE);
    }
  }

  @Override
  public final ModuleVisitor visitModule(
      final String name, final int access, final String version) {
    return moduleWriter =
        new ModuleWriter(
            symbolTable,
            symbolTable.addConstantModule(name).index,
            access,
            version == null ? 0 : symbolTable.addConstantUtf8(version));
  }

  @Override
  public final void visitNestHost(final String nestHost) {
    nestHostClassIndex = symbolTable.addConstantClass(nestHost).index;
  }

  @Override
  public final void visitOuterClass(
      final @InternalForm String owner, final String name, final String descriptor) {
    enclosingClassIndex = symbolTable.addConstantClass(owner).index;
    if (name != null && descriptor != null) {
      enclosingMethodIndex = symbolTable.addConstantNameAndType(name, descriptor);
    }
  }

  @Override
  public final AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (visible) {
      return lastRuntimeVisibleAnnotation =
          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);
    } else {
      return lastRuntimeInvisibleAnnotation =
          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);
    }
  }

  @Override
  public final AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (visible) {
      return lastRuntimeVisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);
    } else {
      return lastRuntimeInvisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);
    }
  }

  @Override
  public final void visitAttribute(final Attribute attribute) {
    // Store the attributes in the <i>reverse</i> order of their visit by this method.
    attribute.nextAttribute = firstAttribute;
    firstAttribute = attribute;
  }

  @Override
  public final void visitNestMember(final String nestMember) {
    if (nestMemberClasses == null) {
      nestMemberClasses = new ByteVector();
    }
    ++numberOfNestMemberClasses;
    nestMemberClasses.putShort(symbolTable.addConstantClass(nestMember).index);
  }

  @Override
  public final void visitPermittedSubclass(final String permittedSubclass) {
    if (permittedSubclasses == null) {
      permittedSubclasses = new ByteVector();
    }
    ++numberOfPermittedSubclasses;
    permittedSubclasses.putShort(symbolTable.addConstantClass(permittedSubclass).index);
  }

  @Override
  public final void visitInnerClass(
      final @InternalForm String name, final @InternalForm String outerName, final @Identifier String innerName, final int access) {
    if (innerClasses == null) {
      innerClasses = new ByteVector();
    }
    // Section 4.7.6 of the JVMS states "Every CONSTANT_Class_info entry in the constant_pool table
    // which represents a class or interface C that is not a package member must have exactly one
    // corresponding entry in the classes array". To avoid duplicates we keep track in the info
    // field of the Symbol of each CONSTANT_Class_info entry C whether an inner class entry has
    // already been added for C. If so, we store the index of this inner class entry (plus one) in
    // the info field. This trick allows duplicate detection in O(1) time.
    Symbol nameSymbol = symbolTable.addConstantClass(name);
    if (nameSymbol.info == 0) {
      ++numberOfInnerClasses;
      innerClasses.putShort(nameSymbol.index);
      innerClasses.putShort(outerName == null ? 0 : symbolTable.addConstantClass(outerName).index);
      innerClasses.putShort(innerName == null ? 0 : symbolTable.addConstantUtf8(innerName));
      innerClasses.putShort(access);
      nameSymbol.info = numberOfInnerClasses;
    }
    // Else, compare the inner classes entry nameSymbol.info - 1 with the arguments of this method
    // and throw an exception if there is a difference?
  }

  @Override
  public final RecordComponentVisitor visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    RecordComponentWriter recordComponentWriter =
        new RecordComponentWriter(symbolTable, name, descriptor, signature);
    if (firstRecordComponent == null) {
      firstRecordComponent = recordComponentWriter;
    } else {
      lastRecordComponent.delegate = recordComponentWriter;
    }
    return lastRecordComponent = recordComponentWriter;
  }

  @Override
  public final FieldVisitor visitField(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    FieldWriter fieldWriter =
        new FieldWriter(symbolTable, access, name, descriptor, signature, value);
    if (firstField == null) {
      firstField = fieldWriter;
    } else {
      lastField.fv = fieldWriter;
    }
    return lastField = fieldWriter;
  }

  @Override
  public final MethodVisitor visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final String[] exceptions) {
    MethodWriter methodWriter =
        new MethodWriter(symbolTable, access, name, descriptor, signature, exceptions, compute);
    if (firstMethod == null) {
      firstMethod = methodWriter;
    } else {
      lastMethod.mv = methodWriter;
    }
    return lastMethod = methodWriter;
  }

  @Override
  public final void visitEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Other public methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the content of the class file that was built by this ClassWriter.
   *
   * @return the binary content of the JVMS ClassFile structure that was built by this ClassWriter.
   * @throws ClassTooLargeException if the constant pool of the class is too large.
   * @throws MethodTooLargeException if the Code attribute of a method is too large.
   */
  public byte[] toByteArray() {
    // First step: compute the size in bytes of the ClassFile structure.
    // The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,
    // constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,
    // methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.
    int size = 24 + 2 * interfaceCount;
    int fieldsCount = 0;
    FieldWriter fieldWriter = firstField;
    while (fieldWriter != null) {
      ++fieldsCount;
      size += fieldWriter.computeFieldInfoSize();
      fieldWriter = (FieldWriter) fieldWriter.fv;
    }
    int methodsCount = 0;
    MethodWriter methodWriter = firstMethod;
    while (methodWriter != null) {
      ++methodsCount;
      size += methodWriter.computeMethodInfoSize();
      methodWriter = (MethodWriter) methodWriter.mv;
    }

    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    int attributesCount = 0;
    if (innerClasses != null) {
      ++attributesCount;
      size += 8 + innerClasses.length;
      symbolTable.addConstantUtf8(Constants.INNER_CLASSES);
    }
    if (enclosingClassIndex != 0) {
      ++attributesCount;
      size += 10;
      symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD);
    }
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {
      ++attributesCount;
      size += 6;
      symbolTable.addConstantUtf8(Constants.SYNTHETIC);
    }
    if (signatureIndex != 0) {
      ++attributesCount;
      size += 8;
      symbolTable.addConstantUtf8(Constants.SIGNATURE);
    }
    if (sourceFileIndex != 0) {
      ++attributesCount;
      size += 8;
      symbolTable.addConstantUtf8(Constants.SOURCE_FILE);
    }
    if (debugExtension != null) {
      ++attributesCount;
      size += 6 + debugExtension.length;
      symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION);
    }
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      ++attributesCount;
      size += 6;
      symbolTable.addConstantUtf8(Constants.DEPRECATED);
    }
    if (lastRuntimeVisibleAnnotation != null) {
      ++attributesCount;
      size +=
          lastRuntimeVisibleAnnotation.computeAnnotationsSize(
              Constants.RUNTIME_VISIBLE_ANNOTATIONS);
    }
    if (lastRuntimeInvisibleAnnotation != null) {
      ++attributesCount;
      size +=
          lastRuntimeInvisibleAnnotation.computeAnnotationsSize(
              Constants.RUNTIME_INVISIBLE_ANNOTATIONS);
    }
    if (lastRuntimeVisibleTypeAnnotation != null) {
      ++attributesCount;
      size +=
          lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(
              Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);
    }
    if (lastRuntimeInvisibleTypeAnnotation != null) {
      ++attributesCount;
      size +=
          lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(
              Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
    }
    if (symbolTable.computeBootstrapMethodsSize() > 0) {
      ++attributesCount;
      size += symbolTable.computeBootstrapMethodsSize();
    }
    if (moduleWriter != null) {
      attributesCount += moduleWriter.getAttributeCount();
      size += moduleWriter.computeAttributesSize();
    }
    if (nestHostClassIndex != 0) {
      ++attributesCount;
      size += 8;
      symbolTable.addConstantUtf8(Constants.NEST_HOST);
    }
    if (nestMemberClasses != null) {
      ++attributesCount;
      size += 8 + nestMemberClasses.length;
      symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);
    }
    if (permittedSubclasses != null) {
      ++attributesCount;
      size += 8 + permittedSubclasses.length;
      symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES);
    }
    int recordComponentCount = 0;
    int recordSize = 0;
    if ((accessFlags & Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {
      RecordComponentWriter recordComponentWriter = firstRecordComponent;
      while (recordComponentWriter != null) {
        ++recordComponentCount;
        recordSize += recordComponentWriter.computeRecordComponentInfoSize();
        recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
      }
      ++attributesCount;
      size += 8 + recordSize;
      symbolTable.addConstantUtf8(Constants.RECORD);
    }
    if (firstAttribute != null) {
      attributesCount += firstAttribute.getAttributeCount();
      size += firstAttribute.computeAttributesSize(symbolTable);
    }
    // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous
    // statements can add attribute names to the constant pool, thereby changing its size!
    size += symbolTable.getConstantPoolLength();
    int constantPoolCount = symbolTable.getConstantPoolCount();
    if (constantPoolCount > 0xFFFF) {
      throw new ClassTooLargeException(symbolTable.getClassName(), constantPoolCount);
    }

    // Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in
    // dynamic resizes) and fill it with the ClassFile content.
    ByteVector result = new ByteVector(size);
    result.putInt(0xCAFEBABE).putInt(version);
    symbolTable.putConstantPool(result);
    int mask = (version & 0xFFFF) < Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;
    result.putShort(accessFlags & ~mask).putShort(thisClass).putShort(superClass);
    result.putShort(interfaceCount);
    for (int i = 0; i < interfaceCount; ++i) {
      result.putShort(interfaces[i]);
    }
    result.putShort(fieldsCount);
    fieldWriter = firstField;
    while (fieldWriter != null) {
      fieldWriter.putFieldInfo(result);
      fieldWriter = (FieldWriter) fieldWriter.fv;
    }
    result.putShort(methodsCount);
    boolean hasFrames = false;
    boolean hasAsmInstructions = false;
    methodWriter = firstMethod;
    while (methodWriter != null) {
      hasFrames |= methodWriter.hasFrames();
      hasAsmInstructions |= methodWriter.hasAsmInstructions();
      methodWriter.putMethodInfo(result);
      methodWriter = (MethodWriter) methodWriter.mv;
    }
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    result.putShort(attributesCount);
    if (innerClasses != null) {
      result
          .putShort(symbolTable.addConstantUtf8(Constants.INNER_CLASSES))
          .putInt(innerClasses.length + 2)
          .putShort(numberOfInnerClasses)
          .putByteArray(innerClasses.data, 0, innerClasses.length);
    }
    if (enclosingClassIndex != 0) {
      result
          .putShort(symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD))
          .putInt(4)
          .putShort(enclosingClassIndex)
          .putShort(enclosingMethodIndex);
    }
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {
      result.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);
    }
    if (signatureIndex != 0) {
      result
          .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))
          .putInt(2)
          .putShort(signatureIndex);
    }
    if (sourceFileIndex != 0) {
      result
          .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_FILE))
          .putInt(2)
          .putShort(sourceFileIndex);
    }
    if (debugExtension != null) {
      int length = debugExtension.length;
      result
          .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION))
          .putInt(length)
          .putByteArray(debugExtension.data, 0, length);
    }
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      result.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);
    }
    AnnotationWriter.putAnnotations(
        symbolTable,
        lastRuntimeVisibleAnnotation,
        lastRuntimeInvisibleAnnotation,
        lastRuntimeVisibleTypeAnnotation,
        lastRuntimeInvisibleTypeAnnotation,
        result);
    symbolTable.putBootstrapMethods(result);
    if (moduleWriter != null) {
      moduleWriter.putAttributes(result);
    }
    if (nestHostClassIndex != 0) {
      result
          .putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST))
          .putInt(2)
          .putShort(nestHostClassIndex);
    }
    if (nestMemberClasses != null) {
      result
          .putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS))
          .putInt(nestMemberClasses.length + 2)
          .putShort(numberOfNestMemberClasses)
          .putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);
    }
    if (permittedSubclasses != null) {
      result
          .putShort(symbolTable.addConstantUtf8(Constants.PERMITTED_SUBCLASSES))
          .putInt(permittedSubclasses.length + 2)
          .putShort(numberOfPermittedSubclasses)
          .putByteArray(permittedSubclasses.data, 0, permittedSubclasses.length);
    }
    if ((accessFlags & Opcodes.ACC_RECORD) != 0 || firstRecordComponent != null) {
      result
          .putShort(symbolTable.addConstantUtf8(Constants.RECORD))
          .putInt(recordSize + 2)
          .putShort(recordComponentCount);
      RecordComponentWriter recordComponentWriter = firstRecordComponent;
      while (recordComponentWriter != null) {
        recordComponentWriter.putRecordComponentInfo(result);
        recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
      }
    }
    if (firstAttribute != null) {
      firstAttribute.putAttributes(symbolTable, result);
    }

    // Third step: replace the ASM specific instructions, if any.
    if (hasAsmInstructions) {
      return replaceAsmInstructions(result.data, hasFrames);
    } else {
      return result.data;
    }
  }

  /**
   * Returns the equivalent of the given class file, with the ASM specific instructions replaced
   * with standard ones. This is done with a ClassReader -&gt; ClassWriter round trip.
   *
   * @param classFile a class file containing ASM specific instructions, generated by this
   *     ClassWriter.
   * @param hasFrames whether there is at least one stack map frames in 'classFile'.
   * @return an equivalent of 'classFile', with the ASM specific instructions replaced with standard
   *     ones.
   */
  private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {
    final Attribute[] attributes = getAttributePrototypes();
    firstField = null;
    lastField = null;
    firstMethod = null;
    lastMethod = null;
    lastRuntimeVisibleAnnotation = null;
    lastRuntimeInvisibleAnnotation = null;
    lastRuntimeVisibleTypeAnnotation = null;
    lastRuntimeInvisibleTypeAnnotation = null;
    moduleWriter = null;
    nestHostClassIndex = 0;
    numberOfNestMemberClasses = 0;
    nestMemberClasses = null;
    numberOfPermittedSubclasses = 0;
    permittedSubclasses = null;
    firstRecordComponent = null;
    lastRecordComponent = null;
    firstAttribute = null;
    compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;
    new ClassReader(classFile, 0, /* checkClassVersion= */ false)
        .accept(
            this,
            attributes,
            (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);
    return toByteArray();
  }

  /**
   * Returns the prototypes of the attributes used by this class, its fields and its methods.
   *
   * @return the prototypes of the attributes used by this class, its fields and its methods.
   */
  private Attribute[] getAttributePrototypes() {
    Attribute.Set attributePrototypes = new Attribute.Set();
    attributePrototypes.addAttributes(firstAttribute);
    FieldWriter fieldWriter = firstField;
    while (fieldWriter != null) {
      fieldWriter.collectAttributePrototypes(attributePrototypes);
      fieldWriter = (FieldWriter) fieldWriter.fv;
    }
    MethodWriter methodWriter = firstMethod;
    while (methodWriter != null) {
      methodWriter.collectAttributePrototypes(attributePrototypes);
      methodWriter = (MethodWriter) methodWriter.mv;
    }
    RecordComponentWriter recordComponentWriter = firstRecordComponent;
    while (recordComponentWriter != null) {
      recordComponentWriter.collectAttributePrototypes(attributePrototypes);
      recordComponentWriter = (RecordComponentWriter) recordComponentWriter.delegate;
    }
    return attributePrototypes.toArray();
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods: constant pool management for Attribute sub classes
  // -----------------------------------------------------------------------------------------------

  /**
   * Adds a number or string constant to the constant pool of the class being build. Does nothing if
   * the constant pool already contains a similar item. <i>This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param value the value of the constant to be added to the constant pool. This parameter must be
   *     an {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.
   * @return the index of a new or already existing constant item with the given value.
   */
  public int newConst(final Object value) {
    return symbolTable.addConstant(value).index;
  }

  /**
   * Adds an UTF8 string to the constant pool of the class being build. Does nothing if the constant
   * pool already contains a similar item. <i>This method is intended for {@link Attribute} sub
   * classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param value the String value.
   * @return the index of a new or already existing UTF8 item.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  public int newUTF8(final String value) {
    return symbolTable.addConstantUtf8(value);
  }

  /**
   * Adds a class reference to the constant pool of the class being build. Does nothing if the
   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}
   * sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param value the internal name of the class (see {@link Type#getInternalName()}).
   * @return the index of a new or already existing class reference item.
   */
  public int newClass(final @InternalForm String value) {
    return symbolTable.addConstantClass(value).index;
  }

  /**
   * Adds a method type reference to the constant pool of the class being build. Does nothing if the
   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}
   * sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param methodDescriptor method descriptor of the method type.
   * @return the index of a new or already existing method type reference item.
   */
  public int newMethodType(final String methodDescriptor) {
    return symbolTable.addConstantMethodType(methodDescriptor).index;
  }

  /**
   * Adds a module reference to the constant pool of the class being build. Does nothing if the
   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}
   * sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param moduleName name of the module.
   * @return the index of a new or already existing module reference item.
   */
  public int newModule(final String moduleName) {
    return symbolTable.addConstantModule(moduleName).index;
  }

  /**
   * Adds a package reference to the constant pool of the class being build. Does nothing if the
   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}
   * sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param packageName name of the package in its internal form.
   * @return the index of a new or already existing module reference item.
   */
  public int newPackage(final String packageName) {
    return symbolTable.addConstantPackage(packageName).index;
  }

  /**
   * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool
   * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,
   * and is normally not needed by class generators or adapters.</i>
   *
   * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link
   *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link
   *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},
   *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   * @param owner the internal name of the field or method owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the name of the field or method.
   * @param descriptor the descriptor of the field or method.
   * @return the index of a new or already existing method type reference item.
   * @deprecated this method is superseded by {@link #newHandle(int, String, String, String,
   *     boolean)}.
   */
  @Deprecated
  public int newHandle(
      final int tag, final @InternalForm String owner, final String name, final String descriptor) {
    return newHandle(tag, owner, name, descriptor, tag == Opcodes.H_INVOKEINTERFACE);
  }

  /**
   * Adds a handle to the constant pool of the class being build. Does nothing if the constant pool
   * already contains a similar item. <i>This method is intended for {@link Attribute} sub classes,
   * and is normally not needed by class generators or adapters.</i>
   *
   * @param tag the kind of this handle. Must be {@link Opcodes#H_GETFIELD}, {@link
   *     Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link
   *     Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},
   *     {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   * @param owner the internal name of the field or method owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the name of the field or method.
   * @param descriptor the descriptor of the field or method.
   * @param isInterface true if the owner is an interface.
   * @return the index of a new or already existing method type reference item.
   */
  public int newHandle(
      final int tag,
      final @InternalForm String owner,
      final String name,
      final String descriptor,
      final boolean isInterface) {
    return symbolTable.addConstantMethodHandle(tag, owner, name, descriptor, isInterface).index;
  }

  /**
   * Adds a dynamic constant reference to the constant pool of the class being build. Does nothing
   * if the constant pool already contains a similar item. <i>This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param name name of the invoked method.
   * @param descriptor field descriptor of the constant type.
   * @param bootstrapMethodHandle the bootstrap method.
   * @param bootstrapMethodArguments the bootstrap method constant arguments.
   * @return the index of a new or already existing dynamic constant reference item.
   */
  public int newConstantDynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    return symbolTable.addConstantDynamic(
            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)
        .index;
  }

  /**
   * Adds an invokedynamic reference to the constant pool of the class being build. Does nothing if
   * the constant pool already contains a similar item. <i>This method is intended for {@link
   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param name name of the invoked method.
   * @param descriptor descriptor of the invoke method.
   * @param bootstrapMethodHandle the bootstrap method.
   * @param bootstrapMethodArguments the bootstrap method constant arguments.
   * @return the index of a new or already existing invokedynamic reference item.
   */
  public int newInvokeDynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    return symbolTable.addConstantInvokeDynamic(
            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)
        .index;
  }

  /**
   * Adds a field reference to the constant pool of the class being build. Does nothing if the
   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}
   * sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).
   * @param name the field's name.
   * @param descriptor the field's descriptor.
   * @return the index of a new or already existing field reference item.
   */
  public int newField(final @InternalForm String owner, final String name, final String descriptor) {
    return symbolTable.addConstantFieldref(owner, name, descriptor).index;
  }

  /**
   * Adds a method reference to the constant pool of the class being build. Does nothing if the
   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}
   * sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor.
   * @param isInterface {@literal true} if {@code owner} is an interface.
   * @return the index of a new or already existing method reference item.
   */
  public int newMethod(
      final @InternalForm String owner, final String name, final String descriptor, final boolean isInterface) {
    return symbolTable.addConstantMethodref(owner, name, descriptor, isInterface).index;
  }

  /**
   * Adds a name and type to the constant pool of the class being build. Does nothing if the
   * constant pool already contains a similar item. <i>This method is intended for {@link Attribute}
   * sub classes, and is normally not needed by class generators or adapters.</i>
   *
   * @param name a name.
   * @param descriptor a type descriptor.
   * @return the index of a new or already existing name and type item.
   */
  public int newNameType(final String name, final String descriptor) {
    return symbolTable.addConstantNameAndType(name, descriptor);
  }

  /**
   * Changes the computation strategy of method properties like max stack size, max number of local
   * variables, and frames.
   *
   * <p><b>WARNING</b>: {@link #setFlags(int)} method changes the behavior of new method visitors
   * returned from {@link #visitMethod(int, String, String, String, String[])}. The behavior will be
   * changed only after the next method visitor is returned. All the previously returned method
   * visitors keep their previous behavior.
   *
   * @param flags option flags that can be used to modify the default behavior of this class. Must
   *     be zero or more of {@link #COMPUTE_MAXS} and {@link #COMPUTE_FRAMES}.
   */
  public final void setFlags(final int flags) {
    if ((flags & ClassWriter.COMPUTE_FRAMES) != 0) {
      compute = MethodWriter.COMPUTE_ALL_FRAMES;
    } else if ((flags & ClassWriter.COMPUTE_MAXS) != 0) {
      compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL;
    } else {
      compute = MethodWriter.COMPUTE_NOTHING;
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Default method to compute common super classes when computing stack map frames
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the common super type of the two given types. The default implementation of this method
   * <i>loads</i> the two given classes and uses the java.lang.Class methods to find the common
   * super class. It can be overridden to compute this common super type in other ways, in
   * particular without actually loading any class, or to take into account the class that is
   * currently being generated by this ClassWriter, which can of course not be loaded since it is
   * under construction.
   *
   * @param type1 the internal name of a class (see {@link Type#getInternalName()}).
   * @param type2 the internal name of another class (see {@link Type#getInternalName()}).
   * @return the internal name of the common super class of the two given classes (see {@link
   *     Type#getInternalName()}).
   */
  protected @InternalForm String getCommonSuperClass(final @InternalForm String type1, final @InternalForm String type2) {
    ClassLoader classLoader = getClassLoader();
    Class<?> class1;
    try {
      class1 = Class.forName(type1.replace('/', '.'), false, classLoader);
    } catch (ClassNotFoundException e) {
      throw new TypeNotPresentException(type1, e);
    }
    Class<?> class2;
    try {
      class2 = Class.forName(type2.replace('/', '.'), false, classLoader);
    } catch (ClassNotFoundException e) {
      throw new TypeNotPresentException(type2, e);
    }
    if (class1.isAssignableFrom(class2)) {
      return type1;
    }
    if (class2.isAssignableFrom(class1)) {
      return type2;
    }
    if (class1.isInterface() || class2.isInterface()) {
      return "java/lang/Object";
    } else {
      do {
        class1 = class1.getSuperclass();
      } while (!class1.isAssignableFrom(class2));
      return class1.getName().replace('.', '/');
    }
  }

  /**
   * Returns the {@link ClassLoader} to be used by the default implementation of {@link
   * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by
   * default.
   *
   * @return ClassLoader
   */
  protected ClassLoader getClassLoader() {
    return getClass().getClassLoader();
  }
}

package org.objectweb.asm;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.regex.Pattern;

/**
 * Defines additional JVM opcodes, access flags and constants which are not part of the ASM public
 * API.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html">JVMS 6</a>
 * @author Eric Bruneton
 */
final class Constants {

  // The ClassFile attribute names, in the order they are defined in
  // https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.7-300.

  static final String CONSTANT_VALUE = "ConstantValue";
  static final String CODE = "Code";
  static final String STACK_MAP_TABLE = "StackMapTable";
  static final String EXCEPTIONS = "Exceptions";
  static final String INNER_CLASSES = "InnerClasses";
  static final String ENCLOSING_METHOD = "EnclosingMethod";
  static final String SYNTHETIC = "Synthetic";
  static final String SIGNATURE = "Signature";
  static final String SOURCE_FILE = "SourceFile";
  static final String SOURCE_DEBUG_EXTENSION = "SourceDebugExtension";
  static final String LINE_NUMBER_TABLE = "LineNumberTable";
  static final String LOCAL_VARIABLE_TABLE = "LocalVariableTable";
  static final String LOCAL_VARIABLE_TYPE_TABLE = "LocalVariableTypeTable";
  static final String DEPRECATED = "Deprecated";
  static final String RUNTIME_VISIBLE_ANNOTATIONS = "RuntimeVisibleAnnotations";
  static final String RUNTIME_INVISIBLE_ANNOTATIONS = "RuntimeInvisibleAnnotations";
  static final String RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = "RuntimeVisibleParameterAnnotations";
  static final String RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS =
      "RuntimeInvisibleParameterAnnotations";
  static final String RUNTIME_VISIBLE_TYPE_ANNOTATIONS = "RuntimeVisibleTypeAnnotations";
  static final String RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = "RuntimeInvisibleTypeAnnotations";
  static final String ANNOTATION_DEFAULT = "AnnotationDefault";
  static final String BOOTSTRAP_METHODS = "BootstrapMethods";
  static final String METHOD_PARAMETERS = "MethodParameters";
  static final String MODULE = "Module";
  static final String MODULE_PACKAGES = "ModulePackages";
  static final String MODULE_MAIN_CLASS = "ModuleMainClass";
  static final String NEST_HOST = "NestHost";
  static final String NEST_MEMBERS = "NestMembers";
  static final String PERMITTED_SUBCLASSES = "PermittedSubclasses";
  static final String RECORD = "Record";

  // ASM specific access flags.
  // WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard
  // access flags, and also to make sure that these flags are automatically filtered out when
  // written in class files (because access flags are stored using 16 bits only).

  static final int ACC_CONSTRUCTOR = 0x40000; // method access flag.

  // ASM specific stack map frame types, used in {@link ClassVisitor#visitFrame}.

  /**
   * A frame inserted between already existing frames. This internal stack map frame type (in
   * addition to the ones declared in {@link Opcodes}) can only be used if the frame content can be
   * computed from the previous existing frame and from the instructions between this existing frame
   * and the inserted one, without any knowledge of the type hierarchy. This kind of frame is only
   * used when an unconditional jump is inserted in a method while expanding an ASM specific
   * instruction. Keep in sync with Opcodes.java.
   */
  static final int F_INSERT = 256;

  // The JVM opcode values which are not part of the ASM public API.
  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html.

  static final int LDC_W = 19;
  static final int LDC2_W = 20;
  static final int ILOAD_0 = 26;
  static final int ILOAD_1 = 27;
  static final int ILOAD_2 = 28;
  static final int ILOAD_3 = 29;
  static final int LLOAD_0 = 30;
  static final int LLOAD_1 = 31;
  static final int LLOAD_2 = 32;
  static final int LLOAD_3 = 33;
  static final int FLOAD_0 = 34;
  static final int FLOAD_1 = 35;
  static final int FLOAD_2 = 36;
  static final int FLOAD_3 = 37;
  static final int DLOAD_0 = 38;
  static final int DLOAD_1 = 39;
  static final int DLOAD_2 = 40;
  static final int DLOAD_3 = 41;
  static final int ALOAD_0 = 42;
  static final int ALOAD_1 = 43;
  static final int ALOAD_2 = 44;
  static final int ALOAD_3 = 45;
  static final int ISTORE_0 = 59;
  static final int ISTORE_1 = 60;
  static final int ISTORE_2 = 61;
  static final int ISTORE_3 = 62;
  static final int LSTORE_0 = 63;
  static final int LSTORE_1 = 64;
  static final int LSTORE_2 = 65;
  static final int LSTORE_3 = 66;
  static final int FSTORE_0 = 67;
  static final int FSTORE_1 = 68;
  static final int FSTORE_2 = 69;
  static final int FSTORE_3 = 70;
  static final int DSTORE_0 = 71;
  static final int DSTORE_1 = 72;
  static final int DSTORE_2 = 73;
  static final int DSTORE_3 = 74;
  static final int ASTORE_0 = 75;
  static final int ASTORE_1 = 76;
  static final int ASTORE_2 = 77;
  static final int ASTORE_3 = 78;
  static final int WIDE = 196;
  static final int GOTO_W = 200;
  static final int JSR_W = 201;

  // Constants to convert between normal and wide jump instructions.

  // The delta between the GOTO_W and JSR_W opcodes and GOTO and JUMP.
  static final int WIDE_JUMP_OPCODE_DELTA = GOTO_W - Opcodes.GOTO;

  // Constants to convert JVM opcodes to the equivalent ASM specific opcodes, and vice versa.

  // The delta between the ASM_IFEQ, ..., ASM_IF_ACMPNE, ASM_GOTO and ASM_JSR opcodes
  // and IFEQ, ..., IF_ACMPNE, GOTO and JSR.
  static final int ASM_OPCODE_DELTA = 49;

  // The delta between the ASM_IFNULL and ASM_IFNONNULL opcodes and IFNULL and IFNONNULL.
  static final int ASM_IFNULL_OPCODE_DELTA = 20;

  // ASM specific opcodes, used for long forward jump instructions.

  static final int ASM_IFEQ = Opcodes.IFEQ + ASM_OPCODE_DELTA;
  static final int ASM_IFNE = Opcodes.IFNE + ASM_OPCODE_DELTA;
  static final int ASM_IFLT = Opcodes.IFLT + ASM_OPCODE_DELTA;
  static final int ASM_IFGE = Opcodes.IFGE + ASM_OPCODE_DELTA;
  static final int ASM_IFGT = Opcodes.IFGT + ASM_OPCODE_DELTA;
  static final int ASM_IFLE = Opcodes.IFLE + ASM_OPCODE_DELTA;
  static final int ASM_IF_ICMPEQ = Opcodes.IF_ICMPEQ + ASM_OPCODE_DELTA;
  static final int ASM_IF_ICMPNE = Opcodes.IF_ICMPNE + ASM_OPCODE_DELTA;
  static final int ASM_IF_ICMPLT = Opcodes.IF_ICMPLT + ASM_OPCODE_DELTA;
  static final int ASM_IF_ICMPGE = Opcodes.IF_ICMPGE + ASM_OPCODE_DELTA;
  static final int ASM_IF_ICMPGT = Opcodes.IF_ICMPGT + ASM_OPCODE_DELTA;
  static final int ASM_IF_ICMPLE = Opcodes.IF_ICMPLE + ASM_OPCODE_DELTA;
  static final int ASM_IF_ACMPEQ = Opcodes.IF_ACMPEQ + ASM_OPCODE_DELTA;
  static final int ASM_IF_ACMPNE = Opcodes.IF_ACMPNE + ASM_OPCODE_DELTA;
  static final int ASM_GOTO = Opcodes.GOTO + ASM_OPCODE_DELTA;
  static final int ASM_JSR = Opcodes.JSR + ASM_OPCODE_DELTA;
  static final int ASM_IFNULL = Opcodes.IFNULL + ASM_IFNULL_OPCODE_DELTA;
  static final int ASM_IFNONNULL = Opcodes.IFNONNULL + ASM_IFNULL_OPCODE_DELTA;
  static final int ASM_GOTO_W = 220;

  private Constants() {}

  static void checkAsmExperimental(final Object caller) {
    Class<?> callerClass = caller.getClass();
    String internalName = callerClass.getName().replace('.', '/');
    if (!isWhitelisted(internalName)) {
      checkIsPreview(callerClass.getClassLoader().getResourceAsStream(internalName + ".class"));
    }
  }

  static boolean isWhitelisted(final @InternalForm String internalName) {
    if (!internalName.startsWith("org/objectweb/asm/")) {
      return false;
    }
    String member = "(Annotation|Class|Field|Method|Module|RecordComponent|Signature)";
    return internalName.contains("Test$")
        || Pattern.matches(
            "org/objectweb/asm/util/Trace" + member + "Visitor(\\$.*)?", internalName)
        || Pattern.matches(
            "org/objectweb/asm/util/Check" + member + "Adapter(\\$.*)?", internalName);
  }

  static void checkIsPreview(final InputStream classInputStream) {
    if (classInputStream == null) {
      throw new IllegalStateException("Bytecode not available, can't check class version");
    }
    int minorVersion;
    try (DataInputStream callerClassStream = new DataInputStream(classInputStream); ) {
      callerClassStream.readInt();
      minorVersion = callerClassStream.readUnsignedShort();
    } catch (IOException ioe) {
      throw new IllegalStateException("I/O error, can't check class version", ioe);
    }
    if (minorVersion != 0xFFFF) {
      throw new IllegalStateException(
          "ASM10_EXPERIMENTAL can only be used by classes compiled with --enable-preview");
    }
  }
}


package org.objectweb.asm;

/**
 * Information about a class being parsed in a {@link ClassReader}.
 *
 * @author Eric Bruneton
 */
final class Context {

  /** The prototypes of the attributes that must be parsed in this class. */
  Attribute[] attributePrototypes;

  /**
   * The options used to parse this class. One or more of {@link ClassReader#SKIP_CODE}, {@link
   * ClassReader#SKIP_DEBUG}, {@link ClassReader#SKIP_FRAMES}, {@link ClassReader#EXPAND_FRAMES} or
   * {@link ClassReader#EXPAND_ASM_INSNS}.
   */
  int parsingOptions;

  /** The buffer used to read strings in the constant pool. */
  char[] charBuffer;

  // Information about the current method, i.e. the one read in the current (or latest) call
  // to {@link ClassReader#readMethod()}.

  /** The access flags of the current method. */
  int currentMethodAccessFlags;

  /** The name of the current method. */
  String currentMethodName;

  /** The descriptor of the current method. */
  String currentMethodDescriptor;

  /**
   * The labels of the current method, indexed by bytecode offset (only bytecode offsets for which a
   * label is needed have a non null associated Label).
   */
  Label[] currentMethodLabels;

  // Information about the current type annotation target, i.e. the one read in the current
  // (or latest) call to {@link ClassReader#readAnnotationTarget()}.

  /**
   * The target_type and target_info of the current type annotation target, encoded as described in
   * {@link TypeReference}.
   */
  int currentTypeAnnotationTarget;

  /** The target_path of the current type annotation target. */
  TypePath currentTypeAnnotationTargetPath;

  /** The start of each local variable range in the current local variable annotation. */
  Label[] currentLocalVariableAnnotationRangeStarts;

  /** The end of each local variable range in the current local variable annotation. */
  Label[] currentLocalVariableAnnotationRangeEnds;

  /**
   * The local variable index of each local variable range in the current local variable annotation.
   */
  int[] currentLocalVariableAnnotationRangeIndices;

  // Information about the current stack map frame, i.e. the one read in the current (or latest)
  // call to {@link ClassReader#readFrame()}.

  /** The bytecode offset of the current stack map frame. */
  int currentFrameOffset;

  /**
   * The type of the current stack map frame. One of {@link Opcodes#F_FULL}, {@link
   * Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or {@link Opcodes#F_SAME1}.
   */
  int currentFrameType;

  /**
   * The number of local variable types in the current stack map frame. Each type is represented
   * with a single array element (even long and double).
   */
  int currentFrameLocalCount;

  /**
   * The delta number of local variable types in the current stack map frame (each type is
   * represented with a single array element - even long and double). This is the number of local
   * variable types in this frame, minus the number of local variable types in the previous frame.
   */
  int currentFrameLocalCountDelta;

  /**
   * The types of the local variables in the current stack map frame. Each type is represented with
   * a single array element (even long and double), using the format described in {@link
   * MethodVisitor#visitFrame}. Depending on {@link #currentFrameType}, this contains the types of
   * all the local variables, or only those of the additional ones (compared to the previous frame).
   */
  Object[] currentFrameLocalTypes;

  /**
   * The number stack element types in the current stack map frame. Each type is represented with a
   * single array element (even long and double).
   */
  int currentFrameStackCount;

  /**
   * The types of the stack elements in the current stack map frame. Each type is represented with a
   * single array element (even long and double), using the format described in {@link
   * MethodVisitor#visitFrame}.
   */
  Object[] currentFrameStackTypes;
}


package org.objectweb.asm;

/**
 * A reference to a type appearing in a class, field or method declaration, or on an instruction.
 * Such a reference designates the part of the class where the referenced type is appearing (e.g. an
 * 'extends', 'implements' or 'throws' clause, a 'new' instruction, a 'catch' clause, a type cast, a
 * local variable declaration, etc).
 *
 * @author Eric Bruneton
 */
public class TypeReference {

  /**
   * The sort of type references that target a type parameter of a generic class. See {@link
   * #getSort}.
   */
  public static final int CLASS_TYPE_PARAMETER = 0x00;

  /**
   * The sort of type references that target a type parameter of a generic method. See {@link
   * #getSort}.
   */
  public static final int METHOD_TYPE_PARAMETER = 0x01;

  /**
   * The sort of type references that target the super class of a class or one of the interfaces it
   * implements. See {@link #getSort}.
   */
  public static final int CLASS_EXTENDS = 0x10;

  /**
   * The sort of type references that target a bound of a type parameter of a generic class. See
   * {@link #getSort}.
   */
  public static final int CLASS_TYPE_PARAMETER_BOUND = 0x11;

  /**
   * The sort of type references that target a bound of a type parameter of a generic method. See
   * {@link #getSort}.
   */
  public static final int METHOD_TYPE_PARAMETER_BOUND = 0x12;

  /** The sort of type references that target the type of a field. See {@link #getSort}. */
  public static final int FIELD = 0x13;

  /** The sort of type references that target the return type of a method. See {@link #getSort}. */
  public static final int METHOD_RETURN = 0x14;

  /**
   * The sort of type references that target the receiver type of a method. See {@link #getSort}.
   */
  public static final int METHOD_RECEIVER = 0x15;

  /**
   * The sort of type references that target the type of a formal parameter of a method. See {@link
   * #getSort}.
   */
  public static final int METHOD_FORMAL_PARAMETER = 0x16;

  /**
   * The sort of type references that target the type of an exception declared in the throws clause
   * of a method. See {@link #getSort}.
   */
  public static final int THROWS = 0x17;

  /**
   * The sort of type references that target the type of a local variable in a method. See {@link
   * #getSort}.
   */
  public static final int LOCAL_VARIABLE = 0x40;

  /**
   * The sort of type references that target the type of a resource variable in a method. See {@link
   * #getSort}.
   */
  public static final int RESOURCE_VARIABLE = 0x41;

  /**
   * The sort of type references that target the type of the exception of a 'catch' clause in a
   * method. See {@link #getSort}.
   */
  public static final int EXCEPTION_PARAMETER = 0x42;

  /**
   * The sort of type references that target the type declared in an 'instanceof' instruction. See
   * {@link #getSort}.
   */
  public static final int INSTANCEOF = 0x43;

  /**
   * The sort of type references that target the type of the object created by a 'new' instruction.
   * See {@link #getSort}.
   */
  public static final int NEW = 0x44;

  /**
   * The sort of type references that target the receiver type of a constructor reference. See
   * {@link #getSort}.
   */
  public static final int CONSTRUCTOR_REFERENCE = 0x45;

  /**
   * The sort of type references that target the receiver type of a method reference. See {@link
   * #getSort}.
   */
  public static final int METHOD_REFERENCE = 0x46;

  /**
   * The sort of type references that target the type declared in an explicit or implicit cast
   * instruction. See {@link #getSort}.
   */
  public static final int CAST = 0x47;

  /**
   * The sort of type references that target a type parameter of a generic constructor in a
   * constructor call. See {@link #getSort}.
   */
  public static final int CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 0x48;

  /**
   * The sort of type references that target a type parameter of a generic method in a method call.
   * See {@link #getSort}.
   */
  public static final int METHOD_INVOCATION_TYPE_ARGUMENT = 0x49;

  /**
   * The sort of type references that target a type parameter of a generic constructor in a
   * constructor reference. See {@link #getSort}.
   */
  public static final int CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = 0x4A;

  /**
   * The sort of type references that target a type parameter of a generic method in a method
   * reference. See {@link #getSort}.
   */
  public static final int METHOD_REFERENCE_TYPE_ARGUMENT = 0x4B;

  /**
   * The target_type and target_info structures - as defined in the Java Virtual Machine
   * Specification (JVMS) - corresponding to this type reference. target_type uses one byte, and all
   * the target_info union fields use up to 3 bytes (except localvar_target, handled with the
   * specific method {@link MethodVisitor#visitLocalVariableAnnotation}). Thus, both structures can
   * be stored in an int.
   *
   * <p>This int field stores target_type (called the TypeReference 'sort' in the public API of this
   * class) in its most significant byte, followed by the target_info fields. Depending on
   * target_type, 1, 2 or even 3 least significant bytes of this field are unused. target_info
   * fields which reference bytecode offsets are set to 0 (these offsets are ignored in ClassReader,
   * and recomputed in MethodWriter).
   *
   * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20">JVMS
   *     4.7.20</a>
   * @see <a
   *     href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1">JVMS
   *     4.7.20.1</a>
   */
  private final int targetTypeAndInfo;

  /**
   * Constructs a new TypeReference.
   *
   * @param typeRef the int encoded value of the type reference, as received in a visit method
   *     related to type annotations, such as {@link ClassVisitor#visitTypeAnnotation}.
   */
  public TypeReference(final int typeRef) {
    this.targetTypeAndInfo = typeRef;
  }

  /**
   * Returns a type reference of the given sort.
   *
   * @param sort one of {@link #FIELD}, {@link #METHOD_RETURN}, {@link #METHOD_RECEIVER}, {@link
   *     #LOCAL_VARIABLE}, {@link #RESOURCE_VARIABLE}, {@link #INSTANCEOF}, {@link #NEW}, {@link
   *     #CONSTRUCTOR_REFERENCE}, or {@link #METHOD_REFERENCE}.
   * @return a type reference of the given sort.
   */
  public static TypeReference newTypeReference(final int sort) {
    return new TypeReference(sort << 24);
  }

  /**
   * Returns a reference to a type parameter of a generic class or method.
   *
   * @param sort one of {@link #CLASS_TYPE_PARAMETER} or {@link #METHOD_TYPE_PARAMETER}.
   * @param paramIndex the type parameter index.
   * @return a reference to the given generic class or method type parameter.
   */
  public static TypeReference newTypeParameterReference(final int sort, final int paramIndex) {
    return new TypeReference((sort << 24) | (paramIndex << 16));
  }

  /**
   * Returns a reference to a type parameter bound of a generic class or method.
   *
   * @param sort one of {@link #CLASS_TYPE_PARAMETER} or {@link #METHOD_TYPE_PARAMETER}.
   * @param paramIndex the type parameter index.
   * @param boundIndex the type bound index within the above type parameters.
   * @return a reference to the given generic class or method type parameter bound.
   */
  public static TypeReference newTypeParameterBoundReference(
      final int sort, final int paramIndex, final int boundIndex) {
    return new TypeReference((sort << 24) | (paramIndex << 16) | (boundIndex << 8));
  }

  /**
   * Returns a reference to the super class or to an interface of the 'implements' clause of a
   * class.
   *
   * @param itfIndex the index of an interface in the 'implements' clause of a class, or -1 to
   *     reference the super class of the class.
   * @return a reference to the given super type of a class.
   */
  public static TypeReference newSuperTypeReference(final int itfIndex) {
    return new TypeReference((CLASS_EXTENDS << 24) | ((itfIndex & 0xFFFF) << 8));
  }

  /**
   * Returns a reference to the type of a formal parameter of a method.
   *
   * @param paramIndex the formal parameter index.
   * @return a reference to the type of the given method formal parameter.
   */
  public static TypeReference newFormalParameterReference(final int paramIndex) {
    return new TypeReference((METHOD_FORMAL_PARAMETER << 24) | (paramIndex << 16));
  }

  /**
   * Returns a reference to the type of an exception, in a 'throws' clause of a method.
   *
   * @param exceptionIndex the index of an exception in a 'throws' clause of a method.
   * @return a reference to the type of the given exception.
   */
  public static TypeReference newExceptionReference(final int exceptionIndex) {
    return new TypeReference((THROWS << 24) | (exceptionIndex << 8));
  }

  /**
   * Returns a reference to the type of the exception declared in a 'catch' clause of a method.
   *
   * @param tryCatchBlockIndex the index of a try catch block (using the order in which they are
   *     visited with visitTryCatchBlock).
   * @return a reference to the type of the given exception.
   */
  public static TypeReference newTryCatchReference(final int tryCatchBlockIndex) {
    return new TypeReference((EXCEPTION_PARAMETER << 24) | (tryCatchBlockIndex << 8));
  }

  /**
   * Returns a reference to the type of a type argument in a constructor or method call or
   * reference.
   *
   * @param sort one of {@link #CAST}, {@link #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link
   *     #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link
   *     #METHOD_REFERENCE_TYPE_ARGUMENT}.
   * @param argIndex the type argument index.
   * @return a reference to the type of the given type argument.
   */
  public static TypeReference newTypeArgumentReference(final int sort, final int argIndex) {
    return new TypeReference((sort << 24) | argIndex);
  }

  /**
   * Returns the sort of this type reference.
   *
   * @return one of {@link #CLASS_TYPE_PARAMETER}, {@link #METHOD_TYPE_PARAMETER}, {@link
   *     #CLASS_EXTENDS}, {@link #CLASS_TYPE_PARAMETER_BOUND}, {@link #METHOD_TYPE_PARAMETER_BOUND},
   *     {@link #FIELD}, {@link #METHOD_RETURN}, {@link #METHOD_RECEIVER}, {@link
   *     #METHOD_FORMAL_PARAMETER}, {@link #THROWS}, {@link #LOCAL_VARIABLE}, {@link
   *     #RESOURCE_VARIABLE}, {@link #EXCEPTION_PARAMETER}, {@link #INSTANCEOF}, {@link #NEW},
   *     {@link #CONSTRUCTOR_REFERENCE}, {@link #METHOD_REFERENCE}, {@link #CAST}, {@link
   *     #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link
   *     #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link #METHOD_REFERENCE_TYPE_ARGUMENT}.
   */
  public int getSort() {
    return targetTypeAndInfo >>> 24;
  }

  /**
   * Returns the index of the type parameter referenced by this type reference. This method must
   * only be used for type references whose sort is {@link #CLASS_TYPE_PARAMETER}, {@link
   * #METHOD_TYPE_PARAMETER}, {@link #CLASS_TYPE_PARAMETER_BOUND} or {@link
   * #METHOD_TYPE_PARAMETER_BOUND}.
   *
   * @return a type parameter index.
   */
  public int getTypeParameterIndex() {
    return (targetTypeAndInfo & 0x00FF0000) >> 16;
  }

  /**
   * Returns the index of the type parameter bound, within the type parameter {@link
   * #getTypeParameterIndex}, referenced by this type reference. This method must only be used for
   * type references whose sort is {@link #CLASS_TYPE_PARAMETER_BOUND} or {@link
   * #METHOD_TYPE_PARAMETER_BOUND}.
   *
   * @return a type parameter bound index.
   */
  public int getTypeParameterBoundIndex() {
    return (targetTypeAndInfo & 0x0000FF00) >> 8;
  }

  /**
   * Returns the index of the "super type" of a class that is referenced by this type reference.
   * This method must only be used for type references whose sort is {@link #CLASS_EXTENDS}.
   *
   * @return the index of an interface in the 'implements' clause of a class, or -1 if this type
   *     reference references the type of the super class.
   */
  public int getSuperTypeIndex() {
    return (short) ((targetTypeAndInfo & 0x00FFFF00) >> 8);
  }

  /**
   * Returns the index of the formal parameter whose type is referenced by this type reference. This
   * method must only be used for type references whose sort is {@link #METHOD_FORMAL_PARAMETER}.
   *
   * @return a formal parameter index.
   */
  public int getFormalParameterIndex() {
    return (targetTypeAndInfo & 0x00FF0000) >> 16;
  }

  /**
   * Returns the index of the exception, in a 'throws' clause of a method, whose type is referenced
   * by this type reference. This method must only be used for type references whose sort is {@link
   * #THROWS}.
   *
   * @return the index of an exception in the 'throws' clause of a method.
   */
  public int getExceptionIndex() {
    return (targetTypeAndInfo & 0x00FFFF00) >> 8;
  }

  /**
   * Returns the index of the try catch block (using the order in which they are visited with
   * visitTryCatchBlock), whose 'catch' type is referenced by this type reference. This method must
   * only be used for type references whose sort is {@link #EXCEPTION_PARAMETER} .
   *
   * @return the index of an exception in the 'throws' clause of a method.
   */
  public int getTryCatchBlockIndex() {
    return (targetTypeAndInfo & 0x00FFFF00) >> 8;
  }

  /**
   * Returns the index of the type argument referenced by this type reference. This method must only
   * be used for type references whose sort is {@link #CAST}, {@link
   * #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link
   * #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link #METHOD_REFERENCE_TYPE_ARGUMENT}.
   *
   * @return a type parameter index.
   */
  public int getTypeArgumentIndex() {
    return targetTypeAndInfo & 0xFF;
  }

  /**
   * Returns the int encoded value of this type reference, suitable for use in visit methods related
   * to type annotations, like visitTypeAnnotation.
   *
   * @return the int encoded value of this type reference.
   */
  public int getValue() {
    return targetTypeAndInfo;
  }

  /**
   * Puts the given target_type and target_info JVMS structures into the given ByteVector.
   *
   * @param targetTypeAndInfo a target_type and a target_info structures encoded as in {@link
   *     #targetTypeAndInfo}. LOCAL_VARIABLE and RESOURCE_VARIABLE target types are not supported.
   * @param output where the type reference must be put.
   */
  static void putTarget(final int targetTypeAndInfo, final ByteVector output) {
    switch (targetTypeAndInfo >>> 24) {
      case CLASS_TYPE_PARAMETER:
      case METHOD_TYPE_PARAMETER:
      case METHOD_FORMAL_PARAMETER:
        output.putShort(targetTypeAndInfo >>> 16);
        break;
      case FIELD:
      case METHOD_RETURN:
      case METHOD_RECEIVER:
        output.putByte(targetTypeAndInfo >>> 24);
        break;
      case CAST:
      case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
      case METHOD_INVOCATION_TYPE_ARGUMENT:
      case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
      case METHOD_REFERENCE_TYPE_ARGUMENT:
        output.putInt(targetTypeAndInfo);
        break;
      case CLASS_EXTENDS:
      case CLASS_TYPE_PARAMETER_BOUND:
      case METHOD_TYPE_PARAMETER_BOUND:
      case THROWS:
      case EXCEPTION_PARAMETER:
      case INSTANCEOF:
      case NEW:
      case CONSTRUCTOR_REFERENCE:
      case METHOD_REFERENCE:
        output.put12(targetTypeAndInfo >>> 24, (targetTypeAndInfo & 0xFFFF00) >> 8);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }
}

package org.objectweb.asm;

/**
 * An {@link AnnotationVisitor} that generates a corresponding 'annotation' or 'type_annotation'
 * structure, as defined in the Java Virtual Machine Specification (JVMS). AnnotationWriter
 * instances can be chained in a doubly linked list, from which Runtime[In]Visible[Type]Annotations
 * attributes can be generated with the {@link #putAnnotations} method. Similarly, arrays of such
 * lists can be used to generate Runtime[In]VisibleParameterAnnotations attributes.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16">JVMS
 *     4.7.16</a>
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20">JVMS
 *     4.7.20</a>
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
final class AnnotationWriter extends AnnotationVisitor {

  /** Where the constants used in this AnnotationWriter must be stored. */
  private final SymbolTable symbolTable;

  /**
   * Whether values are named or not. AnnotationWriter instances used for annotation default and
   * annotation arrays use unnamed values (i.e. they generate an 'element_value' structure for each
   * value, instead of an element_name_index followed by an element_value).
   */
  private final boolean useNamedValues;

  /**
   * The 'annotation' or 'type_annotation' JVMS structure corresponding to the annotation values
   * visited so far. All the fields of these structures, except the last one - the
   * element_value_pairs array, must be set before this ByteVector is passed to the constructor
   * (num_element_value_pairs can be set to 0, it is reset to the correct value in {@link
   * #visitEnd()}). The element_value_pairs array is filled incrementally in the various visit()
   * methods.
   *
   * <p>Note: as an exception to the above rules, for AnnotationDefault attributes (which contain a
   * single element_value by definition), this ByteVector is initially empty when passed to the
   * constructor, and {@link #numElementValuePairsOffset} is set to -1.
   */
  private final ByteVector annotation;

  /**
   * The offset in {@link #annotation} where {@link #numElementValuePairs} must be stored (or -1 for
   * the case of AnnotationDefault attributes).
   */
  private final int numElementValuePairsOffset;

  /** The number of element value pairs visited so far. */
  private int numElementValuePairs;

  /**
   * The previous AnnotationWriter. This field is used to store the list of annotations of a
   * Runtime[In]Visible[Type]Annotations attribute. It is unused for nested or array annotations
   * (annotation values of annotation type), or for AnnotationDefault attributes.
   */
  private final AnnotationWriter previousAnnotation;

  /**
   * The next AnnotationWriter. This field is used to store the list of annotations of a
   * Runtime[In]Visible[Type]Annotations attribute. It is unused for nested or array annotations
   * (annotation values of annotation type), or for AnnotationDefault attributes.
   */
  private AnnotationWriter nextAnnotation;

  // -----------------------------------------------------------------------------------------------
  // Constructors and factories
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link AnnotationWriter}.
   *
   * @param symbolTable where the constants used in this AnnotationWriter must be stored.
   * @param useNamedValues whether values are named or not. AnnotationDefault and annotation arrays
   *     use unnamed values.
   * @param annotation where the 'annotation' or 'type_annotation' JVMS structure corresponding to
   *     the visited content must be stored. This ByteVector must already contain all the fields of
   *     the structure except the last one (the element_value_pairs array).
   * @param previousAnnotation the previously visited annotation of the
   *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or
   *     {@literal null} in other cases (e.g. nested or array annotations).
   */
  AnnotationWriter(
      final SymbolTable symbolTable,
      final boolean useNamedValues,
      final ByteVector annotation,
      final AnnotationWriter previousAnnotation) {
    super(/* latest api = */ Opcodes.ASM9);
    this.symbolTable = symbolTable;
    this.useNamedValues = useNamedValues;
    this.annotation = annotation;
    // By hypothesis, num_element_value_pairs is stored in the last unsigned short of 'annotation'.
    this.numElementValuePairsOffset = annotation.length == 0 ? -1 : annotation.length - 2;
    this.previousAnnotation = previousAnnotation;
    if (previousAnnotation != null) {
      previousAnnotation.nextAnnotation = this;
    }
  }

  /**
   * Creates a new {@link AnnotationWriter} using named values.
   *
   * @param symbolTable where the constants used in this AnnotationWriter must be stored.
   * @param descriptor the class descriptor of the annotation class.
   * @param previousAnnotation the previously visited annotation of the
   *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or
   *     {@literal null} in other cases (e.g. nested or array annotations).
   * @return a new {@link AnnotationWriter} for the given annotation descriptor.
   */
  static AnnotationWriter create(
      final SymbolTable symbolTable,
      final String descriptor,
      final AnnotationWriter previousAnnotation) {
    // Create a ByteVector to hold an 'annotation' JVMS structure.
    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.
    ByteVector annotation = new ByteVector();
    // Write type_index and reserve space for num_element_value_pairs.
    annotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);
    return new AnnotationWriter(
        symbolTable, /* useNamedValues= */ true, annotation, previousAnnotation);
  }

  /**
   * Creates a new {@link AnnotationWriter} using named values.
   *
   * @param symbolTable where the constants used in this AnnotationWriter must be stored.
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link
   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See
   *     {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param previousAnnotation the previously visited annotation of the
   *     Runtime[In]Visible[Type]Annotations attribute to which this annotation belongs, or
   *     {@literal null} in other cases (e.g. nested or array annotations).
   * @return a new {@link AnnotationWriter} for the given type annotation reference and descriptor.
   */
  static AnnotationWriter create(
      final SymbolTable symbolTable,
      final int typeRef,
      final TypePath typePath,
      final String descriptor,
      final AnnotationWriter previousAnnotation) {
    // Create a ByteVector to hold a 'type_annotation' JVMS structure.
    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.
    ByteVector typeAnnotation = new ByteVector();
    // Write target_type, target_info, and target_path.
    TypeReference.putTarget(typeRef, typeAnnotation);
    TypePath.put(typePath, typeAnnotation);
    // Write type_index and reserve space for num_element_value_pairs.
    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);
    return new AnnotationWriter(
        symbolTable, /* useNamedValues= */ true, typeAnnotation, previousAnnotation);
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the AnnotationVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visit(final String name, final Object value) {
    // Case of an element_value with a const_value_index, class_info_index or array_index field.
    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.
    ++numElementValuePairs;
    if (useNamedValues) {
      annotation.putShort(symbolTable.addConstantUtf8(name));
    }
    if (value instanceof String) {
      annotation.put12('s', symbolTable.addConstantUtf8((String) value));
    } else if (value instanceof Byte) {
      annotation.put12('B', symbolTable.addConstantInteger(((Byte) value).byteValue()).index);
    } else if (value instanceof Boolean) {
      int booleanValue = ((Boolean) value).booleanValue() ? 1 : 0;
      annotation.put12('Z', symbolTable.addConstantInteger(booleanValue).index);
    } else if (value instanceof Character) {
      annotation.put12('C', symbolTable.addConstantInteger(((Character) value).charValue()).index);
    } else if (value instanceof Short) {
      annotation.put12('S', symbolTable.addConstantInteger(((Short) value).shortValue()).index);
    } else if (value instanceof Type) {
      annotation.put12('c', symbolTable.addConstantUtf8(((Type) value).getDescriptor()));
    } else if (value instanceof byte[]) {
      byte[] byteArray = (byte[]) value;
      annotation.put12('[', byteArray.length);
      for (byte byteValue : byteArray) {
        annotation.put12('B', symbolTable.addConstantInteger(byteValue).index);
      }
    } else if (value instanceof boolean[]) {
      boolean[] booleanArray = (boolean[]) value;
      annotation.put12('[', booleanArray.length);
      for (boolean booleanValue : booleanArray) {
        annotation.put12('Z', symbolTable.addConstantInteger(booleanValue ? 1 : 0).index);
      }
    } else if (value instanceof short[]) {
      short[] shortArray = (short[]) value;
      annotation.put12('[', shortArray.length);
      for (short shortValue : shortArray) {
        annotation.put12('S', symbolTable.addConstantInteger(shortValue).index);
      }
    } else if (value instanceof char[]) {
      char[] charArray = (char[]) value;
      annotation.put12('[', charArray.length);
      for (char charValue : charArray) {
        annotation.put12('C', symbolTable.addConstantInteger(charValue).index);
      }
    } else if (value instanceof int[]) {
      int[] intArray = (int[]) value;
      annotation.put12('[', intArray.length);
      for (int intValue : intArray) {
        annotation.put12('I', symbolTable.addConstantInteger(intValue).index);
      }
    } else if (value instanceof long[]) {
      long[] longArray = (long[]) value;
      annotation.put12('[', longArray.length);
      for (long longValue : longArray) {
        annotation.put12('J', symbolTable.addConstantLong(longValue).index);
      }
    } else if (value instanceof float[]) {
      float[] floatArray = (float[]) value;
      annotation.put12('[', floatArray.length);
      for (float floatValue : floatArray) {
        annotation.put12('F', symbolTable.addConstantFloat(floatValue).index);
      }
    } else if (value instanceof double[]) {
      double[] doubleArray = (double[]) value;
      annotation.put12('[', doubleArray.length);
      for (double doubleValue : doubleArray) {
        annotation.put12('D', symbolTable.addConstantDouble(doubleValue).index);
      }
    } else {
      Symbol symbol = symbolTable.addConstant(value);
      annotation.put12(".s.IFJDCS".charAt(symbol.tag), symbol.index);
    }
  }

  @Override
  public void visitEnum(final String name, final String descriptor, final String value) {
    // Case of an element_value with an enum_const_value field.
    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.
    ++numElementValuePairs;
    if (useNamedValues) {
      annotation.putShort(symbolTable.addConstantUtf8(name));
    }
    annotation
        .put12('e', symbolTable.addConstantUtf8(descriptor))
        .putShort(symbolTable.addConstantUtf8(value));
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
    // Case of an element_value with an annotation_value field.
    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.
    ++numElementValuePairs;
    if (useNamedValues) {
      annotation.putShort(symbolTable.addConstantUtf8(name));
    }
    // Write tag and type_index, and reserve 2 bytes for num_element_value_pairs.
    annotation.put12('@', symbolTable.addConstantUtf8(descriptor)).putShort(0);
    return new AnnotationWriter(symbolTable, /* useNamedValues= */ true, annotation, null);
  }

  @Override
  public AnnotationVisitor visitArray(final String name) {
    // Case of an element_value with an array_value field.
    // https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1
    ++numElementValuePairs;
    if (useNamedValues) {
      annotation.putShort(symbolTable.addConstantUtf8(name));
    }
    // Write tag, and reserve 2 bytes for num_values. Here we take advantage of the fact that the
    // end of an element_value of array type is similar to the end of an 'annotation' structure: an
    // unsigned short num_values followed by num_values element_value, versus an unsigned short
    // num_element_value_pairs, followed by num_element_value_pairs { element_name_index,
    // element_value } tuples. This allows us to use an AnnotationWriter with unnamed values to
    // visit the array elements. Its num_element_value_pairs will correspond to the number of array
    // elements and will be stored in what is in fact num_values.
    annotation.put12('[', 0);
    return new AnnotationWriter(symbolTable, /* useNamedValues= */ false, annotation, null);
  }

  @Override
  public void visitEnd() {
    if (numElementValuePairsOffset != -1) {
      byte[] data = annotation.data;
      data[numElementValuePairsOffset] = (byte) (numElementValuePairs >>> 8);
      data[numElementValuePairsOffset + 1] = (byte) numElementValuePairs;
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the size of a Runtime[In]Visible[Type]Annotations attribute containing this annotation
   * and all its <i>predecessors</i> (see {@link #previousAnnotation}. Also adds the attribute name
   * to the constant pool of the class (if not null).
   *
   * @param attributeName one of "Runtime[In]Visible[Type]Annotations", or {@literal null}.
   * @return the size in bytes of a Runtime[In]Visible[Type]Annotations attribute containing this
   *     annotation and all its predecessors. This includes the size of the attribute_name_index and
   *     attribute_length fields.
   */
  int computeAnnotationsSize(final String attributeName) {
    if (attributeName != null) {
      symbolTable.addConstantUtf8(attributeName);
    }
    // The attribute_name_index, attribute_length and num_annotations fields use 8 bytes.
    int attributeSize = 8;
    AnnotationWriter annotationWriter = this;
    while (annotationWriter != null) {
      attributeSize += annotationWriter.annotation.length;
      annotationWriter = annotationWriter.previousAnnotation;
    }
    return attributeSize;
  }

  /**
   * Returns the size of the Runtime[In]Visible[Type]Annotations attributes containing the given
   * annotations and all their <i>predecessors</i> (see {@link #previousAnnotation}. Also adds the
   * attribute names to the constant pool of the class (if not null).
   *
   * @param lastRuntimeVisibleAnnotation The last runtime visible annotation of a field, method or
   *     class. The previous ones can be accessed with the {@link #previousAnnotation} field. May be
   *     {@literal null}.
   * @param lastRuntimeInvisibleAnnotation The last runtime invisible annotation of this a field,
   *     method or class. The previous ones can be accessed with the {@link #previousAnnotation}
   *     field. May be {@literal null}.
   * @param lastRuntimeVisibleTypeAnnotation The last runtime visible type annotation of this a
   *     field, method or class. The previous ones can be accessed with the {@link
   *     #previousAnnotation} field. May be {@literal null}.
   * @param lastRuntimeInvisibleTypeAnnotation The last runtime invisible type annotation of a
   *     field, method or class field. The previous ones can be accessed with the {@link
   *     #previousAnnotation} field. May be {@literal null}.
   * @return the size in bytes of a Runtime[In]Visible[Type]Annotations attribute containing the
   *     given annotations and all their predecessors. This includes the size of the
   *     attribute_name_index and attribute_length fields.
   */
  static int computeAnnotationsSize(
      final AnnotationWriter lastRuntimeVisibleAnnotation,
      final AnnotationWriter lastRuntimeInvisibleAnnotation,
      final AnnotationWriter lastRuntimeVisibleTypeAnnotation,
      final AnnotationWriter lastRuntimeInvisibleTypeAnnotation) {
    int size = 0;
    if (lastRuntimeVisibleAnnotation != null) {
      size +=
          lastRuntimeVisibleAnnotation.computeAnnotationsSize(
              Constants.RUNTIME_VISIBLE_ANNOTATIONS);
    }
    if (lastRuntimeInvisibleAnnotation != null) {
      size +=
          lastRuntimeInvisibleAnnotation.computeAnnotationsSize(
              Constants.RUNTIME_INVISIBLE_ANNOTATIONS);
    }
    if (lastRuntimeVisibleTypeAnnotation != null) {
      size +=
          lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(
              Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);
    }
    if (lastRuntimeInvisibleTypeAnnotation != null) {
      size +=
          lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(
              Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
    }
    return size;
  }

  /**
   * Puts a Runtime[In]Visible[Type]Annotations attribute containing this annotations and all its
   * <i>predecessors</i> (see {@link #previousAnnotation} in the given ByteVector. Annotations are
   * put in the same order they have been visited.
   *
   * @param attributeNameIndex the constant pool index of the attribute name (one of
   *     "Runtime[In]Visible[Type]Annotations").
   * @param output where the attribute must be put.
   */
  void putAnnotations(final int attributeNameIndex, final ByteVector output) {
    int attributeLength = 2; // For num_annotations.
    int numAnnotations = 0;
    AnnotationWriter annotationWriter = this;
    AnnotationWriter firstAnnotation = null;
    while (annotationWriter != null) {
      // In case the user forgot to call visitEnd().
      annotationWriter.visitEnd();
      attributeLength += annotationWriter.annotation.length;
      numAnnotations++;
      firstAnnotation = annotationWriter;
      annotationWriter = annotationWriter.previousAnnotation;
    }
    output.putShort(attributeNameIndex);
    output.putInt(attributeLength);
    output.putShort(numAnnotations);
    annotationWriter = firstAnnotation;
    while (annotationWriter != null) {
      output.putByteArray(annotationWriter.annotation.data, 0, annotationWriter.annotation.length);
      annotationWriter = annotationWriter.nextAnnotation;
    }
  }

  /**
   * Puts the Runtime[In]Visible[Type]Annotations attributes containing the given annotations and
   * all their <i>predecessors</i> (see {@link #previousAnnotation} in the given ByteVector.
   * Annotations are put in the same order they have been visited.
   *
   * @param symbolTable where the constants used in the AnnotationWriter instances are stored.
   * @param lastRuntimeVisibleAnnotation The last runtime visible annotation of a field, method or
   *     class. The previous ones can be accessed with the {@link #previousAnnotation} field. May be
   *     {@literal null}.
   * @param lastRuntimeInvisibleAnnotation The last runtime invisible annotation of this a field,
   *     method or class. The previous ones can be accessed with the {@link #previousAnnotation}
   *     field. May be {@literal null}.
   * @param lastRuntimeVisibleTypeAnnotation The last runtime visible type annotation of this a
   *     field, method or class. The previous ones can be accessed with the {@link
   *     #previousAnnotation} field. May be {@literal null}.
   * @param lastRuntimeInvisibleTypeAnnotation The last runtime invisible type annotation of a
   *     field, method or class field. The previous ones can be accessed with the {@link
   *     #previousAnnotation} field. May be {@literal null}.
   * @param output where the attributes must be put.
   */
  static void putAnnotations(
      final SymbolTable symbolTable,
      final AnnotationWriter lastRuntimeVisibleAnnotation,
      final AnnotationWriter lastRuntimeInvisibleAnnotation,
      final AnnotationWriter lastRuntimeVisibleTypeAnnotation,
      final AnnotationWriter lastRuntimeInvisibleTypeAnnotation,
      final ByteVector output) {
    if (lastRuntimeVisibleAnnotation != null) {
      lastRuntimeVisibleAnnotation.putAnnotations(
          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output);
    }
    if (lastRuntimeInvisibleAnnotation != null) {
      lastRuntimeInvisibleAnnotation.putAnnotations(
          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output);
    }
    if (lastRuntimeVisibleTypeAnnotation != null) {
      lastRuntimeVisibleTypeAnnotation.putAnnotations(
          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);
    }
    if (lastRuntimeInvisibleTypeAnnotation != null) {
      lastRuntimeInvisibleTypeAnnotation.putAnnotations(
          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);
    }
  }

  /**
   * Returns the size of a Runtime[In]VisibleParameterAnnotations attribute containing all the
   * annotation lists from the given AnnotationWriter sub-array. Also adds the attribute name to the
   * constant pool of the class.
   *
   * @param attributeName one of "Runtime[In]VisibleParameterAnnotations".
   * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>
   *     element).
   * @param annotableParameterCount the number of elements in annotationWriters to take into account
   *     (elements [0..annotableParameterCount[ are taken into account).
   * @return the size in bytes of a Runtime[In]VisibleParameterAnnotations attribute corresponding
   *     to the given sub-array of AnnotationWriter lists. This includes the size of the
   *     attribute_name_index and attribute_length fields.
   */
  static int computeParameterAnnotationsSize(
      final String attributeName,
      final AnnotationWriter[] annotationWriters,
      final int annotableParameterCount) {
    // Note: attributeName is added to the constant pool by the call to computeAnnotationsSize
    // below. This assumes that there is at least one non-null element in the annotationWriters
    // sub-array (which is ensured by the lazy instantiation of this array in MethodWriter).
    // The attribute_name_index, attribute_length and num_parameters fields use 7 bytes, and each
    // element of the parameter_annotations array uses 2 bytes for its num_annotations field.
    int attributeSize = 7 + 2 * annotableParameterCount;
    for (int i = 0; i < annotableParameterCount; ++i) {
      AnnotationWriter annotationWriter = annotationWriters[i];
      attributeSize +=
          annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(attributeName) - 8;
    }
    return attributeSize;
  }

  /**
   * Puts a Runtime[In]VisibleParameterAnnotations attribute containing all the annotation lists
   * from the given AnnotationWriter sub-array in the given ByteVector.
   *
   * @param attributeNameIndex constant pool index of the attribute name (one of
   *     Runtime[In]VisibleParameterAnnotations).
   * @param annotationWriters an array of AnnotationWriter lists (designated by their <i>last</i>
   *     element).
   * @param annotableParameterCount the number of elements in annotationWriters to put (elements
   *     [0..annotableParameterCount[ are put).
   * @param output where the attribute must be put.
   */
  static void putParameterAnnotations(
      final int attributeNameIndex,
      final AnnotationWriter[] annotationWriters,
      final int annotableParameterCount,
      final ByteVector output) {
    // The num_parameters field uses 1 byte, and each element of the parameter_annotations array
    // uses 2 bytes for its num_annotations field.
    int attributeLength = 1 + 2 * annotableParameterCount;
    for (int i = 0; i < annotableParameterCount; ++i) {
      AnnotationWriter annotationWriter = annotationWriters[i];
      attributeLength +=
          annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(null) - 8;
    }
    output.putShort(attributeNameIndex);
    output.putInt(attributeLength);
    output.putByte(annotableParameterCount);
    for (int i = 0; i < annotableParameterCount; ++i) {
      AnnotationWriter annotationWriter = annotationWriters[i];
      AnnotationWriter firstAnnotation = null;
      int numAnnotations = 0;
      while (annotationWriter != null) {
        // In case user the forgot to call visitEnd().
        annotationWriter.visitEnd();
        numAnnotations++;
        firstAnnotation = annotationWriter;
        annotationWriter = annotationWriter.previousAnnotation;
      }
      output.putShort(numAnnotations);
      annotationWriter = firstAnnotation;
      while (annotationWriter != null) {
        output.putByteArray(
            annotationWriter.annotation.data, 0, annotationWriter.annotation.length);
        annotationWriter = annotationWriter.nextAnnotation;
      }
    }
  }
}

package org.objectweb.asm;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

/**
 * A Java field or method type. This class can be used to make it easier to manipulate type and
 * method descriptors.
 *
 * @author Eric Bruneton
 * @author Chris Nokleberg
 */
public final class Type {

  /** The sort of the {@code void} type. See {@link #getSort}. */
  public static final int VOID = 0;

  /** The sort of the {@code boolean} type. See {@link #getSort}. */
  public static final int BOOLEAN = 1;

  /** The sort of the {@code char} type. See {@link #getSort}. */
  public static final int CHAR = 2;

  /** The sort of the {@code byte} type. See {@link #getSort}. */
  public static final int BYTE = 3;

  /** The sort of the {@code short} type. See {@link #getSort}. */
  public static final int SHORT = 4;

  /** The sort of the {@code int} type. See {@link #getSort}. */
  public static final int INT = 5;

  /** The sort of the {@code float} type. See {@link #getSort}. */
  public static final int FLOAT = 6;

  /** The sort of the {@code long} type. See {@link #getSort}. */
  public static final int LONG = 7;

  /** The sort of the {@code double} type. See {@link #getSort}. */
  public static final int DOUBLE = 8;

  /** The sort of array reference types. See {@link #getSort}. */
  public static final int ARRAY = 9;

  /** The sort of object reference types. See {@link #getSort}. */
  public static final int OBJECT = 10;

  /** The sort of method types. See {@link #getSort}. */
  public static final int METHOD = 11;

  /** The (private) sort of object reference types represented with an internal name. */
  private static final int INTERNAL = 12;

  /** The descriptors of the primitive types. */
  private static final String PRIMITIVE_DESCRIPTORS = "VZCBSIFJD";

  /** The {@code void} type. */
  public static final Type VOID_TYPE = new Type(VOID, PRIMITIVE_DESCRIPTORS, VOID, VOID + 1);

  /** The {@code boolean} type. */
  public static final Type BOOLEAN_TYPE =
      new Type(BOOLEAN, PRIMITIVE_DESCRIPTORS, BOOLEAN, BOOLEAN + 1);

  /** The {@code char} type. */
  public static final Type CHAR_TYPE = new Type(CHAR, PRIMITIVE_DESCRIPTORS, CHAR, CHAR + 1);

  /** The {@code byte} type. */
  public static final Type BYTE_TYPE = new Type(BYTE, PRIMITIVE_DESCRIPTORS, BYTE, BYTE + 1);

  /** The {@code short} type. */
  public static final Type SHORT_TYPE = new Type(SHORT, PRIMITIVE_DESCRIPTORS, SHORT, SHORT + 1);

  /** The {@code int} type. */
  public static final Type INT_TYPE = new Type(INT, PRIMITIVE_DESCRIPTORS, INT, INT + 1);

  /** The {@code float} type. */
  public static final Type FLOAT_TYPE = new Type(FLOAT, PRIMITIVE_DESCRIPTORS, FLOAT, FLOAT + 1);

  /** The {@code long} type. */
  public static final Type LONG_TYPE = new Type(LONG, PRIMITIVE_DESCRIPTORS, LONG, LONG + 1);

  /** The {@code double} type. */
  public static final Type DOUBLE_TYPE =
      new Type(DOUBLE, PRIMITIVE_DESCRIPTORS, DOUBLE, DOUBLE + 1);

  // -----------------------------------------------------------------------------------------------
  // Fields
  // -----------------------------------------------------------------------------------------------

  /**
   * The sort of this type. Either {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE},
   * {@link #SHORT}, {@link #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY},
   * {@link #OBJECT}, {@link #METHOD} or {@link #INTERNAL}.
   */
  private final int sort;

  /**
   * A buffer containing the value of this field or method type. This value is an internal name for
   * {@link #OBJECT} and {@link #INTERNAL} types, and a field or method descriptor in the other
   * cases.
   *
   * <p>For {@link #OBJECT} types, this field also contains the descriptor: the characters in
   * [{@link #valueBegin},{@link #valueEnd}) contain the internal name, and those in [{@link
   * #valueBegin} - 1, {@link #valueEnd} + 1) contain the descriptor.
   */
  private final String valueBuffer;

  /**
   * The beginning index, inclusive, of the value of this Java field or method type in {@link
   * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,
   * and a field or method descriptor in the other cases.
   */
  private final int valueBegin;

  /**
   * The end index, exclusive, of the value of this Java field or method type in {@link
   * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,
   * and a field or method descriptor in the other cases.
   */
  private final int valueEnd;

  /**
   * Constructs a reference type.
   *
   * @param sort the sort of this type, see {@link #sort}.
   * @param valueBuffer a buffer containing the value of this field or method type.
   * @param valueBegin the beginning index, inclusive, of the value of this field or method type in
   *     valueBuffer.
   * @param valueEnd the end index, exclusive, of the value of this field or method type in
   *     valueBuffer.
   */
  private Type(final int sort, final String valueBuffer, final int valueBegin, final int valueEnd) {
    this.sort = sort;
    this.valueBuffer = valueBuffer;
    this.valueBegin = valueBegin;
    this.valueEnd = valueEnd;
  }

  // -----------------------------------------------------------------------------------------------
  // Methods to get Type(s) from a descriptor, a reflected Method or Constructor, other types, etc.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the {@link Type} corresponding to the given type descriptor.
   *
   * @param typeDescriptor a field or method type descriptor.
   * @return the {@link Type} corresponding to the given type descriptor.
   */
  public static Type getType(final String typeDescriptor) {
    return getTypeInternal(typeDescriptor, 0, typeDescriptor.length());
  }

  /**
   * Returns the {@link Type} corresponding to the given class.
   *
   * @param clazz a class.
   * @return the {@link Type} corresponding to the given class.
   */
  public static Type getType(final Class<?> clazz) {
    if (clazz.isPrimitive()) {
      if (clazz == Integer.TYPE) {
        return INT_TYPE;
      } else if (clazz == Void.TYPE) {
        return VOID_TYPE;
      } else if (clazz == Boolean.TYPE) {
        return BOOLEAN_TYPE;
      } else if (clazz == Byte.TYPE) {
        return BYTE_TYPE;
      } else if (clazz == Character.TYPE) {
        return CHAR_TYPE;
      } else if (clazz == Short.TYPE) {
        return SHORT_TYPE;
      } else if (clazz == Double.TYPE) {
        return DOUBLE_TYPE;
      } else if (clazz == Float.TYPE) {
        return FLOAT_TYPE;
      } else if (clazz == Long.TYPE) {
        return LONG_TYPE;
      } else {
        throw new AssertionError();
      }
    } else {
      return getType(getDescriptor(clazz));
    }
  }

  /**
   * Returns the method {@link Type} corresponding to the given constructor.
   *
   * @param constructor a {@link Constructor} object.
   * @return the method {@link Type} corresponding to the given constructor.
   */
  public static Type getType(final Constructor<?> constructor) {
    return getType(getConstructorDescriptor(constructor));
  }

  /**
   * Returns the method {@link Type} corresponding to the given method.
   *
   * @param method a {@link Method} object.
   * @return the method {@link Type} corresponding to the given method.
   */
  public static Type getType(final Method method) {
    return getType(getMethodDescriptor(method));
  }

  /**
   * Returns the type of the elements of this array type. This method should only be used for an
   * array type.
   *
   * @return Returns the type of the elements of this array type.
   */
  public Type getElementType() {
    final int numDimensions = getDimensions();
    return getTypeInternal(valueBuffer, valueBegin + numDimensions, valueEnd);
  }

  /**
   * Returns the {@link Type} corresponding to the given internal name.
   *
   * @param internalName an internal name (see {@link Type#getInternalName()}).
   * @return the {@link Type} corresponding to the given internal name.
   */
  public static Type getObjectType(final @InternalForm String internalName) {
    return new Type(
        internalName.charAt(0) == '[' ? ARRAY : INTERNAL, internalName, 0, internalName.length());
  }

  /**
   * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to <code>
   * Type.getType(methodDescriptor)</code>.
   *
   * @param methodDescriptor a method descriptor.
   * @return the {@link Type} corresponding to the given method descriptor.
   */
  public static Type getMethodType(final String methodDescriptor) {
    return new Type(METHOD, methodDescriptor, 0, methodDescriptor.length());
  }

  /**
   * Returns the method {@link Type} corresponding to the given argument and return types.
   *
   * @param returnType the return type of the method.
   * @param argumentTypes the argument types of the method.
   * @return the method {@link Type} corresponding to the given argument and return types.
   */
  public static Type getMethodType(final Type returnType, final Type... argumentTypes) {
    return getType(getMethodDescriptor(returnType, argumentTypes));
  }

  /**
   * Returns the argument types of methods of this type. This method should only be used for method
   * types.
   *
   * @return the argument types of methods of this type.
   */
  public Type[] getArgumentTypes() {
    return getArgumentTypes(getDescriptor());
  }

  /**
   * Returns the {@link Type} values corresponding to the argument types of the given method
   * descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the {@link Type} values corresponding to the argument types of the given method
   *     descriptor.
   */
  public static Type[] getArgumentTypes(final String methodDescriptor) {
    // First step: compute the number of argument types in methodDescriptor.
    int numArgumentTypes = getArgumentCount(methodDescriptor);

    // Second step: create a Type instance for each argument type.
    Type[] argumentTypes = new Type[numArgumentTypes];
    // Skip the first character, which is always a '('.
    int currentOffset = 1;
    // Parse and create the argument types, one at each loop iteration.
    int currentArgumentTypeIndex = 0;
    while (methodDescriptor.charAt(currentOffset) != ')') {
      final int currentArgumentTypeOffset = currentOffset;
      while (methodDescriptor.charAt(currentOffset) == '[') {
        currentOffset++;
      }
      if (methodDescriptor.charAt(currentOffset++) == 'L') {
        // Skip the argument descriptor content.
        int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);
        currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
      }
      argumentTypes[currentArgumentTypeIndex++] =
          getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset);
    }
    return argumentTypes;
  }

  /**
   * Returns the {@link Type} values corresponding to the argument types of the given method.
   *
   * @param method a method.
   * @return the {@link Type} values corresponding to the argument types of the given method.
   */
  public static Type[] getArgumentTypes(final Method method) {
    Class<?>[] classes = method.getParameterTypes();
    Type[] types = new Type[classes.length];
    for (int i = classes.length - 1; i >= 0; --i) {
      types[i] = getType(classes[i]);
    }
    return types;
  }

  /**
   * Returns the return type of methods of this type. This method should only be used for method
   * types.
   *
   * @return the return type of methods of this type.
   */
  public Type getReturnType() {
    return getReturnType(getDescriptor());
  }

  /**
   * Returns the {@link Type} corresponding to the return type of the given method descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the {@link Type} corresponding to the return type of the given method descriptor.
   */
  public static Type getReturnType(final String methodDescriptor) {
    return getTypeInternal(
        methodDescriptor, getReturnTypeOffset(methodDescriptor), methodDescriptor.length());
  }

  /**
   * Returns the {@link Type} corresponding to the return type of the given method.
   *
   * @param method a method.
   * @return the {@link Type} corresponding to the return type of the given method.
   */
  public static Type getReturnType(final Method method) {
    return getType(method.getReturnType());
  }

  /**
   * Returns the start index of the return type of the given method descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the start index of the return type of the given method descriptor.
   */
  static int getReturnTypeOffset(final String methodDescriptor) {
    // Skip the first character, which is always a '('.
    int currentOffset = 1;
    // Skip the argument types, one at a each loop iteration.
    while (methodDescriptor.charAt(currentOffset) != ')') {
      while (methodDescriptor.charAt(currentOffset) == '[') {
        currentOffset++;
      }
      if (methodDescriptor.charAt(currentOffset++) == 'L') {
        // Skip the argument descriptor content.
        int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);
        currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
      }
    }
    return currentOffset + 1;
  }

  /**
   * Returns the {@link Type} corresponding to the given field or method descriptor.
   *
   * @param descriptorBuffer a buffer containing the field or method descriptor.
   * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in
   *     descriptorBuffer.
   * @param descriptorEnd the end index, exclusive, of the field or method descriptor in
   *     descriptorBuffer.
   * @return the {@link Type} corresponding to the given type descriptor.
   */
  private static Type getTypeInternal(
      final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {
    switch (descriptorBuffer.charAt(descriptorBegin)) {
      case 'V':
        return VOID_TYPE;
      case 'Z':
        return BOOLEAN_TYPE;
      case 'C':
        return CHAR_TYPE;
      case 'B':
        return BYTE_TYPE;
      case 'S':
        return SHORT_TYPE;
      case 'I':
        return INT_TYPE;
      case 'F':
        return FLOAT_TYPE;
      case 'J':
        return LONG_TYPE;
      case 'D':
        return DOUBLE_TYPE;
      case '[':
        return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd);
      case 'L':
        return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1);
      case '(':
        return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd);
      default:
        throw new IllegalArgumentException("Invalid descriptor: " + descriptorBuffer);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Methods to get class names, internal names or descriptors.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the binary name of the class corresponding to this type. This method must not be used
   * on method types.
   *
   * @return the binary name of the class corresponding to this type.
   */
  public String getClassName() {
    switch (sort) {
      case VOID:
        return "void";
      case BOOLEAN:
        return "boolean";
      case CHAR:
        return "char";
      case BYTE:
        return "byte";
      case SHORT:
        return "short";
      case INT:
        return "int";
      case FLOAT:
        return "float";
      case LONG:
        return "long";
      case DOUBLE:
        return "double";
      case ARRAY:
        StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());
        for (int i = getDimensions(); i > 0; --i) {
          stringBuilder.append("[]");
        }
        return stringBuilder.toString();
      case OBJECT:
      case INTERNAL:
        return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.');
      default:
        throw new AssertionError();
    }
  }

  /**
   * Returns the internal name of the class corresponding to this object or array type. The internal
   * name of a class is its fully qualified name (as returned by Class.getName(), where '.' are
   * replaced by '/'). This method should only be used for an object or array type.
   *
   * @return the internal name of the class corresponding to this object type.
   */
  public @InternalForm String getInternalName() {
    return valueBuffer.substring(valueBegin, valueEnd);
  }

  /**
   * Returns the internal name of the given class. The internal name of a class is its fully
   * qualified name, as returned by Class.getName(), where '.' are replaced by '/'.
   *
   * @param clazz an object or array class.
   * @return the internal name of the given class.
   */
  public static @InternalForm String getInternalName(final Class<?> clazz) {
    return clazz.getName().replace('.', '/');
  }

  /**
   * Returns the descriptor corresponding to this type.
   *
   * @return the descriptor corresponding to this type.
   */
  public String getDescriptor() {
    if (sort == OBJECT) {
      return valueBuffer.substring(valueBegin - 1, valueEnd + 1);
    } else if (sort == INTERNAL) {
      return 'L' + valueBuffer.substring(valueBegin, valueEnd) + ';';
    } else {
      return valueBuffer.substring(valueBegin, valueEnd);
    }
  }

  /**
   * Returns the descriptor corresponding to the given class.
   *
   * @param clazz an object class, a primitive class or an array class.
   * @return the descriptor corresponding to the given class.
   */
  public static String getDescriptor(final Class<?> clazz) {
    StringBuilder stringBuilder = new StringBuilder();
    appendDescriptor(clazz, stringBuilder);
    return stringBuilder.toString();
  }

  /**
   * Returns the descriptor corresponding to the given constructor.
   *
   * @param constructor a {@link Constructor} object.
   * @return the descriptor of the given constructor.
   */
  public static String getConstructorDescriptor(final Constructor<?> constructor) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append('(');
    Class<?>[] parameters = constructor.getParameterTypes();
    for (Class<?> parameter : parameters) {
      appendDescriptor(parameter, stringBuilder);
    }
    return stringBuilder.append(")V").toString();
  }

  /**
   * Returns the descriptor corresponding to the given argument and return types.
   *
   * @param returnType the return type of the method.
   * @param argumentTypes the argument types of the method.
   * @return the descriptor corresponding to the given argument and return types.
   */
  public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append('(');
    for (Type argumentType : argumentTypes) {
      argumentType.appendDescriptor(stringBuilder);
    }
    stringBuilder.append(')');
    returnType.appendDescriptor(stringBuilder);
    return stringBuilder.toString();
  }

  /**
   * Returns the descriptor corresponding to the given method.
   *
   * @param method a {@link Method} object.
   * @return the descriptor of the given method.
   */
  public static String getMethodDescriptor(final Method method) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append('(');
    Class<?>[] parameters = method.getParameterTypes();
    for (Class<?> parameter : parameters) {
      appendDescriptor(parameter, stringBuilder);
    }
    stringBuilder.append(')');
    appendDescriptor(method.getReturnType(), stringBuilder);
    return stringBuilder.toString();
  }

  /**
   * Appends the descriptor corresponding to this type to the given string buffer.
   *
   * @param stringBuilder the string builder to which the descriptor must be appended.
   */
  private void appendDescriptor(final StringBuilder stringBuilder) {
    if (sort == OBJECT) {
      stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);
    } else if (sort == INTERNAL) {
      stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';');
    } else {
      stringBuilder.append(valueBuffer, valueBegin, valueEnd);
    }
  }

  /**
   * Appends the descriptor of the given class to the given string builder.
   *
   * @param clazz the class whose descriptor must be computed.
   * @param stringBuilder the string builder to which the descriptor must be appended.
   */
  private static void appendDescriptor(final Class<?> clazz, final StringBuilder stringBuilder) {
    Class<?> currentClass = clazz;
    while (currentClass.isArray()) {
      stringBuilder.append('[');
      currentClass = currentClass.getComponentType();
    }
    if (currentClass.isPrimitive()) {
      char descriptor;
      if (currentClass == Integer.TYPE) {
        descriptor = 'I';
      } else if (currentClass == Void.TYPE) {
        descriptor = 'V';
      } else if (currentClass == Boolean.TYPE) {
        descriptor = 'Z';
      } else if (currentClass == Byte.TYPE) {
        descriptor = 'B';
      } else if (currentClass == Character.TYPE) {
        descriptor = 'C';
      } else if (currentClass == Short.TYPE) {
        descriptor = 'S';
      } else if (currentClass == Double.TYPE) {
        descriptor = 'D';
      } else if (currentClass == Float.TYPE) {
        descriptor = 'F';
      } else if (currentClass == Long.TYPE) {
        descriptor = 'J';
      } else {
        throw new AssertionError();
      }
      stringBuilder.append(descriptor);
    } else {
      stringBuilder.append('L').append(getInternalName(currentClass)).append(';');
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Methods to get the sort, dimension, size, and opcodes corresponding to a Type or descriptor.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the sort of this type.
   *
   * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link
   *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or
   *     {@link #METHOD}.
   */
  public int getSort() {
    return sort == INTERNAL ? OBJECT : sort;
  }

  /**
   * Returns the number of dimensions of this array type. This method should only be used for an
   * array type.
   *
   * @return the number of dimensions of this array type.
   */
  public int getDimensions() {
    int numDimensions = 1;
    while (valueBuffer.charAt(valueBegin + numDimensions) == '[') {
      numDimensions++;
    }
    return numDimensions;
  }

  /**
   * Returns the size of values of this type. This method must not be used for method types.
   *
   * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for
   *     {@code void} and 1 otherwise.
   */
  public int getSize() {
    switch (sort) {
      case VOID:
        return 0;
      case BOOLEAN:
      case CHAR:
      case BYTE:
      case SHORT:
      case INT:
      case FLOAT:
      case ARRAY:
      case OBJECT:
      case INTERNAL:
        return 1;
      case LONG:
      case DOUBLE:
        return 2;
      default:
        throw new AssertionError();
    }
  }

  /**
   * Returns the number of arguments of this method type. This method should only be used for method
   * types.
   *
   * @return the number of arguments of this method type. Each argument counts for 1, even long and
   *     double ones. The implicit @literal{this} argument is not counted.
   */
  public int getArgumentCount() {
    return getArgumentCount(getDescriptor());
  }

  /**
   * Returns the number of arguments in the given method descriptor.
   *
   * @param methodDescriptor a method descriptor.
   * @return the number of arguments in the given method descriptor. Each argument counts for 1,
   *     even long and double ones. The implicit @literal{this} argument is not counted.
   */
  public static int getArgumentCount(final String methodDescriptor) {
    int argumentCount = 0;
    // Skip the first character, which is always a '('.
    int currentOffset = 1;
    // Parse the argument types, one at a each loop iteration.
    while (methodDescriptor.charAt(currentOffset) != ')') {
      while (methodDescriptor.charAt(currentOffset) == '[') {
        currentOffset++;
      }
      if (methodDescriptor.charAt(currentOffset++) == 'L') {
        // Skip the argument descriptor content.
        int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);
        currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
      }
      ++argumentCount;
    }
    return argumentCount;
  }

  /**
   * Returns the size of the arguments and of the return value of methods of this type. This method
   * should only be used for method types.
   *
   * @return the size of the arguments of the method (plus one for the implicit this argument),
   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =
   *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code
   *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,
   *     the others have size 1.
   */
  public int getArgumentsAndReturnSizes() {
    return getArgumentsAndReturnSizes(getDescriptor());
  }

  /**
   * Computes the size of the arguments and of the return value of a method.
   *
   * @param methodDescriptor a method descriptor.
   * @return the size of the arguments of the method (plus one for the implicit this argument),
   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =
   *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code
   *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,
   *     the others have size 1.
   */
  public static int getArgumentsAndReturnSizes(final String methodDescriptor) {
    int argumentsSize = 1;
    // Skip the first character, which is always a '('.
    int currentOffset = 1;
    int currentChar = methodDescriptor.charAt(currentOffset);
    // Parse the argument types and compute their size, one at a each loop iteration.
    while (currentChar != ')') {
      if (currentChar == 'J' || currentChar == 'D') {
        currentOffset++;
        argumentsSize += 2;
      } else {
        while (methodDescriptor.charAt(currentOffset) == '[') {
          currentOffset++;
        }
        if (methodDescriptor.charAt(currentOffset++) == 'L') {
          // Skip the argument descriptor content.
          int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);
          currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
        }
        argumentsSize += 1;
      }
      currentChar = methodDescriptor.charAt(currentOffset);
    }
    currentChar = methodDescriptor.charAt(currentOffset + 1);
    if (currentChar == 'V') {
      return argumentsSize << 2;
    } else {
      int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1;
      return argumentsSize << 2 | returnSize;
    }
  }

  /**
   * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for
   * method types.
   *
   * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,
   *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and
   *     IRETURN.
   * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For
   *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns
   *     FRETURN.
   */
  public int getOpcode(final int opcode) {
    if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {
      switch (sort) {
        case BOOLEAN:
        case BYTE:
          return opcode + (Opcodes.BALOAD - Opcodes.IALOAD);
        case CHAR:
          return opcode + (Opcodes.CALOAD - Opcodes.IALOAD);
        case SHORT:
          return opcode + (Opcodes.SALOAD - Opcodes.IALOAD);
        case INT:
          return opcode;
        case FLOAT:
          return opcode + (Opcodes.FALOAD - Opcodes.IALOAD);
        case LONG:
          return opcode + (Opcodes.LALOAD - Opcodes.IALOAD);
        case DOUBLE:
          return opcode + (Opcodes.DALOAD - Opcodes.IALOAD);
        case ARRAY:
        case OBJECT:
        case INTERNAL:
          return opcode + (Opcodes.AALOAD - Opcodes.IALOAD);
        case METHOD:
        case VOID:
          throw new UnsupportedOperationException();
        default:
          throw new AssertionError();
      }
    } else {
      switch (sort) {
        case VOID:
          if (opcode != Opcodes.IRETURN) {
            throw new UnsupportedOperationException();
          }
          return Opcodes.RETURN;
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case SHORT:
        case INT:
          return opcode;
        case FLOAT:
          return opcode + (Opcodes.FRETURN - Opcodes.IRETURN);
        case LONG:
          return opcode + (Opcodes.LRETURN - Opcodes.IRETURN);
        case DOUBLE:
          return opcode + (Opcodes.DRETURN - Opcodes.IRETURN);
        case ARRAY:
        case OBJECT:
        case INTERNAL:
          if (opcode != Opcodes.ILOAD && opcode != Opcodes.ISTORE && opcode != Opcodes.IRETURN) {
            throw new UnsupportedOperationException();
          }
          return opcode + (Opcodes.ARETURN - Opcodes.IRETURN);
        case METHOD:
          throw new UnsupportedOperationException();
        default:
          throw new AssertionError();
      }
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Equals, hashCode and toString.
  // -----------------------------------------------------------------------------------------------

  /**
   * Tests if the given object is equal to this type.
   *
   * @param object the object to be compared to this type.
   * @return {@literal true} if the given object is equal to this type.
   */
  @Override
  public boolean equals(final Object object) {
    if (this == object) {
      return true;
    }
    if (!(object instanceof Type)) {
      return false;
    }
    Type other = (Type) object;
    if ((sort == INTERNAL ? OBJECT : sort) != (other.sort == INTERNAL ? OBJECT : other.sort)) {
      return false;
    }
    int begin = valueBegin;
    int end = valueEnd;
    int otherBegin = other.valueBegin;
    int otherEnd = other.valueEnd;
    // Compare the values.
    if (end - begin != otherEnd - otherBegin) {
      return false;
    }
    for (int i = begin, j = otherBegin; i < end; i++, j++) {
      if (valueBuffer.charAt(i) != other.valueBuffer.charAt(j)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Returns a hash code value for this type.
   *
   * @return a hash code value for this type.
   */
  @Override
  public int hashCode() {
    int hashCode = 13 * (sort == INTERNAL ? OBJECT : sort);
    if (sort >= ARRAY) {
      for (int i = valueBegin, end = valueEnd; i < end; i++) {
        hashCode = 17 * (hashCode + valueBuffer.charAt(i));
      }
    }
    return hashCode;
  }

  /**
   * Returns a string representation of this type.
   *
   * @return the descriptor of this type.
   */
  @Override
  public String toString() {
    return getDescriptor();
  }
}

package org.objectweb.asm;

/**
 * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type
 * table entries of a class.
 *
 * @author Eric Bruneton
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4">JVMS
 *     4.4</a>
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23">JVMS
 *     4.7.23</a>
 */
final class SymbolTable {

  /**
   * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link
   * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link
   * Attribute#write}.
   */
  final ClassWriter classWriter;

  /**
   * The ClassReader from which this SymbolTable was constructed, or {@literal null} if it was
   * constructed from scratch.
   */
  private final ClassReader sourceClassReader;

  /** The major version number of the class to which this symbol table belongs. */
  private int majorVersion;

  /** The internal name of the class to which this symbol table belongs. */
  private @InternalForm String className;

  /**
   * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are
   * accessible (recursively) via {@link Entry#next}.
   */
  private int entryCount;

  /**
   * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the
   * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at
   * the array index given by its hash code modulo the array size. If several entries must be stored
   * at the same array index, they are linked together via their {@link Entry#next} field. The
   * factory methods of this class make sure that this table does not contain duplicated entries.
   */
  private Entry[] entries;

  /**
   * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool
   * item has index 1, and long and double items count for two items.
   */
  private int constantPoolCount;

  /**
   * The content of the ClassFile's constant_pool JVMS structure corresponding to this SymbolTable.
   * The ClassFile's constant_pool_count field is <i>not</i> included.
   */
  private ByteVector constantPool;

  /**
   * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the
   * BootstrapMethods_attribute's num_bootstrap_methods field value.
   */
  private int bootstrapMethodCount;

  /**
   * The content of the BootstrapMethods attribute 'bootstrap_methods' array corresponding to this
   * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its
   * num_bootstrap_methods field, are <i>not</i> included.
   */
  private ByteVector bootstrapMethods;

  /**
   * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to
   * typeCount (excluded). The other array entries are empty.
   */
  private int typeCount;

  /**
   * An ASM specific type table used to temporarily store internal names that will not necessarily
   * be stored in the constant pool. This type table is used by the control flow and data flow
   * analysis algorithm used to compute stack map frames from scratch. This array stores {@link
   * Symbol#TYPE_TAG}, {@link Symbol#UNINITIALIZED_TYPE_TAG},{@link
   * Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} and {@link Symbol#MERGED_TYPE_TAG} entries. The type
   * symbol at index {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).
   */
  private Entry[] typeTable;

  /**
   * The actual number of {@link LabelEntry} in {@link #labelTable}. These elements are stored from
   * index 0 to labelCount (excluded). The other array entries are empty. These label entries are
   * also stored in the {@link #labelEntries} hash set.
   */
  private int labelCount;

  /**
   * The labels corresponding to the "forward uninitialized" types in the ASM specific {@link
   * typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}). The label entry at index {@code
   * i} has its {@link LabelEntry#index} equal to {@code i} (and vice versa).
   */
  private LabelEntry[] labelTable;

  /**
   * A hash set of all the {@link LabelEntry} elements in the {@link #labelTable}. Each {@link
   * LabelEntry} instance is stored at the array index given by its hash code modulo the array size.
   * If several entries must be stored at the same array index, they are linked together via their
   * {@link LabelEntry#next} field. The {@link #getOrAddLabelEntry(Label)} method ensures that this
   * table does not contain duplicated entries.
   */
  private LabelEntry[] labelEntries;

  /**
   * Constructs a new, empty SymbolTable for the given ClassWriter.
   *
   * @param classWriter a ClassWriter.
   */
  SymbolTable(final ClassWriter classWriter) {
    this.classWriter = classWriter;
    this.sourceClassReader = null;
    this.entries = new Entry[256];
    this.constantPoolCount = 1;
    this.constantPool = new ByteVector();
  }

  /**
   * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and
   * bootstrap methods of the given ClassReader.
   *
   * @param classWriter a ClassWriter.
   * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to
   *     initialize the SymbolTable.
   */
  SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {
    this.classWriter = classWriter;
    this.sourceClassReader = classReader;

    // Copy the constant pool binary content.
    byte[] inputBytes = classReader.classFileBuffer;
    int constantPoolOffset = classReader.getItem(1) - 1;
    int constantPoolLength = classReader.header - constantPoolOffset;
    constantPoolCount = classReader.getItemCount();
    constantPool = new ByteVector(constantPoolLength);
    constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);

    // Add the constant pool items in the symbol table entries. Reserve enough space in 'entries' to
    // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*
    // method calls below), and to account for bootstrap method entries.
    entries = new Entry[constantPoolCount * 2];
    char[] charBuffer = new char[classReader.getMaxStringLength()];
    boolean hasBootstrapMethods = false;
    int itemIndex = 1;
    while (itemIndex < constantPoolCount) {
      int itemOffset = classReader.getItem(itemIndex);
      int itemTag = inputBytes[itemOffset - 1];
      int nameAndTypeItemOffset;
      switch (itemTag) {
        case Symbol.CONSTANT_FIELDREF_TAG:
        case Symbol.CONSTANT_METHODREF_TAG:
        case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
          nameAndTypeItemOffset =
              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));
          addConstantMemberReference(
              itemIndex,
              itemTag,
              classReader.readClass(itemOffset, charBuffer),
              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),
              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));
          break;
        case Symbol.CONSTANT_INTEGER_TAG:
        case Symbol.CONSTANT_FLOAT_TAG:
          addConstantIntegerOrFloat(itemIndex, itemTag, classReader.readInt(itemOffset));
          break;
        case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
          addConstantNameAndType(
              itemIndex,
              classReader.readUTF8(itemOffset, charBuffer),
              classReader.readUTF8(itemOffset + 2, charBuffer));
          break;
        case Symbol.CONSTANT_LONG_TAG:
        case Symbol.CONSTANT_DOUBLE_TAG:
          addConstantLongOrDouble(itemIndex, itemTag, classReader.readLong(itemOffset));
          break;
        case Symbol.CONSTANT_UTF8_TAG:
          addConstantUtf8(itemIndex, classReader.readUtf(itemIndex, charBuffer));
          break;
        case Symbol.CONSTANT_METHOD_HANDLE_TAG:
          int memberRefItemOffset =
              classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));
          nameAndTypeItemOffset =
              classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));
          addConstantMethodHandle(
              itemIndex,
              classReader.readByte(itemOffset),
              classReader.readClass(memberRefItemOffset, charBuffer),
              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),
              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),
              classReader.readByte(memberRefItemOffset - 1)
                  == Symbol.CONSTANT_INTERFACE_METHODREF_TAG);
          break;
        case Symbol.CONSTANT_DYNAMIC_TAG:
        case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
          hasBootstrapMethods = true;
          nameAndTypeItemOffset =
              classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));
          addConstantDynamicOrInvokeDynamicReference(
              itemTag,
              itemIndex,
              classReader.readUTF8(nameAndTypeItemOffset, charBuffer),
              classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer),
              classReader.readUnsignedShort(itemOffset));
          break;
        case Symbol.CONSTANT_STRING_TAG:
        case Symbol.CONSTANT_CLASS_TAG:
        case Symbol.CONSTANT_METHOD_TYPE_TAG:
        case Symbol.CONSTANT_MODULE_TAG:
        case Symbol.CONSTANT_PACKAGE_TAG:
          addConstantUtf8Reference(
              itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));
          break;
        default:
          throw new IllegalArgumentException();
      }
      itemIndex +=
          (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;
    }

    // Copy the BootstrapMethods, if any.
    if (hasBootstrapMethods) {
      copyBootstrapMethods(classReader, charBuffer);
    }
  }

  /**
   * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of
   * the SymbolTable.
   *
   * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the
   *     SymbolTable.
   * @param charBuffer a buffer used to read strings in the constant pool.
   */
  private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {
    // Find attributOffset of the 'bootstrap_methods' array.
    byte[] inputBytes = classReader.classFileBuffer;
    int currentAttributeOffset = classReader.getFirstAttributeOffset();
    for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {
      String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);
      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
        bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);
        break;
      }
      currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);
    }
    if (bootstrapMethodCount > 0) {
      // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.
      int bootstrapMethodsOffset = currentAttributeOffset + 8;
      int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;
      bootstrapMethods = new ByteVector(bootstrapMethodsLength);
      bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);

      // Add each bootstrap method in the symbol table entries.
      int currentOffset = bootstrapMethodsOffset;
      for (int i = 0; i < bootstrapMethodCount; i++) {
        int offset = currentOffset - bootstrapMethodsOffset;
        int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);
        currentOffset += 2;
        int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);
        currentOffset += 2;
        int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();
        while (numBootstrapArguments-- > 0) {
          int bootstrapArgument = classReader.readUnsignedShort(currentOffset);
          currentOffset += 2;
          hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();
        }
        add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));
      }
    }
  }

  /**
   * Returns the ClassReader from which this SymbolTable was constructed.
   *
   * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it
   *     was constructed from scratch.
   */
  ClassReader getSource() {
    return sourceClassReader;
  }

  /**
   * Returns the major version of the class to which this symbol table belongs.
   *
   * @return the major version of the class to which this symbol table belongs.
   */
  int getMajorVersion() {
    return majorVersion;
  }

  /**
   * Returns the internal name of the class to which this symbol table belongs.
   *
   * @return the internal name of the class to which this symbol table belongs.
   */
  @InternalForm String getClassName() {
    return className;
  }

  /**
   * Sets the major version and the name of the class to which this symbol table belongs. Also adds
   * the class name to the constant pool.
   *
   * @param majorVersion a major ClassFile version number.
   * @param className an internal class name.
   * @return the constant pool index of a new or already existing Symbol with the given class name.
   */
  int setMajorVersionAndClassName(final int majorVersion, final String className) {
    this.majorVersion = majorVersion;
    this.className = className;
    return addConstantClass(className).index;
  }

  /**
   * Returns the number of items in this symbol table's constant_pool array (plus 1).
   *
   * @return the number of items in this symbol table's constant_pool array (plus 1).
   */
  int getConstantPoolCount() {
    return constantPoolCount;
  }

  /**
   * Returns the length in bytes of this symbol table's constant_pool array.
   *
   * @return the length in bytes of this symbol table's constant_pool array.
   */
  int getConstantPoolLength() {
    return constantPool.length;
  }

  /**
   * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the
   * constant_pool_count value.
   *
   * @param output where the JVMS ClassFile's constant_pool array must be put.
   */
  void putConstantPool(final ByteVector output) {
    output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);
  }

  /**
   * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the
   * attribute name in the constant pool.
   *
   * @return the size in bytes of this symbol table's BootstrapMethods attribute.
   */
  int computeBootstrapMethodsSize() {
    if (bootstrapMethods != null) {
      addConstantUtf8(Constants.BOOTSTRAP_METHODS);
      return 8 + bootstrapMethods.length;
    } else {
      return 0;
    }
  }

  /**
   * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the
   * 6 attribute header bytes and the num_bootstrap_methods value.
   *
   * @param output where the JVMS BootstrapMethods attribute must be put.
   */
  void putBootstrapMethods(final ByteVector output) {
    if (bootstrapMethods != null) {
      output
          .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS))
          .putInt(bootstrapMethods.length + 2)
          .putShort(bootstrapMethodCount)
          .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Generic symbol table entries management.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the list of entries which can potentially have the given hash code.
   *
   * @param hashCode a {@link Entry#hashCode} value.
   * @return the list of entries which can potentially have the given hash code. The list is stored
   *     via the {@link Entry#next} field.
   */
  private Entry get(final int hashCode) {
    return entries[hashCode % entries.length];
  }

  /**
   * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check
   * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized
   * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link
   * #entries} array index) as much as possible, with reasonable memory usage.
   *
   * @param entry an Entry (which must not already be contained in {@link #entries}).
   * @return the given entry
   */
  private Entry put(final Entry entry) {
    if (entryCount > (entries.length * 3) / 4) {
      int currentCapacity = entries.length;
      int newCapacity = currentCapacity * 2 + 1;
      Entry[] newEntries = new Entry[newCapacity];
      for (int i = currentCapacity - 1; i >= 0; --i) {
        Entry currentEntry = entries[i];
        while (currentEntry != null) {
          int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;
          Entry nextEntry = currentEntry.next;
          currentEntry.next = newEntries[newCurrentEntryIndex];
          newEntries[newCurrentEntryIndex] = currentEntry;
          currentEntry = nextEntry;
        }
      }
      entries = newEntries;
    }
    entryCount++;
    int index = entry.hashCode % entries.length;
    entry.next = entries[index];
    return entries[index] = entry;
  }

  /**
   * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check
   * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize
   * {@link #entries} if necessary.
   *
   * @param entry an Entry (which must not already be contained in {@link #entries}).
   */
  private void add(final Entry entry) {
    entryCount++;
    int index = entry.hashCode % entries.length;
    entry.next = entries[index];
    entries[index] = entry;
  }

  // -----------------------------------------------------------------------------------------------
  // Constant pool entries management.
  // -----------------------------------------------------------------------------------------------

  /**
   * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value the value of the constant to be added to the constant pool. This parameter must be
   *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link
   *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstant(final Object value) {
    if (value instanceof Integer) {
      return addConstantInteger(((Integer) value).intValue());
    } else if (value instanceof Byte) {
      return addConstantInteger(((Byte) value).intValue());
    } else if (value instanceof Character) {
      return addConstantInteger(((Character) value).charValue());
    } else if (value instanceof Short) {
      return addConstantInteger(((Short) value).intValue());
    } else if (value instanceof Boolean) {
      return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);
    } else if (value instanceof Float) {
      return addConstantFloat(((Float) value).floatValue());
    } else if (value instanceof Long) {
      return addConstantLong(((Long) value).longValue());
    } else if (value instanceof Double) {
      return addConstantDouble(((Double) value).doubleValue());
    } else if (value instanceof String) {
      return addConstantString((String) value);
    } else if (value instanceof Type) {
      Type type = (Type) value;
      int typeSort = type.getSort();
      if (typeSort == Type.OBJECT) {
        return addConstantClass(type.getInternalName());
      } else if (typeSort == Type.METHOD) {
        return addConstantMethodType(type.getDescriptor());
      } else { // type is a primitive or array type.
        return addConstantClass(type.getDescriptor());
      }
    } else if (value instanceof Handle) {
      Handle handle = (Handle) value;
      return addConstantMethodHandle(
          handle.getTag(),
          handle.getOwner(),
          handle.getName(),
          handle.getDesc(),
          handle.isInterface());
    } else if (value instanceof ConstantDynamic) {
      ConstantDynamic constantDynamic = (ConstantDynamic) value;
      return addConstantDynamic(
          constantDynamic.getName(),
          constantDynamic.getDescriptor(),
          constantDynamic.getBootstrapMethod(),
          constantDynamic.getBootstrapMethodArgumentsUnsafe());
    } else {
      throw new IllegalArgumentException("value " + value);
    }
  }

  /**
   * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value the internal name of a class.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantClass(final @InternalForm String value) {
    return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);
  }

  /**
   * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param owner the internal name of a class.
   * @param name a field name.
   * @param descriptor a field descriptor.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantFieldref(final @InternalForm String owner, final String name, final String descriptor) {
    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);
  }

  /**
   * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this
   * symbol table. Does nothing if the constant pool already contains a similar item.
   *
   * @param owner the internal name of a class.
   * @param name a method name.
   * @param descriptor a method descriptor.
   * @param isInterface whether owner is an interface or not.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantMethodref(
      final @InternalForm String owner, final String name, final String descriptor, final boolean isInterface) {
    int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;
    return addConstantMemberReference(tag, owner, name, descriptor);
  }

  /**
   * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to
   * the constant pool of this symbol table. Does nothing if the constant pool already contains a
   * similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}
   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.
   * @param owner the internal name of a class.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   * @return a new or already existing Symbol with the given value.
   */
  private Entry addConstantMemberReference(
      final int tag, final @InternalForm String owner, final String name, final String descriptor) {
    int hashCode = hash(tag, owner, name, descriptor);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == tag
          && entry.hashCode == hashCode
          && entry.owner.equals(owner)
          && entry.name.equals(name)
          && entry.value.equals(descriptor)) {
        return entry;
      }
      entry = entry.next;
    }
    constantPool.put122(
        tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));
    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));
  }

  /**
   * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info
   * to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}
   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.
   * @param owner the internal name of a class.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   */
  private void addConstantMemberReference(
      final int index,
      final int tag,
      final @InternalForm String owner,
      final String name,
      final String descriptor) {
    add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));
  }

  /**
   * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a string.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantString(final String value) {
    return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);
  }

  /**
   * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value an int.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantInteger(final int value) {
    return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);
  }

  /**
   * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a float.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantFloat(final float value) {
    return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));
  }

  /**
   * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.
   * Does nothing if the constant pool already contains a similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.
   * @param value an int or float.
   * @return a constant pool constant with the given tag and primitive values.
   */
  private Symbol addConstantIntegerOrFloat(final int tag, final int value) {
    int hashCode = hash(tag, value);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {
        return entry;
      }
      entry = entry.next;
    }
    constantPool.putByte(tag).putInt(value);
    return put(new Entry(constantPoolCount++, tag, value, hashCode));
  }

  /**
   * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol
   * table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.
   * @param value an int or float.
   */
  private void addConstantIntegerOrFloat(final int index, final int tag, final int value) {
    add(new Entry(index, tag, value, hash(tag, value)));
  }

  /**
   * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a long.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantLong(final long value) {
    return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);
  }

  /**
   * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a double.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantDouble(final double value) {
    return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));
  }

  /**
   * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.
   * Does nothing if the constant pool already contains a similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.
   * @param value a long or double.
   * @return a constant pool constant with the given tag and primitive values.
   */
  private Symbol addConstantLongOrDouble(final int tag, final long value) {
    int hashCode = hash(tag, value);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {
        return entry;
      }
      entry = entry.next;
    }
    int index = constantPoolCount;
    constantPool.putByte(tag).putLong(value);
    constantPoolCount += 2;
    return put(new Entry(index, tag, value, hashCode));
  }

  /**
   * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol
   * table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.
   * @param value a long or double.
   */
  private void addConstantLongOrDouble(final int index, final int tag, final long value) {
    add(new Entry(index, tag, value, hash(tag, value)));
  }

  /**
   * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   * @return a new or already existing Symbol with the given value.
   */
  int addConstantNameAndType(final String name, final String descriptor) {
    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;
    int hashCode = hash(tag, name, descriptor);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == tag
          && entry.hashCode == hashCode
          && entry.name.equals(name)
          && entry.value.equals(descriptor)) {
        return entry.index;
      }
      entry = entry.next;
    }
    constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));
    return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;
  }

  /**
   * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   */
  private void addConstantNameAndType(final int index, final String name, final String descriptor) {
    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;
    add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));
  }

  /**
   * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param value a string.
   * @return a new or already existing Symbol with the given value.
   */
  int addConstantUtf8(final String value) {
    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == Symbol.CONSTANT_UTF8_TAG
          && entry.hashCode == hashCode
          && entry.value.equals(value)) {
        return entry.index;
      }
      entry = entry.next;
    }
    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);
    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;
  }

  /**
   * Adds a new CONSTANT_String_info to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param value a string.
   */
  private void addConstantUtf8(final int index, final String value) {
    add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));
  }

  /**
   * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if
   * the constant pool already contains a similar item.
   *
   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link
   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link
   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link
   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   * @param owner the internal name of a class of interface.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   * @param isInterface whether owner is an interface or not.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantMethodHandle(
      final int referenceKind,
      final @InternalForm String owner,
      final String name,
      final String descriptor,
      final boolean isInterface) {
    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;
    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);
    // Note that we don't need to include isInterface in the hash computation, because it is
    // redundant with owner (we can't have the same owner with different isInterface values).
    int hashCode = hash(tag, owner, name, descriptor, data);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == tag
          && entry.hashCode == hashCode
          && entry.data == data
          && entry.owner.equals(owner)
          && entry.name.equals(name)
          && entry.value.equals(descriptor)) {
        return entry;
      }
      entry = entry.next;
    }
    if (referenceKind <= Opcodes.H_PUTSTATIC) {
      constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);
    } else {
      constantPool.put112(
          tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);
    }
    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, data, hashCode));
  }

  /**
   * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link
   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link
   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link
   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   * @param owner the internal name of a class of interface.
   * @param name a field or method name.
   * @param descriptor a field or method descriptor.
   * @param isInterface whether owner is an interface or not.
   */
  private void addConstantMethodHandle(
      final int index,
      final int referenceKind,
      final @InternalForm String owner,
      final String name,
      final String descriptor,
      final boolean isInterface) {
    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;
    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);
    int hashCode = hash(tag, owner, name, descriptor, data);
    add(new Entry(index, tag, owner, name, descriptor, data, hashCode));
  }

  /**
   * Returns the {@link Symbol#data} field for a CONSTANT_MethodHandle_info Symbol.
   *
   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link
   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link
   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link
   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   * @param isInterface whether owner is an interface or not.
   */
  private static int getConstantMethodHandleSymbolData(
      final int referenceKind, final boolean isInterface) {
    if (referenceKind > Opcodes.H_PUTSTATIC && isInterface) {
      return referenceKind << 8;
    }
    return referenceKind;
  }

  /**
   * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param methodDescriptor a method descriptor.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantMethodType(final String methodDescriptor) {
    return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);
  }

  /**
   * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related
   * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant
   * pool already contains a similar item.
   *
   * @param name a method name.
   * @param descriptor a field descriptor.
   * @param bootstrapMethodHandle a bootstrap method handle.
   * @param bootstrapMethodArguments the bootstrap method arguments.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantDynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);
    return addConstantDynamicOrInvokeDynamicReference(
        Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);
  }

  /**
   * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the
   * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param name a method name.
   * @param descriptor a method descriptor.
   * @param bootstrapMethodHandle a bootstrap method handle.
   * @param bootstrapMethodArguments the bootstrap method arguments.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantInvokeDynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);
    return addConstantDynamicOrInvokeDynamicReference(
        Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);
  }

  /**
   * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol
   * table. Does nothing if the constant pool already contains a similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link
   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.
   * @param name a method name.
   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for
   *     CONSTANT_INVOKE_DYNAMIC_TAG.
   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.
   * @return a new or already existing Symbol with the given value.
   */
  private Symbol addConstantDynamicOrInvokeDynamicReference(
      final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {
    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == tag
          && entry.hashCode == hashCode
          && entry.data == bootstrapMethodIndex
          && entry.name.equals(name)
          && entry.value.equals(descriptor)) {
        return entry;
      }
      entry = entry.next;
    }
    constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));
    return put(
        new Entry(
            constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));
  }

  /**
   * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this
   * symbol table.
   *
   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link
   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.
   * @param index the constant pool index of the new Symbol.
   * @param name a method name.
   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for
   *     CONSTANT_INVOKE_DYNAMIC_TAG.
   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.
   */
  private void addConstantDynamicOrInvokeDynamicReference(
      final int tag,
      final int index,
      final String name,
      final String descriptor,
      final int bootstrapMethodIndex) {
    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);
    add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));
  }

  /**
   * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param moduleName a fully qualified name (using dots) of a module.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantModule(final @FullyQualifiedName String moduleName) {
    return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);
  }

  /**
   * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the
   * constant pool already contains a similar item.
   *
   * @param packageName the internal name of a package.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addConstantPackage(final String packageName) {
    return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);
  }

  /**
   * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,
   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does
   * nothing if the constant pool already contains a similar item.
   *
   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link
   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link
   *     Symbol#CONSTANT_PACKAGE_TAG}.
   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a
   *     package name, depending on tag.
   * @return a new or already existing Symbol with the given value.
   */
  private Symbol addConstantUtf8Reference(final int tag, final String value) {
    int hashCode = hash(tag, value);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {
        return entry;
      }
      entry = entry.next;
    }
    constantPool.put12(tag, addConstantUtf8(value));
    return put(new Entry(constantPoolCount++, tag, value, hashCode));
  }

  /**
   * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,
   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.
   *
   * @param index the constant pool index of the new Symbol.
   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link
   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link
   *     Symbol#CONSTANT_PACKAGE_TAG}.
   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a
   *     package name, depending on tag.
   */
  private void addConstantUtf8Reference(final int index, final int tag, final String value) {
    add(new Entry(index, tag, value, hash(tag, value)));
  }

  // -----------------------------------------------------------------------------------------------
  // Bootstrap method entries management.
  // -----------------------------------------------------------------------------------------------

  /**
   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if
   * the BootstrapMethods already contains a similar bootstrap method.
   *
   * @param bootstrapMethodHandle a bootstrap method handle.
   * @param bootstrapMethodArguments the bootstrap method arguments.
   * @return a new or already existing Symbol with the given value.
   */
  Symbol addBootstrapMethod(
      final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {
    ByteVector bootstrapMethodsAttribute = bootstrapMethods;
    if (bootstrapMethodsAttribute == null) {
      bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();
    }

    // The bootstrap method arguments can be Constant_Dynamic values, which reference other
    // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool
    // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified
    // while adding the given bootstrap method to it, in the rest of this method.
    int numBootstrapArguments = bootstrapMethodArguments.length;
    int[] bootstrapMethodArgumentIndexes = new int[numBootstrapArguments];
    for (int i = 0; i < numBootstrapArguments; i++) {
      bootstrapMethodArgumentIndexes[i] = addConstant(bootstrapMethodArguments[i]).index;
    }

    // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to
    // compare it with existing ones, and will be reverted below if there is already a similar
    // bootstrap method.
    int bootstrapMethodOffset = bootstrapMethodsAttribute.length;
    bootstrapMethodsAttribute.putShort(
        addConstantMethodHandle(
                bootstrapMethodHandle.getTag(),
                bootstrapMethodHandle.getOwner(),
                bootstrapMethodHandle.getName(),
                bootstrapMethodHandle.getDesc(),
                bootstrapMethodHandle.isInterface())
            .index);

    bootstrapMethodsAttribute.putShort(numBootstrapArguments);
    for (int i = 0; i < numBootstrapArguments; i++) {
      bootstrapMethodsAttribute.putShort(bootstrapMethodArgumentIndexes[i]);
    }

    // Compute the length and the hash code of the bootstrap method.
    int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;
    int hashCode = bootstrapMethodHandle.hashCode();
    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {
      hashCode ^= bootstrapMethodArgument.hashCode();
    }
    hashCode &= 0x7FFFFFFF;

    // Add the bootstrap method to the symbol table or revert the above changes.
    return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);
  }

  /**
   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if
   * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the
   * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).
   *
   * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.
   * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.
   * @param hashCode the hash code of this bootstrap method.
   * @return a new or already existing Symbol with the given value.
   */
  private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {
    final byte[] bootstrapMethodsData = bootstrapMethods.data;
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {
        int otherOffset = (int) entry.data;
        boolean isSameBootstrapMethod = true;
        for (int i = 0; i < length; ++i) {
          if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {
            isSameBootstrapMethod = false;
            break;
          }
        }
        if (isSameBootstrapMethod) {
          bootstrapMethods.length = offset; // Revert to old position.
          return entry;
        }
      }
      entry = entry.next;
    }
    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));
  }

  // -----------------------------------------------------------------------------------------------
  // Type table entries management.
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the type table element whose index is given.
   *
   * @param typeIndex a type table index.
   * @return the type table element whose index is given.
   */
  Symbol getType(final int typeIndex) {
    return typeTable[typeIndex];
  }

  /**
   * Returns the label corresponding to the "forward uninitialized" type table element whose index
   * is given.
   *
   * @param typeIndex the type table index of a "forward uninitialized" type table element.
   * @return the label corresponding of the NEW instruction which created this "forward
   *     uninitialized" type.
   */
  Label getForwardUninitializedLabel(final int typeIndex) {
    return labelTable[(int) typeTable[typeIndex].data].label;
  }

  /**
   * Adds a type in the type table of this symbol table. Does nothing if the type table already
   * contains a similar type.
   *
   * @param value an internal class name.
   * @return the index of a new or already existing type Symbol with the given value.
   */
  int addType(final String value) {
    int hashCode = hash(Symbol.TYPE_TAG, value);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {
        return entry.index;
      }
      entry = entry.next;
    }
    return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));
  }

  /**
   * Adds an uninitialized type in the type table of this symbol table. Does nothing if the type
   * table already contains a similar type.
   *
   * @param value an internal class name.
   * @param bytecodeOffset the bytecode offset of the NEW instruction that created this
   *     uninitialized type value.
   * @return the index of a new or already existing type #@link Symbol} with the given value.
   */
  int addUninitializedType(final String value, final int bytecodeOffset) {
    int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG
          && entry.hashCode == hashCode
          && entry.data == bytecodeOffset
          && entry.value.equals(value)) {
        return entry.index;
      }
      entry = entry.next;
    }
    return addTypeInternal(
        new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));
  }

  /**
   * Adds a "forward uninitialized" type in the type table of this symbol table. Does nothing if the
   * type table already contains a similar type.
   *
   * @param value an internal class name.
   * @param label the label of the NEW instruction that created this uninitialized type value. If
   *     the label is resolved, use the {@link #addUninitializedType} method instead.
   * @return the index of a new or already existing type {@link Symbol} with the given value.
   */
  int addForwardUninitializedType(final String value, final Label label) {
    int labelIndex = getOrAddLabelEntry(label).index;
    int hashCode = hash(Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == Symbol.FORWARD_UNINITIALIZED_TYPE_TAG
          && entry.hashCode == hashCode
          && entry.data == labelIndex
          && entry.value.equals(value)) {
        return entry.index;
      }
      entry = entry.next;
    }
    return addTypeInternal(
        new Entry(typeCount, Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex, hashCode));
  }

  /**
   * Adds a merged type in the type table of this symbol table. Does nothing if the type table
   * already contains a similar type.
   *
   * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type
   *     table.
   * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type
   *     table.
   * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,
   *     corresponding to the common super class of the given types.
   */
  int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {
    long data =
        typeTableIndex1 < typeTableIndex2
            ? typeTableIndex1 | (((long) typeTableIndex2) << 32)
            : typeTableIndex2 | (((long) typeTableIndex1) << 32);
    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);
    Entry entry = get(hashCode);
    while (entry != null) {
      if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {
        return entry.info;
      }
      entry = entry.next;
    }
    String type1 = typeTable[typeTableIndex1].value;
    String type2 = typeTable[typeTableIndex2].value;
    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));
    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;
    return commonSuperTypeIndex;
  }

  /**
   * Adds the given type Symbol to {@link #typeTable}.
   *
   * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.
   *     The index of this Symbol must be equal to the current value of {@link #typeCount}.
   * @return the index in {@link #typeTable} where the given type was added, which is also equal to
   *     entry's index by hypothesis.
   */
  private int addTypeInternal(final Entry entry) {
    if (typeTable == null) {
      typeTable = new Entry[16];
    }
    if (typeCount == typeTable.length) {
      Entry[] newTypeTable = new Entry[2 * typeTable.length];
      System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);
      typeTable = newTypeTable;
    }
    typeTable[typeCount++] = entry;
    return put(entry).index;
  }

  /**
   * Returns the {@link LabelEntry} corresponding to the given label. Creates a new one if there is
   * no such entry.
   *
   * @param label the {@link Label} of a NEW instruction which created an uninitialized type, in the
   *     case where this NEW instruction is after the &lt;init&gt; constructor call (in bytecode
   *     offset order). See {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}.
   * @return the {@link LabelEntry} corresponding to {@code label}.
   */
  private LabelEntry getOrAddLabelEntry(final Label label) {
    if (labelEntries == null) {
      labelEntries = new LabelEntry[16];
      labelTable = new LabelEntry[16];
    }
    int hashCode = System.identityHashCode(label);
    LabelEntry labelEntry = labelEntries[hashCode % labelEntries.length];
    while (labelEntry != null && labelEntry.label != label) {
      labelEntry = labelEntry.next;
    }
    if (labelEntry != null) {
      return labelEntry;
    }

    if (labelCount > (labelEntries.length * 3) / 4) {
      int currentCapacity = labelEntries.length;
      int newCapacity = currentCapacity * 2 + 1;
      LabelEntry[] newLabelEntries = new LabelEntry[newCapacity];
      for (int i = currentCapacity - 1; i >= 0; --i) {
        LabelEntry currentEntry = labelEntries[i];
        while (currentEntry != null) {
          int newCurrentEntryIndex = System.identityHashCode(currentEntry.label) % newCapacity;
          LabelEntry nextEntry = currentEntry.next;
          currentEntry.next = newLabelEntries[newCurrentEntryIndex];
          newLabelEntries[newCurrentEntryIndex] = currentEntry;
          currentEntry = nextEntry;
        }
      }
      labelEntries = newLabelEntries;
    }
    if (labelCount == labelTable.length) {
      LabelEntry[] newLabelTable = new LabelEntry[2 * labelTable.length];
      System.arraycopy(labelTable, 0, newLabelTable, 0, labelTable.length);
      labelTable = newLabelTable;
    }

    labelEntry = new LabelEntry(labelCount, label);
    int index = hashCode % labelEntries.length;
    labelEntry.next = labelEntries[index];
    labelEntries[index] = labelEntry;
    labelTable[labelCount++] = labelEntry;
    return labelEntry;
  }

  // -----------------------------------------------------------------------------------------------
  // Static helper methods to compute hash codes.
  // -----------------------------------------------------------------------------------------------

  private static int hash(final int tag, final int value) {
    return 0x7FFFFFFF & (tag + value);
  }

  private static int hash(final int tag, final long value) {
    return 0x7FFFFFFF & (tag + (int) value + (int) (value >>> 32));
  }

  private static int hash(final int tag, final String value) {
    return 0x7FFFFFFF & (tag + value.hashCode());
  }

  private static int hash(final int tag, final String value1, final int value2) {
    return 0x7FFFFFFF & (tag + value1.hashCode() + value2);
  }

  private static int hash(final int tag, final String value1, final String value2) {
    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());
  }

  private static int hash(
      final int tag, final String value1, final String value2, final int value3) {
    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));
  }

  private static int hash(
      final int tag, final String value1, final String value2, final String value3) {
    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());
  }

  private static int hash(
      final int tag,
      final String value1,
      final String value2,
      final String value3,
      final int value4) {
    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);
  }

  /**
   * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields
   * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid
   * duplicate symbols). See {@link #entries}.
   *
   * @author Eric Bruneton
   */
  private static final class Entry extends Symbol {

    /** The hash code of this entry. */
    final int hashCode;

    /**
     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link
     * #entries}) as this one.
     */
    Entry next;

    Entry(
        final int index,
        final int tag,
        final @InternalForm String owner,
        final @Identifier String name,
        final String value,
        final long data,
        final int hashCode) {
      super(index, tag, owner, name, value, data);
      this.hashCode = hashCode;
    }

    Entry(final int index, final int tag, final String value, final int hashCode) {
      super(index, tag, /* owner= */ null, /* name= */ null, value, /* data= */ 0);
      this.hashCode = hashCode;
    }

    Entry(final int index, final int tag, final String value, final long data, final int hashCode) {
      super(index, tag, /* owner= */ null, /* name= */ null, value, data);
      this.hashCode = hashCode;
    }

    Entry(
        final int index, final int tag, final String name, final String value, final int hashCode) {
      super(index, tag, /* owner= */ null, name, value, /* data= */ 0);
      this.hashCode = hashCode;
    }

    Entry(final int index, final int tag, final long data, final int hashCode) {
      super(index, tag, /* owner= */ null, /* name= */ null, /* value= */ null, data);
      this.hashCode = hashCode;
    }
  }

  /**
   * A label corresponding to a "forward uninitialized" type in the ASM specific {@link
   * SymbolTable#typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}).
   *
   * @author Eric Bruneton
   */
  private static final class LabelEntry {

    /** The index of this label entry in the {@link SymbolTable#labelTable} array. */
    final int index;

    /** The value of this label entry. */
    final Label label;

    /**
     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link
     * SymbolTable#labelEntries}}) as this one.
     */
    LabelEntry next;

    LabelEntry(final int index, final Label label) {
      this.index = index;
      this.label = label;
    }
  }
}

package org.objectweb.asm;

/**
 * The input and output stack map frames of a basic block.
 *
 * <p>Stack map frames are computed in two steps:
 *
 * <ul>
 *   <li>During the visit of each instruction in MethodWriter, the state of the frame at the end of
 *       the current basic block is updated by simulating the action of the instruction on the
 *       previous state of this so called "output frame".
 *   <li>After all instructions have been visited, a fix point algorithm is used in MethodWriter to
 *       compute the "input frame" of each basic block (i.e. the stack map frame at the beginning of
 *       the basic block). See {@link MethodWriter#computeAllFrames}.
 * </ul>
 *
 * <p>Output stack map frames are computed relatively to the input frame of the basic block, which
 * is not yet known when output frames are computed. It is therefore necessary to be able to
 * represent abstract types such as "the type at position x in the input frame locals" or "the type
 * at position x from the top of the input frame stack" or even "the type at position x in the input
 * frame, with y more (or less) array dimensions". This explains the rather complicated type format
 * used in this class, explained below.
 *
 * <p>The local variables and the operand stack of input and output frames contain values called
 * "abstract types" hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS
 * and VALUE, packed in a single int value for better performance and memory efficiency:
 *
 * <pre>
 *   =====================================
 *   |...DIM|KIND|.F|...............VALUE|
 *   =====================================
 * </pre>
 *
 * <ul>
 *   <li>the DIM field, stored in the 6 most significant bits, is a signed number of array
 *       dimensions (from -32 to 31, included). It can be retrieved with {@link #DIM_MASK} and a
 *       right shift of {@link #DIM_SHIFT}.
 *   <li>the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be
 *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link
 *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link
 *       #FORWARD_UNINITIALIZED_KIND},{@link #LOCAL_KIND} or {@link #STACK_KIND}.
 *   <li>the FLAGS field, stored in 2 bits, contains up to 2 boolean flags. Currently only one flag
 *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.
 *   <li>the VALUE field, stored in the remaining 20 bits, contains either
 *       <ul>
 *         <li>one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link
 *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link
 *             #ITEM_INTEGER}, {@link #ITEM_FLOAT}, {@link #ITEM_LONG}, {@link #ITEM_DOUBLE}, {@link
 *             #ITEM_NULL} or {@link #ITEM_UNINITIALIZED_THIS}, if KIND is equal to {@link
 *             #CONSTANT_KIND}.
 *         <li>the index of a {@link Symbol#TYPE_TAG} {@link Symbol} in the type table of a {@link
 *             SymbolTable}, if KIND is equal to {@link #REFERENCE_KIND}.
 *         <li>the index of an {@link Symbol#UNINITIALIZED_TYPE_TAG} {@link Symbol} in the type
 *             table of a {@link SymbolTable}, if KIND is equal to {@link #UNINITIALIZED_KIND}.
 *         <li>the index of a {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} {@link Symbol} in the
 *             type table of a {@link SymbolTable}, if KIND is equal to {@link
 *             #FORWARD_UNINITIALIZED_KIND}.
 *         <li>the index of a local variable in the input stack frame, if KIND is equal to {@link
 *             #LOCAL_KIND}.
 *         <li>a position relatively to the top of the stack of the input stack frame, if KIND is
 *             equal to {@link #STACK_KIND},
 *       </ul>
 * </ul>
 *
 * <p>Output frames can contain abstract types of any kind and with a positive or negative array
 * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid
 * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND,
 * UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract types of positive or {@literal null}
 * array dimension. In all cases the type table contains only internal type names (array type
 * descriptors are forbidden - array dimensions must be represented through the DIM field).
 *
 * <p>The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +
 * TOP), for local variables as well as in the operand stack. This is necessary to be able to
 * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented
 * by the abstract types in the stack (which are not always known).
 *
 * @author Eric Bruneton
 */
class Frame {

  // Constants used in the StackMapTable attribute.
  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.

  static final int SAME_FRAME = 0;
  static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;
  static final int RESERVED = 128;
  static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;
  static final int CHOP_FRAME = 248;
  static final int SAME_FRAME_EXTENDED = 251;
  static final int APPEND_FRAME = 252;
  static final int FULL_FRAME = 255;

  static final int ITEM_TOP = 0;
  static final int ITEM_INTEGER = 1;
  static final int ITEM_FLOAT = 2;
  static final int ITEM_DOUBLE = 3;
  static final int ITEM_LONG = 4;
  static final int ITEM_NULL = 5;
  static final int ITEM_UNINITIALIZED_THIS = 6;
  static final int ITEM_OBJECT = 7;
  static final int ITEM_UNINITIALIZED = 8;
  // Additional, ASM specific constants used in abstract types below.
  private static final int ITEM_ASM_BOOLEAN = 9;
  private static final int ITEM_ASM_BYTE = 10;
  private static final int ITEM_ASM_CHAR = 11;
  private static final int ITEM_ASM_SHORT = 12;

  // The size and offset in bits of each field of an abstract type.

  private static final int DIM_SIZE = 6;
  private static final int KIND_SIZE = 4;
  private static final int FLAGS_SIZE = 2;
  private static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;

  private static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;
  private static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;
  private static final int FLAGS_SHIFT = VALUE_SIZE;

  // Bitmasks to get each field of an abstract type.

  private static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;
  private static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;
  private static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;

  // Constants to manipulate the DIM field of an abstract type.

  /** The constant to be added to an abstract type to get one with one more array dimension. */
  private static final int ARRAY_OF = +1 << DIM_SHIFT;

  /** The constant to be added to an abstract type to get one with one less array dimension. */
  private static final int ELEMENT_OF = -1 << DIM_SHIFT;

  // Possible values for the KIND field of an abstract type.

  private static final int CONSTANT_KIND = 1 << KIND_SHIFT;
  private static final int REFERENCE_KIND = 2 << KIND_SHIFT;
  private static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;
  private static final int FORWARD_UNINITIALIZED_KIND = 4 << KIND_SHIFT;
  private static final int LOCAL_KIND = 5 << KIND_SHIFT;
  private static final int STACK_KIND = 6 << KIND_SHIFT;

  // Possible flags for the FLAGS field of an abstract type.

  /**
   * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,
   * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been
   * partially overridden with an xSTORE instruction).
   */
  private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;

  // Useful predefined abstract types (all the possible CONSTANT_KIND types).

  private static final int TOP = CONSTANT_KIND | ITEM_TOP;
  private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;
  private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;
  private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;
  private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;
  private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;
  private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;
  private static final int LONG = CONSTANT_KIND | ITEM_LONG;
  private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;
  private static final int NULL = CONSTANT_KIND | ITEM_NULL;
  private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;

  // -----------------------------------------------------------------------------------------------
  // Instance fields
  // -----------------------------------------------------------------------------------------------

  /** The basic block to which these input and output stack map frames correspond. */
  Label owner;

  /** The input stack map frame locals. This is an array of abstract types. */
  private int[] inputLocals;

  /** The input stack map frame stack. This is an array of abstract types. */
  private int[] inputStack;

  /** The output stack map frame locals. This is an array of abstract types. */
  private int[] outputLocals;

  /** The output stack map frame stack. This is an array of abstract types. */
  private int[] outputStack;

  /**
   * The start of the output stack, relatively to the input stack. This offset is always negative or
   * null. A null offset means that the output stack must be appended to the input stack. A -n
   * offset means that the first n output stack elements must replace the top n input stack
   * elements, and that the other elements must be appended to the input stack.
   */
  private short outputStackStart;

  /** The index of the top stack element in {@link #outputStack}. */
  private short outputStackTop;

  /** The number of types that are initialized in the basic block. See {@link #initializations}. */
  private int initializationCount;

  /**
   * The abstract types that are initialized in the basic block. A constructor invocation on an
   * UNINITIALIZED, FORWARD_UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every
   * occurrence</i> of this type in the local variables and in the operand stack. This cannot be
   * done during the first step of the algorithm since, during this step, the local variables and
   * the operand stack types are still abstract. It is therefore necessary to store the abstract
   * types of the constructors which are invoked in the basic block, in order to do this replacement
   * during the second step of the algorithm, where the frames are fully computed. Note that this
   * array can contain abstract types that are relative to the input locals or to the input stack.
   */
  private int[] initializations;

  // -----------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new Frame.
   *
   * @param owner the basic block to which these input and output stack map frames correspond.
   */
  Frame(final Label owner) {
    this.owner = owner;
  }

  /**
   * Sets this frame to the value of the given frame.
   *
   * <p>WARNING: after this method is called the two frames share the same data structures. It is
   * recommended to discard the given frame to avoid unexpected side effects.
   *
   * @param frame The new frame value.
   */
  final void copyFrom(final Frame frame) {
    inputLocals = frame.inputLocals;
    inputStack = frame.inputStack;
    outputStackStart = 0;
    outputLocals = frame.outputLocals;
    outputStack = frame.outputStack;
    outputStackTop = frame.outputStackTop;
    initializationCount = frame.initializationCount;
    initializations = frame.initializations;
  }

  // -----------------------------------------------------------------------------------------------
  // Static methods to get abstract types from other type formats
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the abstract type corresponding to the given public API frame element type.
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param type a frame element type described using the same format as in {@link
   *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link
   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or
   *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating
   *     a NEW instruction (for uninitialized types).
   * @return the abstract type corresponding to the given frame element type.
   */
  static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {
    if (type instanceof Integer) {
      return CONSTANT_KIND | ((Integer) type).intValue();
    } else if (type instanceof String) {
      String descriptor = Type.getObjectType((String) type).getDescriptor();
      return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);
    } else {
      Label label = (Label) type;
      if ((label.flags & Label.FLAG_RESOLVED) != 0) {
        return UNINITIALIZED_KIND | symbolTable.addUninitializedType("", label.bytecodeOffset);
      } else {
        return FORWARD_UNINITIALIZED_KIND | symbolTable.addForwardUninitializedType("", label);
      }
    }
  }

  /**
   * Returns the abstract type corresponding to the internal name of a class.
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param internalName the internal name of a class. This must <i>not</i> be an array type
   *     descriptor.
   * @return the abstract type value corresponding to the given internal name.
   */
  static int getAbstractTypeFromInternalName(
      final SymbolTable symbolTable, final @InternalForm String internalName) {
    return REFERENCE_KIND | symbolTable.addType(internalName);
  }

  /**
   * Returns the abstract type corresponding to the given type descriptor.
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param buffer a string ending with a type descriptor.
   * @param offset the start offset of the type descriptor in buffer.
   * @return the abstract type corresponding to the given type descriptor.
   */
  private static int getAbstractTypeFromDescriptor(
      final SymbolTable symbolTable, final String buffer, final int offset) {
    String internalName;
    switch (buffer.charAt(offset)) {
      case 'V':
        return 0;
      case 'Z':
      case 'C':
      case 'B':
      case 'S':
      case 'I':
        return INTEGER;
      case 'F':
        return FLOAT;
      case 'J':
        return LONG;
      case 'D':
        return DOUBLE;
      case 'L':
        internalName = buffer.substring(offset + 1, buffer.length() - 1);
        return REFERENCE_KIND | symbolTable.addType(internalName);
      case '[':
        int elementDescriptorOffset = offset + 1;
        while (buffer.charAt(elementDescriptorOffset) == '[') {
          ++elementDescriptorOffset;
        }
        int typeValue;
        switch (buffer.charAt(elementDescriptorOffset)) {
          case 'Z':
            typeValue = BOOLEAN;
            break;
          case 'C':
            typeValue = CHAR;
            break;
          case 'B':
            typeValue = BYTE;
            break;
          case 'S':
            typeValue = SHORT;
            break;
          case 'I':
            typeValue = INTEGER;
            break;
          case 'F':
            typeValue = FLOAT;
            break;
          case 'J':
            typeValue = LONG;
            break;
          case 'D':
            typeValue = DOUBLE;
            break;
          case 'L':
            internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);
            typeValue = REFERENCE_KIND | symbolTable.addType(internalName);
            break;
          default:
            throw new IllegalArgumentException(
                "Invalid descriptor fragment: " + buffer.substring(elementDescriptorOffset));
        }
        return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;
      default:
        throw new IllegalArgumentException("Invalid descriptor: " + buffer.substring(offset));
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Methods related to the input frame
  // -----------------------------------------------------------------------------------------------

  /**
   * Sets the input frame from the given method description. This method is used to initialize the
   * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable
   * attribute).
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param access the method's access flags.
   * @param descriptor the method descriptor.
   * @param maxLocals the maximum number of local variables of the method.
   */
  final void setInputFrameFromDescriptor(
      final SymbolTable symbolTable,
      final int access,
      final String descriptor,
      final int maxLocals) {
    inputLocals = new int[maxLocals];
    inputStack = new int[0];
    int inputLocalIndex = 0;
    if ((access & Opcodes.ACC_STATIC) == 0) {
      if ((access & Constants.ACC_CONSTRUCTOR) == 0) {
        inputLocals[inputLocalIndex++] =
            REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());
      } else {
        inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;
      }
    }
    for (Type argumentType : Type.getArgumentTypes(descriptor)) {
      int abstractType =
          getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);
      inputLocals[inputLocalIndex++] = abstractType;
      if (abstractType == LONG || abstractType == DOUBLE) {
        inputLocals[inputLocalIndex++] = TOP;
      }
    }
    while (inputLocalIndex < maxLocals) {
      inputLocals[inputLocalIndex++] = TOP;
    }
  }

  /**
   * Sets the input frame from the given public API frame description.
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param numLocal the number of local variables.
   * @param local the local variable types, described using the same format as in {@link
   *     MethodVisitor#visitFrame}.
   * @param numStack the number of operand stack elements.
   * @param stack the operand stack types, described using the same format as in {@link
   *     MethodVisitor#visitFrame}.
   */
  final void setInputFrameFromApiFormat(
      final SymbolTable symbolTable,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    int inputLocalIndex = 0;
    for (int i = 0; i < numLocal; ++i) {
      inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]);
      if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) {
        inputLocals[inputLocalIndex++] = TOP;
      }
    }
    while (inputLocalIndex < inputLocals.length) {
      inputLocals[inputLocalIndex++] = TOP;
    }
    int numStackTop = 0;
    for (int i = 0; i < numStack; ++i) {
      if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {
        ++numStackTop;
      }
    }
    inputStack = new int[numStack + numStackTop];
    int inputStackIndex = 0;
    for (int i = 0; i < numStack; ++i) {
      inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]);
      if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {
        inputStack[inputStackIndex++] = TOP;
      }
    }
    outputStackTop = 0;
    initializationCount = 0;
  }

  final int getInputStackSize() {
    return inputStack.length;
  }

  // -----------------------------------------------------------------------------------------------
  // Methods related to the output frame
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the abstract type stored at the given local variable index in the output frame.
   *
   * @param localIndex the index of the local variable whose value must be returned.
   * @return the abstract type stored at the given local variable index in the output frame.
   */
  private int getLocal(final int localIndex) {
    if (outputLocals == null || localIndex >= outputLocals.length) {
      // If this local has never been assigned in this basic block, it is still equal to its value
      // in the input frame.
      return LOCAL_KIND | localIndex;
    } else {
      int abstractType = outputLocals[localIndex];
      if (abstractType == 0) {
        // If this local has never been assigned in this basic block, so it is still equal to its
        // value in the input frame.
        abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;
      }
      return abstractType;
    }
  }

  /**
   * Replaces the abstract type stored at the given local variable index in the output frame.
   *
   * @param localIndex the index of the output frame local variable that must be set.
   * @param abstractType the value that must be set.
   */
  private void setLocal(final int localIndex, final int abstractType) {
    // Create and/or resize the output local variables array if necessary.
    if (outputLocals == null) {
      outputLocals = new int[10];
    }
    int outputLocalsLength = outputLocals.length;
    if (localIndex >= outputLocalsLength) {
      int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];
      System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);
      outputLocals = newOutputLocals;
    }
    // Set the local variable.
    outputLocals[localIndex] = abstractType;
  }

  /**
   * Pushes the given abstract type on the output frame stack.
   *
   * @param abstractType an abstract type.
   */
  private void push(final int abstractType) {
    // Create and/or resize the output stack array if necessary.
    if (outputStack == null) {
      outputStack = new int[10];
    }
    int outputStackLength = outputStack.length;
    if (outputStackTop >= outputStackLength) {
      int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];
      System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);
      outputStack = newOutputStack;
    }
    // Pushes the abstract type on the output stack.
    outputStack[outputStackTop++] = abstractType;
    // Updates the maximum size reached by the output stack, if needed (note that this size is
    // relative to the input stack size, which is not known yet).
    short outputStackSize = (short) (outputStackStart + outputStackTop);
    if (outputStackSize > owner.outputStackMax) {
      owner.outputStackMax = outputStackSize;
    }
  }

  /**
   * Pushes the abstract type corresponding to the given descriptor on the output frame stack.
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param descriptor a type or method descriptor (in which case its return type is pushed).
   */
  private void push(final SymbolTable symbolTable, final String descriptor) {
    int typeDescriptorOffset =
        descriptor.charAt(0) == '(' ? Type.getReturnTypeOffset(descriptor) : 0;
    int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);
    if (abstractType != 0) {
      push(abstractType);
      if (abstractType == LONG || abstractType == DOUBLE) {
        push(TOP);
      }
    }
  }

  /**
   * Pops an abstract type from the output frame stack and returns its value.
   *
   * @return the abstract type that has been popped from the output frame stack.
   */
  private int pop() {
    if (outputStackTop > 0) {
      return outputStack[--outputStackTop];
    } else {
      // If the output frame stack is empty, pop from the input stack.
      return STACK_KIND | -(--outputStackStart);
    }
  }

  /**
   * Pops the given number of abstract types from the output frame stack.
   *
   * @param elements the number of abstract types that must be popped.
   */
  private void pop(final int elements) {
    if (outputStackTop >= elements) {
      outputStackTop -= elements;
    } else {
      // If the number of elements to be popped is greater than the number of elements in the output
      // stack, clear it, and pop the remaining elements from the input stack.
      outputStackStart -= elements - outputStackTop;
      outputStackTop = 0;
    }
  }

  /**
   * Pops as many abstract types from the output frame stack as described by the given descriptor.
   *
   * @param descriptor a type or method descriptor (in which case its argument types are popped).
   */
  private void pop(final String descriptor) {
    char firstDescriptorChar = descriptor.charAt(0);
    if (firstDescriptorChar == '(') {
      pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);
    } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
      pop(2);
    } else {
      pop(1);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Methods to handle uninitialized types
  // -----------------------------------------------------------------------------------------------

  /**
   * Adds an abstract type to the list of types on which a constructor is invoked in the basic
   * block.
   *
   * @param abstractType an abstract type on a which a constructor is invoked.
   */
  private void addInitializedType(final int abstractType) {
    // Create and/or resize the initializations array if necessary.
    if (initializations == null) {
      initializations = new int[2];
    }
    int initializationsLength = initializations.length;
    if (initializationCount >= initializationsLength) {
      int[] newInitializations =
          new int[Math.max(initializationCount + 1, 2 * initializationsLength)];
      System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);
      initializations = newInitializations;
    }
    // Store the abstract type.
    initializations[initializationCount++] = abstractType;
  }

  /**
   * Returns the "initialized" abstract type corresponding to the given abstract type.
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param abstractType an abstract type.
   * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is
   *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract type for
   *     one of the types on which a constructor is invoked in the basic block. Otherwise returns
   *     abstractType.
   */
  private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {
    if (abstractType == UNINITIALIZED_THIS
        || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND
        || (abstractType & (DIM_MASK | KIND_MASK)) == FORWARD_UNINITIALIZED_KIND) {
      for (int i = 0; i < initializationCount; ++i) {
        int initializedType = initializations[i];
        int dim = initializedType & DIM_MASK;
        int kind = initializedType & KIND_MASK;
        int value = initializedType & VALUE_MASK;
        if (kind == LOCAL_KIND) {
          initializedType = dim + inputLocals[value];
        } else if (kind == STACK_KIND) {
          initializedType = dim + inputStack[inputStack.length - value];
        }
        if (abstractType == initializedType) {
          if (abstractType == UNINITIALIZED_THIS) {
            return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());
          } else {
            return REFERENCE_KIND
                | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value);
          }
        }
      }
    }
    return abstractType;
  }

  // -----------------------------------------------------------------------------------------------
  // Main method, to simulate the execution of each instruction on the output frame
  // -----------------------------------------------------------------------------------------------

  /**
   * Simulates the action of the given instruction on the output stack frame.
   *
   * @param opcode the opcode of the instruction.
   * @param arg the numeric operand of the instruction, if any.
   * @param argSymbol the Symbol operand of the instruction, if any.
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   */
  void execute(
      final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {
    // Abstract types popped from the stack or read from local variables.
    int abstractType1;
    int abstractType2;
    int abstractType3;
    int abstractType4;
    switch (opcode) {
      case Opcodes.NOP:
      case Opcodes.INEG:
      case Opcodes.LNEG:
      case Opcodes.FNEG:
      case Opcodes.DNEG:
      case Opcodes.I2B:
      case Opcodes.I2C:
      case Opcodes.I2S:
      case Opcodes.GOTO:
      case Opcodes.RETURN:
        break;
      case Opcodes.ACONST_NULL:
        push(NULL);
        break;
      case Opcodes.ICONST_M1:
      case Opcodes.ICONST_0:
      case Opcodes.ICONST_1:
      case Opcodes.ICONST_2:
      case Opcodes.ICONST_3:
      case Opcodes.ICONST_4:
      case Opcodes.ICONST_5:
      case Opcodes.BIPUSH:
      case Opcodes.SIPUSH:
      case Opcodes.ILOAD:
        push(INTEGER);
        break;
      case Opcodes.LCONST_0:
      case Opcodes.LCONST_1:
      case Opcodes.LLOAD:
        push(LONG);
        push(TOP);
        break;
      case Opcodes.FCONST_0:
      case Opcodes.FCONST_1:
      case Opcodes.FCONST_2:
      case Opcodes.FLOAD:
        push(FLOAT);
        break;
      case Opcodes.DCONST_0:
      case Opcodes.DCONST_1:
      case Opcodes.DLOAD:
        push(DOUBLE);
        push(TOP);
        break;
      case Opcodes.LDC:
        switch (argSymbol.tag) {
          case Symbol.CONSTANT_INTEGER_TAG:
            push(INTEGER);
            break;
          case Symbol.CONSTANT_LONG_TAG:
            push(LONG);
            push(TOP);
            break;
          case Symbol.CONSTANT_FLOAT_TAG:
            push(FLOAT);
            break;
          case Symbol.CONSTANT_DOUBLE_TAG:
            push(DOUBLE);
            push(TOP);
            break;
          case Symbol.CONSTANT_CLASS_TAG:
            push(REFERENCE_KIND | symbolTable.addType("java/lang/Class"));
            break;
          case Symbol.CONSTANT_STRING_TAG:
            push(REFERENCE_KIND | symbolTable.addType("java/lang/String"));
            break;
          case Symbol.CONSTANT_METHOD_TYPE_TAG:
            push(REFERENCE_KIND | symbolTable.addType("java/lang/invoke/MethodType"));
            break;
          case Symbol.CONSTANT_METHOD_HANDLE_TAG:
            push(REFERENCE_KIND | symbolTable.addType("java/lang/invoke/MethodHandle"));
            break;
          case Symbol.CONSTANT_DYNAMIC_TAG:
            push(symbolTable, argSymbol.value);
            break;
          default:
            throw new AssertionError();
        }
        break;
      case Opcodes.ALOAD:
        push(getLocal(arg));
        break;
      case Opcodes.LALOAD:
      case Opcodes.D2L:
        pop(2);
        push(LONG);
        push(TOP);
        break;
      case Opcodes.DALOAD:
      case Opcodes.L2D:
        pop(2);
        push(DOUBLE);
        push(TOP);
        break;
      case Opcodes.AALOAD:
        pop(1);
        abstractType1 = pop();
        push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);
        break;
      case Opcodes.ISTORE:
      case Opcodes.FSTORE:
      case Opcodes.ASTORE:
        abstractType1 = pop();
        setLocal(arg, abstractType1);
        if (arg > 0) {
          int previousLocalType = getLocal(arg - 1);
          if (previousLocalType == LONG || previousLocalType == DOUBLE) {
            setLocal(arg - 1, TOP);
          } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND
              || (previousLocalType & KIND_MASK) == STACK_KIND) {
            // The type of the previous local variable is not known yet, but if it later appears
            // to be LONG or DOUBLE, we should then use TOP instead.
            setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);
          }
        }
        break;
      case Opcodes.LSTORE:
      case Opcodes.DSTORE:
        pop(1);
        abstractType1 = pop();
        setLocal(arg, abstractType1);
        setLocal(arg + 1, TOP);
        if (arg > 0) {
          int previousLocalType = getLocal(arg - 1);
          if (previousLocalType == LONG || previousLocalType == DOUBLE) {
            setLocal(arg - 1, TOP);
          } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND
              || (previousLocalType & KIND_MASK) == STACK_KIND) {
            // The type of the previous local variable is not known yet, but if it later appears
            // to be LONG or DOUBLE, we should then use TOP instead.
            setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);
          }
        }
        break;
      case Opcodes.IASTORE:
      case Opcodes.BASTORE:
      case Opcodes.CASTORE:
      case Opcodes.SASTORE:
      case Opcodes.FASTORE:
      case Opcodes.AASTORE:
        pop(3);
        break;
      case Opcodes.LASTORE:
      case Opcodes.DASTORE:
        pop(4);
        break;
      case Opcodes.POP:
      case Opcodes.IFEQ:
      case Opcodes.IFNE:
      case Opcodes.IFLT:
      case Opcodes.IFGE:
      case Opcodes.IFGT:
      case Opcodes.IFLE:
      case Opcodes.IRETURN:
      case Opcodes.FRETURN:
      case Opcodes.ARETURN:
      case Opcodes.TABLESWITCH:
      case Opcodes.LOOKUPSWITCH:
      case Opcodes.ATHROW:
      case Opcodes.MONITORENTER:
      case Opcodes.MONITOREXIT:
      case Opcodes.IFNULL:
      case Opcodes.IFNONNULL:
        pop(1);
        break;
      case Opcodes.POP2:
      case Opcodes.IF_ICMPEQ:
      case Opcodes.IF_ICMPNE:
      case Opcodes.IF_ICMPLT:
      case Opcodes.IF_ICMPGE:
      case Opcodes.IF_ICMPGT:
      case Opcodes.IF_ICMPLE:
      case Opcodes.IF_ACMPEQ:
      case Opcodes.IF_ACMPNE:
      case Opcodes.LRETURN:
      case Opcodes.DRETURN:
        pop(2);
        break;
      case Opcodes.DUP:
        abstractType1 = pop();
        push(abstractType1);
        push(abstractType1);
        break;
      case Opcodes.DUP_X1:
        abstractType1 = pop();
        abstractType2 = pop();
        push(abstractType1);
        push(abstractType2);
        push(abstractType1);
        break;
      case Opcodes.DUP_X2:
        abstractType1 = pop();
        abstractType2 = pop();
        abstractType3 = pop();
        push(abstractType1);
        push(abstractType3);
        push(abstractType2);
        push(abstractType1);
        break;
      case Opcodes.DUP2:
        abstractType1 = pop();
        abstractType2 = pop();
        push(abstractType2);
        push(abstractType1);
        push(abstractType2);
        push(abstractType1);
        break;
      case Opcodes.DUP2_X1:
        abstractType1 = pop();
        abstractType2 = pop();
        abstractType3 = pop();
        push(abstractType2);
        push(abstractType1);
        push(abstractType3);
        push(abstractType2);
        push(abstractType1);
        break;
      case Opcodes.DUP2_X2:
        abstractType1 = pop();
        abstractType2 = pop();
        abstractType3 = pop();
        abstractType4 = pop();
        push(abstractType2);
        push(abstractType1);
        push(abstractType4);
        push(abstractType3);
        push(abstractType2);
        push(abstractType1);
        break;
      case Opcodes.SWAP:
        abstractType1 = pop();
        abstractType2 = pop();
        push(abstractType1);
        push(abstractType2);
        break;
      case Opcodes.IALOAD:
      case Opcodes.BALOAD:
      case Opcodes.CALOAD:
      case Opcodes.SALOAD:
      case Opcodes.IADD:
      case Opcodes.ISUB:
      case Opcodes.IMUL:
      case Opcodes.IDIV:
      case Opcodes.IREM:
      case Opcodes.IAND:
      case Opcodes.IOR:
      case Opcodes.IXOR:
      case Opcodes.ISHL:
      case Opcodes.ISHR:
      case Opcodes.IUSHR:
      case Opcodes.L2I:
      case Opcodes.D2I:
      case Opcodes.FCMPL:
      case Opcodes.FCMPG:
        pop(2);
        push(INTEGER);
        break;
      case Opcodes.LADD:
      case Opcodes.LSUB:
      case Opcodes.LMUL:
      case Opcodes.LDIV:
      case Opcodes.LREM:
      case Opcodes.LAND:
      case Opcodes.LOR:
      case Opcodes.LXOR:
        pop(4);
        push(LONG);
        push(TOP);
        break;
      case Opcodes.FALOAD:
      case Opcodes.FADD:
      case Opcodes.FSUB:
      case Opcodes.FMUL:
      case Opcodes.FDIV:
      case Opcodes.FREM:
      case Opcodes.L2F:
      case Opcodes.D2F:
        pop(2);
        push(FLOAT);
        break;
      case Opcodes.DADD:
      case Opcodes.DSUB:
      case Opcodes.DMUL:
      case Opcodes.DDIV:
      case Opcodes.DREM:
        pop(4);
        push(DOUBLE);
        push(TOP);
        break;
      case Opcodes.LSHL:
      case Opcodes.LSHR:
      case Opcodes.LUSHR:
        pop(3);
        push(LONG);
        push(TOP);
        break;
      case Opcodes.IINC:
        setLocal(arg, INTEGER);
        break;
      case Opcodes.I2L:
      case Opcodes.F2L:
        pop(1);
        push(LONG);
        push(TOP);
        break;
      case Opcodes.I2F:
        pop(1);
        push(FLOAT);
        break;
      case Opcodes.I2D:
      case Opcodes.F2D:
        pop(1);
        push(DOUBLE);
        push(TOP);
        break;
      case Opcodes.F2I:
      case Opcodes.ARRAYLENGTH:
      case Opcodes.INSTANCEOF:
        pop(1);
        push(INTEGER);
        break;
      case Opcodes.LCMP:
      case Opcodes.DCMPL:
      case Opcodes.DCMPG:
        pop(4);
        push(INTEGER);
        break;
      case Opcodes.JSR:
      case Opcodes.RET:
        throw new IllegalArgumentException("JSR/RET are not supported with computeFrames option");
      case Opcodes.GETSTATIC:
        push(symbolTable, argSymbol.value);
        break;
      case Opcodes.PUTSTATIC:
        pop(argSymbol.value);
        break;
      case Opcodes.GETFIELD:
        pop(1);
        push(symbolTable, argSymbol.value);
        break;
      case Opcodes.PUTFIELD:
        pop(argSymbol.value);
        pop();
        break;
      case Opcodes.INVOKEVIRTUAL:
      case Opcodes.INVOKESPECIAL:
      case Opcodes.INVOKESTATIC:
      case Opcodes.INVOKEINTERFACE:
        pop(argSymbol.value);
        if (opcode != Opcodes.INVOKESTATIC) {
          abstractType1 = pop();
          if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {
            addInitializedType(abstractType1);
          }
        }
        push(symbolTable, argSymbol.value);
        break;
      case Opcodes.INVOKEDYNAMIC:
        pop(argSymbol.value);
        push(symbolTable, argSymbol.value);
        break;
      case Opcodes.NEW:
        push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));
        break;
      case Opcodes.NEWARRAY:
        pop();
        switch (arg) {
          case Opcodes.T_BOOLEAN:
            push(ARRAY_OF | BOOLEAN);
            break;
          case Opcodes.T_CHAR:
            push(ARRAY_OF | CHAR);
            break;
          case Opcodes.T_BYTE:
            push(ARRAY_OF | BYTE);
            break;
          case Opcodes.T_SHORT:
            push(ARRAY_OF | SHORT);
            break;
          case Opcodes.T_INT:
            push(ARRAY_OF | INTEGER);
            break;
          case Opcodes.T_FLOAT:
            push(ARRAY_OF | FLOAT);
            break;
          case Opcodes.T_DOUBLE:
            push(ARRAY_OF | DOUBLE);
            break;
          case Opcodes.T_LONG:
            push(ARRAY_OF | LONG);
            break;
          default:
            throw new IllegalArgumentException();
        }
        break;
      case Opcodes.ANEWARRAY:
        String arrayElementType = argSymbol.value;
        pop();
        if (arrayElementType.charAt(0) == '[') {
          push(symbolTable, '[' + arrayElementType);
        } else {
          push(ARRAY_OF | REFERENCE_KIND | symbolTable.addType(arrayElementType));
        }
        break;
      case Opcodes.CHECKCAST:
        String castType = argSymbol.value;
        pop();
        if (castType.charAt(0) == '[') {
          push(symbolTable, castType);
        } else {
          push(REFERENCE_KIND | symbolTable.addType(castType));
        }
        break;
      case Opcodes.MULTIANEWARRAY:
        pop(arg);
        push(symbolTable, argSymbol.value);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Frame merging methods, used in the second step of the stack map frame computation algorithm
  // -----------------------------------------------------------------------------------------------

  /**
   * Computes the concrete output type corresponding to a given abstract output type.
   *
   * @param abstractOutputType an abstract output type.
   * @param numStack the size of the input stack, used to resolve abstract output types of
   *     STACK_KIND kind.
   * @return the concrete output type corresponding to 'abstractOutputType'.
   */
  private int getConcreteOutputType(final int abstractOutputType, final int numStack) {
    int dim = abstractOutputType & DIM_MASK;
    int kind = abstractOutputType & KIND_MASK;
    if (kind == LOCAL_KIND) {
      // By definition, a LOCAL_KIND type designates the concrete type of a local variable at
      // the beginning of the basic block corresponding to this frame (which is known when
      // this method is called, but was not when the abstract type was computed).
      int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];
      if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
          && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
        concreteOutputType = TOP;
      }
      return concreteOutputType;
    } else if (kind == STACK_KIND) {
      // By definition, a STACK_KIND type designates the concrete type of a local variable at
      // the beginning of the basic block corresponding to this frame (which is known when
      // this method is called, but was not when the abstract type was computed).
      int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];
      if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
          && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
        concreteOutputType = TOP;
      }
      return concreteOutputType;
    } else {
      return abstractOutputType;
    }
  }

  /**
   * Merges the input frame of the given {@link Frame} with the input and output frames of this
   * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation
   * (the input and output frames of this {@link Frame} are never changed).
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame
   *     of a successor, in the control flow graph, of the basic block corresponding to this frame.
   * @param catchTypeIndex if 'frame' corresponds to an exception handler basic block, the type
   *     table index of the caught exception type, otherwise 0.
   * @return {@literal true} if the input frame of 'frame' has been changed by this operation.
   */
  final boolean merge(
      final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {
    boolean frameChanged = false;

    // Compute the concrete types of the local variables at the end of the basic block corresponding
    // to this frame, by resolving its abstract output types, and merge these concrete types with
    // those of the local variables in the input frame of dstFrame.
    int numLocal = inputLocals.length;
    int numStack = inputStack.length;
    if (dstFrame.inputLocals == null) {
      dstFrame.inputLocals = new int[numLocal];
      frameChanged = true;
    }
    for (int i = 0; i < numLocal; ++i) {
      int concreteOutputType;
      if (outputLocals != null && i < outputLocals.length) {
        int abstractOutputType = outputLocals[i];
        if (abstractOutputType == 0) {
          // If the local variable has never been assigned in this basic block, it is equal to its
          // value at the beginning of the block.
          concreteOutputType = inputLocals[i];
        } else {
          concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);
        }
      } else {
        // If the local variable has never been assigned in this basic block, it is equal to its
        // value at the beginning of the block.
        concreteOutputType = inputLocals[i];
      }
      // concreteOutputType might be an uninitialized type from the input locals or from the input
      // stack. However, if a constructor has been called for this class type in the basic block,
      // then this type is no longer uninitialized at the end of basic block.
      if (initializations != null) {
        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
      }
      frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);
    }

    // If dstFrame is an exception handler block, it can be reached from any instruction of the
    // basic block corresponding to this frame, in particular from the first one. Therefore, the
    // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this
    // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one
    // element stack containing the caught exception type).
    if (catchTypeIndex > 0) {
      for (int i = 0; i < numLocal; ++i) {
        frameChanged |= merge(symbolTable, inputLocals[i], dstFrame.inputLocals, i);
      }
      if (dstFrame.inputStack == null) {
        dstFrame.inputStack = new int[1];
        frameChanged = true;
      }
      frameChanged |= merge(symbolTable, catchTypeIndex, dstFrame.inputStack, 0);
      return frameChanged;
    }

    // Compute the concrete types of the stack operands at the end of the basic block corresponding
    // to this frame, by resolving its abstract output types, and merge these concrete types with
    // those of the stack operands in the input frame of dstFrame.
    int numInputStack = inputStack.length + outputStackStart;
    if (dstFrame.inputStack == null) {
      dstFrame.inputStack = new int[numInputStack + outputStackTop];
      frameChanged = true;
    }
    // First, do this for the stack operands that have not been popped in the basic block
    // corresponding to this frame, and which are therefore equal to their value in the input
    // frame (except for uninitialized types, which may have been initialized).
    for (int i = 0; i < numInputStack; ++i) {
      int concreteOutputType = inputStack[i];
      if (initializations != null) {
        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
      }
      frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);
    }
    // Then, do this for the stack operands that have pushed in the basic block (this code is the
    // same as the one above for local variables).
    for (int i = 0; i < outputStackTop; ++i) {
      int abstractOutputType = outputStack[i];
      int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);
      if (initializations != null) {
        concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
      }
      frameChanged |=
          merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);
    }
    return frameChanged;
  }

  /**
   * Merges the type at the given index in the given abstract type array with the given type.
   * Returns {@literal true} if the type array has been modified by this operation.
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param sourceType the abstract type with which the abstract type array element must be merged.
   *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link
   *     #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND} kind, with positive or
   *     {@literal null} array dimensions.
   * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},
   *     {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND}
   *     kind, with positive or {@literal null} array dimensions.
   * @param dstIndex the index of the type that must be merged in dstTypes.
   * @return {@literal true} if the type array has been modified by this operation.
   */
  private static boolean merge(
      final SymbolTable symbolTable,
      final int sourceType,
      final int[] dstTypes,
      final int dstIndex) {
    int dstType = dstTypes[dstIndex];
    if (dstType == sourceType) {
      // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.
      return false;
    }
    int srcType = sourceType;
    if ((sourceType & ~DIM_MASK) == NULL) {
      if (dstType == NULL) {
        return false;
      }
      srcType = NULL;
    }
    if (dstType == 0) {
      // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.
      dstTypes[dstIndex] = srcType;
      return true;
    }
    int mergedType;
    if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {
      // If dstType is a reference type of any array dimension.
      if (srcType == NULL) {
        // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.
        return false;
      } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {
        // If srcType has the same array dimension and the same kind as dstType.
        if ((dstType & KIND_MASK) == REFERENCE_KIND) {
          // If srcType and dstType are reference types with the same array dimension,
          // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.
          mergedType =
              (srcType & DIM_MASK)
                  | REFERENCE_KIND
                  | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);
        } else {
          // If srcType and dstType are array types of equal dimension but different element types,
          // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.
          int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);
          mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType("java/lang/Object");
        }
      } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {
        // If srcType is any other reference or array type,
        // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object
        // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type
        // with a non reference element type (and similarly for dstDim).
        int srcDim = srcType & DIM_MASK;
        if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {
          srcDim = ELEMENT_OF + srcDim;
        }
        int dstDim = dstType & DIM_MASK;
        if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {
          dstDim = ELEMENT_OF + dstDim;
        }
        mergedType =
            Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType("java/lang/Object");
      } else {
        // If srcType is any other type, merge(srcType, dstType) = TOP.
        mergedType = TOP;
      }
    } else if (dstType == NULL) {
      // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a
      // an array type or a reference type.
      mergedType =
          (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;
    } else {
      // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.
      mergedType = TOP;
    }
    if (mergedType != dstType) {
      dstTypes[dstIndex] = mergedType;
      return true;
    }
    return false;
  }

  // -----------------------------------------------------------------------------------------------
  // Frame output methods, to generate StackMapFrame attributes
  // -----------------------------------------------------------------------------------------------

  /**
   * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is
   * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and
   * {@link MethodWriter#visitFrameEnd} methods.
   *
   * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link
   *     Frame}.
   */
  final void accept(final MethodWriter methodWriter) {
    // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and
    // all trailing TOP types.
    int[] localTypes = inputLocals;
    int numLocal = 0;
    int numTrailingTop = 0;
    int i = 0;
    while (i < localTypes.length) {
      int localType = localTypes[i];
      i += (localType == LONG || localType == DOUBLE) ? 2 : 1;
      if (localType == TOP) {
        numTrailingTop++;
      } else {
        numLocal += numTrailingTop + 1;
        numTrailingTop = 0;
      }
    }
    // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.
    int[] stackTypes = inputStack;
    int numStack = 0;
    i = 0;
    while (i < stackTypes.length) {
      int stackType = stackTypes[i];
      i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;
      numStack++;
    }
    // Visit the frame and its content.
    int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);
    i = 0;
    while (numLocal-- > 0) {
      int localType = localTypes[i];
      i += (localType == LONG || localType == DOUBLE) ? 2 : 1;
      methodWriter.visitAbstractType(frameIndex++, localType);
    }
    i = 0;
    while (numStack-- > 0) {
      int stackType = stackTypes[i];
      i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;
      methodWriter.visitAbstractType(frameIndex++, stackType);
    }
    methodWriter.visitFrameEnd();
  }

  /**
   * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info
   * format used in StackMapTable attributes.
   *
   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
   * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link
   *     Frame#REFERENCE_KIND}, {@link Frame#UNINITIALIZED_KIND} or {@link
   *     Frame#FORWARD_UNINITIALIZED_KIND} types.
   * @param output where the abstract type must be put.
   * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4">JVMS
   *     4.7.4</a>
   */
  static void putAbstractType(
      final SymbolTable symbolTable, final int abstractType, final ByteVector output) {
    int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT;
    if (arrayDimensions == 0) {
      int typeValue = abstractType & VALUE_MASK;
      switch (abstractType & KIND_MASK) {
        case CONSTANT_KIND:
          output.putByte(typeValue);
          break;
        case REFERENCE_KIND:
          output
              .putByte(ITEM_OBJECT)
              .putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index);
          break;
        case UNINITIALIZED_KIND:
          output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data);
          break;
        case FORWARD_UNINITIALIZED_KIND:
          output.putByte(ITEM_UNINITIALIZED);
          symbolTable.getForwardUninitializedLabel(typeValue).put(output);
          break;
        default:
          throw new AssertionError();
      }
    } else {
      // Case of an array type, we need to build its descriptor first.
      StringBuilder typeDescriptor = new StringBuilder();
      while (arrayDimensions-- > 0) {
        typeDescriptor.append('[');
      }
      if ((abstractType & KIND_MASK) == REFERENCE_KIND) {
        typeDescriptor
            .append('L')
            .append(symbolTable.getType(abstractType & VALUE_MASK).value)
            .append(';');
      } else {
        switch (abstractType & VALUE_MASK) {
          case Frame.ITEM_ASM_BOOLEAN:
            typeDescriptor.append('Z');
            break;
          case Frame.ITEM_ASM_BYTE:
            typeDescriptor.append('B');
            break;
          case Frame.ITEM_ASM_CHAR:
            typeDescriptor.append('C');
            break;
          case Frame.ITEM_ASM_SHORT:
            typeDescriptor.append('S');
            break;
          case Frame.ITEM_INTEGER:
            typeDescriptor.append('I');
            break;
          case Frame.ITEM_FLOAT:
            typeDescriptor.append('F');
            break;
          case Frame.ITEM_LONG:
            typeDescriptor.append('J');
            break;
          case Frame.ITEM_DOUBLE:
            typeDescriptor.append('D');
            break;
          default:
            throw new AssertionError();
        }
      }
      output
          .putByte(ITEM_OBJECT)
          .putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index);
    }
  }
}

package org.objectweb.asm;

/**
 * Information about an exception handler. Corresponds to an element of the exception_table array of
 * a Code attribute, as defined in the Java Virtual Machine Specification (JVMS). Handler instances
 * can be chained together, with their {@link #nextHandler} field, to describe a full JVMS
 * exception_table array.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3">JVMS
 *     4.7.3</a>
 * @author Eric Bruneton
 */
final class Handler {

  /**
   * The start_pc field of this JVMS exception_table entry. Corresponds to the beginning of the
   * exception handler's scope (inclusive).
   */
  final Label startPc;

  /**
   * The end_pc field of this JVMS exception_table entry. Corresponds to the end of the exception
   * handler's scope (exclusive).
   */
  final Label endPc;

  /**
   * The handler_pc field of this JVMS exception_table entry. Corresponding to the beginning of the
   * exception handler's code.
   */
  final Label handlerPc;

  /**
   * The catch_type field of this JVMS exception_table entry. This is the constant pool index of the
   * internal name of the type of exceptions handled by this handler, or 0 to catch any exceptions.
   */
  final int catchType;

  /**
   * The internal name of the type of exceptions handled by this handler, or {@literal null} to
   * catch any exceptions.
   */
  final @InternalForm String catchTypeDescriptor;

  /** The next exception handler. */
  Handler nextHandler;

  /**
   * Constructs a new Handler.
   *
   * @param startPc the start_pc field of this JVMS exception_table entry.
   * @param endPc the end_pc field of this JVMS exception_table entry.
   * @param handlerPc the handler_pc field of this JVMS exception_table entry.
   * @param catchType The catch_type field of this JVMS exception_table entry.
   * @param catchTypeDescriptor The internal name of the type of exceptions handled by this handler,
   *     or {@literal null} to catch any exceptions.
   */
  Handler(
      final Label startPc,
      final Label endPc,
      final Label handlerPc,
      final int catchType,
      final @InternalForm String catchTypeDescriptor) {
    this.startPc = startPc;
    this.endPc = endPc;
    this.handlerPc = handlerPc;
    this.catchType = catchType;
    this.catchTypeDescriptor = catchTypeDescriptor;
  }

  /**
   * Constructs a new Handler from the given one, with a different scope.
   *
   * @param handler an existing Handler.
   * @param startPc the start_pc field of this JVMS exception_table entry.
   * @param endPc the end_pc field of this JVMS exception_table entry.
   */
  Handler(final Handler handler, final Label startPc, final Label endPc) {
    this(startPc, endPc, handler.handlerPc, handler.catchType, handler.catchTypeDescriptor);
    this.nextHandler = handler.nextHandler;
  }

  /**
   * Removes the range between start and end from the Handler list that begins with the given
   * element.
   *
   * @param firstHandler the beginning of a Handler list. May be {@literal null}.
   * @param start the start of the range to be removed.
   * @param end the end of the range to be removed. Maybe {@literal null}.
   * @return the exception handler list with the start-end range removed.
   */
  static Handler removeRange(final Handler firstHandler, final Label start, final Label end) {
    if (firstHandler == null) {
      return null;
    } else {
      firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end);
    }
    int handlerStart = firstHandler.startPc.bytecodeOffset;
    int handlerEnd = firstHandler.endPc.bytecodeOffset;
    int rangeStart = start.bytecodeOffset;
    int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset;
    // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect.
    if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) {
      return firstHandler;
    }
    if (rangeStart <= handlerStart) {
      if (rangeEnd >= handlerEnd) {
        // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler.
        return firstHandler.nextHandler;
      } else {
        // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[
        return new Handler(firstHandler, end, firstHandler.endPc);
      }
    } else if (rangeEnd >= handlerEnd) {
      // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[
      return new Handler(firstHandler, firstHandler.startPc, start);
    } else {
      // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ =
      //     [handlerStart,rangeStart[ + [rangeEnd,handerEnd[
      firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc);
      return new Handler(firstHandler, firstHandler.startPc, start);
    }
  }

  /**
   * Returns the number of elements of the Handler list that begins with the given element.
   *
   * @param firstHandler the beginning of a Handler list. May be {@literal null}.
   * @return the number of elements of the Handler list that begins with 'handler'.
   */
  static int getExceptionTableLength(final Handler firstHandler) {
    int length = 0;
    Handler handler = firstHandler;
    while (handler != null) {
      length++;
      handler = handler.nextHandler;
    }
    return length;
  }

  /**
   * Returns the size in bytes of the JVMS exception_table corresponding to the Handler list that
   * begins with the given element. <i>This includes the exception_table_length field.</i>
   *
   * @param firstHandler the beginning of a Handler list. May be {@literal null}.
   * @return the size in bytes of the exception_table_length and exception_table structures.
   */
  static int getExceptionTableSize(final Handler firstHandler) {
    return 2 + 8 * getExceptionTableLength(firstHandler);
  }

  /**
   * Puts the JVMS exception_table corresponding to the Handler list that begins with the given
   * element. <i>This includes the exception_table_length field.</i>
   *
   * @param firstHandler the beginning of a Handler list. May be {@literal null}.
   * @param output where the exception_table_length and exception_table structures must be put.
   */
  static void putExceptionTable(final Handler firstHandler, final ByteVector output) {
    output.putShort(getExceptionTableLength(firstHandler));
    Handler handler = firstHandler;
    while (handler != null) {
      output
          .putShort(handler.startPc.bytecodeOffset)
          .putShort(handler.endPc.bytecodeOffset)
          .putShort(handler.handlerPc.bytecodeOffset)
          .putShort(handler.catchType);
      handler = handler.nextHandler;
    }
  }
}

package org.objectweb.asm;

/**
 * The JVM opcodes, access flags and array type codes. This interface does not define all the JVM
 * opcodes because some opcodes are automatically handled. For example, the xLOAD and xSTORE opcodes
 * are automatically replaced by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and
 * xSTORE_n opcodes are therefore not defined in this interface. Likewise for LDC, automatically
 * replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and JSR_W.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html">JVMS 6</a>
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
// DontCheck(InterfaceIsType): can't be fixed (for backward binary compatibility).
public interface Opcodes {

  // ASM API versions.

  int ASM4 = 4 << 16 | 0 << 8;
  int ASM5 = 5 << 16 | 0 << 8;
  int ASM6 = 6 << 16 | 0 << 8;
  int ASM7 = 7 << 16 | 0 << 8;
  int ASM8 = 8 << 16 | 0 << 8;
  int ASM9 = 9 << 16 | 0 << 8;

  /**
   * <i>Experimental, use at your own risk. This field will be renamed when it becomes stable, this
   * will break existing code using it. Only code compiled with --enable-preview can use this.</i>
   *
   * @deprecated This API is experimental.
   */
  @Deprecated int ASM10_EXPERIMENTAL = 1 << 24 | 10 << 16 | 0 << 8;

  /*
   * Internal flags used to redirect calls to deprecated methods. For instance, if a visitOldStuff
   * method in API_OLD is deprecated and replaced with visitNewStuff in API_NEW, then the
   * redirection should be done as follows:
   *
   * <pre>
   * public class StuffVisitor {
   *   ...
   *
   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {
   *     // SOURCE_DEPRECATED means "a call from a deprecated method using the old 'api' value".
   *     visitNewStuf(arg | (api &#60; API_NEW ? SOURCE_DEPRECATED : 0), ...);
   *   }
   *
   *   public void visitNewStuff(int argAndSource, ...) {
   *     if (api &#60; API_NEW &#38;&#38; (argAndSource &#38; SOURCE_DEPRECATED) == 0) {
   *       visitOldStuff(argAndSource, ...);
   *     } else {
   *       int arg = argAndSource &#38; ~SOURCE_MASK;
   *       [ do stuff ]
   *     }
   *   }
   * }
   * </pre>
   *
   * <p>If 'api' is equal to API_NEW, there are two cases:
   *
   * <ul>
   *   <li>call visitNewStuff: the redirection test is skipped and 'do stuff' is executed directly.
   *   <li>call visitOldSuff: the source is not set to SOURCE_DEPRECATED before calling
   *       visitNewStuff, but the redirection test is skipped anyway in visitNewStuff, which
   *       directly executes 'do stuff'.
   * </ul>
   *
   * <p>If 'api' is equal to API_OLD, there are two cases:
   *
   * <ul>
   *   <li>call visitOldSuff: the source is set to SOURCE_DEPRECATED before calling visitNewStuff.
   *       Because of this visitNewStuff does not redirect back to visitOldStuff, and instead
   *       executes 'do stuff'.
   *   <li>call visitNewStuff: the call is redirected to visitOldStuff because the source is 0.
   *       visitOldStuff now sets the source to SOURCE_DEPRECATED and calls visitNewStuff back. This
   *       time visitNewStuff does not redirect the call, and instead executes 'do stuff'.
   * </ul>
   *
   * <h1>User subclasses</h1>
   *
   * <p>If a user subclass overrides one of these methods, there are only two cases: either 'api' is
   * API_OLD and visitOldStuff is overridden (and visitNewStuff is not), or 'api' is API_NEW or
   * more, and visitNewStuff is overridden (and visitOldStuff is not). Any other case is a user
   * programming error.
   *
   * <p>If 'api' is equal to API_NEW, the class hierarchy is equivalent to
   *
   * <pre>
   * public class StuffVisitor {
   *   &#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }
   *   public void visitNewStuff(int arg, ...) { [ do stuff ] }
   * }
   * class UserStuffVisitor extends StuffVisitor {
   *   &#64;Override public void visitNewStuff(int arg, ...) {
   *     super.visitNewStuff(int arg, ...); // optional
   *     [ do user stuff ]
   *   }
   * }
   * </pre>
   *
   * <p>It is then obvious that whether visitNewStuff or visitOldStuff is called, 'do stuff' and 'do
   * user stuff' will be executed, in this order.
   *
   * <p>If 'api' is equal to API_OLD, the class hierarchy is equivalent to
   *
   * <pre>
   * public class StuffVisitor {
   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {
   *     visitNewStuff(arg | SOURCE_DEPRECATED, ...);
   *   }
   *   public void visitNewStuff(int argAndSource...) {
   *     if ((argAndSource & SOURCE_DEPRECATED) == 0) {
   *       visitOldStuff(argAndSource, ...);
   *     } else {
   *       int arg = argAndSource &#38; ~SOURCE_MASK;
   *       [ do stuff ]
   *     }
   *   }
   * }
   * class UserStuffVisitor extends StuffVisitor {
   *   &#64;Override public void visitOldStuff(int arg, ...) {
   *     super.visitOldStuff(int arg, ...); // optional
   *     [ do user stuff ]
   *   }
   * }
   * </pre>
   *
   * <p>and there are two cases:
   *
   * <ul>
   *   <li>call visitOldStuff: in the call to super.visitOldStuff, the source is set to
   *       SOURCE_DEPRECATED and visitNewStuff is called. Here 'do stuff' is run because the source
   *       was previously set to SOURCE_DEPRECATED, and execution eventually returns to
   *       UserStuffVisitor.visitOldStuff, where 'do user stuff' is run.
   *   <li>call visitNewStuff: the call is redirected to UserStuffVisitor.visitOldStuff because the
   *       source is 0. Execution continues as in the previous case, resulting in 'do stuff' and 'do
   *       user stuff' being executed, in this order.
   * </ul>
   *
   * <h1>ASM subclasses</h1>
   *
   * <p>In ASM packages, subclasses of StuffVisitor can typically be sub classed again by the user,
   * and can be used with API_OLD or API_NEW. Because of this, if such a subclass must override
   * visitNewStuff, it must do so in the following way (and must not override visitOldStuff):
   *
   * <pre>
   * public class AsmStuffVisitor extends StuffVisitor {
   *   &#64;Override public void visitNewStuff(int argAndSource, ...) {
   *     if (api &#60; API_NEW &#38;&#38; (argAndSource &#38; SOURCE_DEPRECATED) == 0) {
   *       super.visitNewStuff(argAndSource, ...);
   *       return;
   *     }
   *     super.visitNewStuff(argAndSource, ...); // optional
   *     int arg = argAndSource &#38; ~SOURCE_MASK;
   *     [ do other stuff ]
   *   }
   * }
   * </pre>
   *
   * <p>If a user class extends this with 'api' equal to API_NEW, the class hierarchy is equivalent
   * to
   *
   * <pre>
   * public class StuffVisitor {
   *   &#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }
   *   public void visitNewStuff(int arg, ...) { [ do stuff ] }
   * }
   * public class AsmStuffVisitor extends StuffVisitor {
   *   &#64;Override public void visitNewStuff(int arg, ...) {
   *     super.visitNewStuff(arg, ...);
   *     [ do other stuff ]
   *   }
   * }
   * class UserStuffVisitor extends StuffVisitor {
   *   &#64;Override public void visitNewStuff(int arg, ...) {
   *     super.visitNewStuff(int arg, ...);
   *     [ do user stuff ]
   *   }
   * }
   * </pre>
   *
   * <p>It is then obvious that whether visitNewStuff or visitOldStuff is called, 'do stuff', 'do
   * other stuff' and 'do user stuff' will be executed, in this order. If, on the other hand, a user
   * class extends AsmStuffVisitor with 'api' equal to API_OLD, the class hierarchy is equivalent to
   *
   * <pre>
   * public class StuffVisitor {
   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {
   *     visitNewStuf(arg | SOURCE_DEPRECATED, ...);
   *   }
   *   public void visitNewStuff(int argAndSource, ...) {
   *     if ((argAndSource & SOURCE_DEPRECATED) == 0) {
   *       visitOldStuff(argAndSource, ...);
   *     } else {
   *       int arg = argAndSource &#38; ~SOURCE_MASK;
   *       [ do stuff ]
   *     }
   *   }
   * }
   * public class AsmStuffVisitor extends StuffVisitor {
   *   &#64;Override public void visitNewStuff(int argAndSource, ...) {
   *     if ((argAndSource &#38; SOURCE_DEPRECATED) == 0) {
   *       super.visitNewStuff(argAndSource, ...);
   *       return;
   *     }
   *     super.visitNewStuff(argAndSource, ...); // optional
   *     int arg = argAndSource &#38; ~SOURCE_MASK;
   *     [ do other stuff ]
   *   }
   * }
   * class UserStuffVisitor extends StuffVisitor {
   *   &#64;Override public void visitOldStuff(int arg, ...) {
   *     super.visitOldStuff(arg, ...);
   *     [ do user stuff ]
   *   }
   * }
   * </pre>
   *
   * <p>and, here again, whether visitNewStuff or visitOldStuff is called, 'do stuff', 'do other
   * stuff' and 'do user stuff' will be executed, in this order (exercise left to the reader).
   *
   * <h1>Notes</h1>
   *
   * <ul>
   *   <li>the SOURCE_DEPRECATED flag is set only if 'api' is API_OLD, just before calling
   *       visitNewStuff. By hypothesis, this method is not overridden by the user. Therefore, user
   *       classes can never see this flag. Only ASM subclasses must take care of extracting the
   *       actual argument value by clearing the source flags.
   *   <li>because the SOURCE_DEPRECATED flag is immediately cleared in the caller, the caller can
   *       call visitOldStuff or visitNewStuff (in 'do stuff' and 'do user stuff') on a delegate
   *       visitor without any risks (breaking the redirection logic, "leaking" the flag, etc).
   *   <li>all the scenarios discussed above are unit tested in MethodVisitorTest.
   * </ul>
   */

  int SOURCE_DEPRECATED = 0x100;
  int SOURCE_MASK = SOURCE_DEPRECATED;

  // Java ClassFile versions (the minor version is stored in the 16 most significant bits, and the
  // major version in the 16 least significant bits).

  int V1_1 = 3 << 16 | 45;
  int V1_2 = 0 << 16 | 46;
  int V1_3 = 0 << 16 | 47;
  int V1_4 = 0 << 16 | 48;
  int V1_5 = 0 << 16 | 49;
  int V1_6 = 0 << 16 | 50;
  int V1_7 = 0 << 16 | 51;
  int V1_8 = 0 << 16 | 52;
  int V9 = 0 << 16 | 53;
  int V10 = 0 << 16 | 54;
  int V11 = 0 << 16 | 55;
  int V12 = 0 << 16 | 56;
  int V13 = 0 << 16 | 57;
  int V14 = 0 << 16 | 58;
  int V15 = 0 << 16 | 59;
  int V16 = 0 << 16 | 60;
  int V17 = 0 << 16 | 61;
  int V18 = 0 << 16 | 62;
  int V19 = 0 << 16 | 63;
  int V20 = 0 << 16 | 64;
  int V21 = 0 << 16 | 65;
  int V22 = 0 << 16 | 66;
  int V23 = 0 << 16 | 67;
  int V24 = 0 << 16 | 68;

  /**
   * Version flag indicating that the class is using 'preview' features.
   *
   * <p>{@code version & V_PREVIEW == V_PREVIEW} tests if a version is flagged with {@code
   * V_PREVIEW}.
   */
  int V_PREVIEW = 0xFFFF0000;

  // Access flags values, defined in
  // - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.1-200-E.1
  // - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.5-200-A.1
  // - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6-200-A.1
  // - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25

  int ACC_PUBLIC = 0x0001; // class, field, method
  int ACC_PRIVATE = 0x0002; // class, field, method
  int ACC_PROTECTED = 0x0004; // class, field, method
  int ACC_STATIC = 0x0008; // field, method
  int ACC_FINAL = 0x0010; // class, field, method, parameter
  int ACC_SUPER = 0x0020; // class
  int ACC_SYNCHRONIZED = 0x0020; // method
  int ACC_OPEN = 0x0020; // module
  int ACC_TRANSITIVE = 0x0020; // module requires
  int ACC_VOLATILE = 0x0040; // field
  int ACC_BRIDGE = 0x0040; // method
  int ACC_STATIC_PHASE = 0x0040; // module requires
  int ACC_VARARGS = 0x0080; // method
  int ACC_TRANSIENT = 0x0080; // field
  int ACC_NATIVE = 0x0100; // method
  int ACC_INTERFACE = 0x0200; // class
  int ACC_ABSTRACT = 0x0400; // class, method
  int ACC_STRICT = 0x0800; // method
  int ACC_SYNTHETIC = 0x1000; // class, field, method, parameter, module *
  int ACC_ANNOTATION = 0x2000; // class
  int ACC_ENUM = 0x4000; // class(?) field inner
  int ACC_MANDATED = 0x8000; // field, method, parameter, module, module *
  int ACC_MODULE = 0x8000; // class

  // ASM specific access flags.
  // WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard
  // access flags, and also to make sure that these flags are automatically filtered out when
  // written in class files (because access flags are stored using 16 bits only).

  int ACC_RECORD = 0x10000; // class
  int ACC_DEPRECATED = 0x20000; // class, field, method

  // Possible values for the type operand of the NEWARRAY instruction.
  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html#jvms-6.5.newarray.

  int T_BOOLEAN = 4;
  int T_CHAR = 5;
  int T_FLOAT = 6;
  int T_DOUBLE = 7;
  int T_BYTE = 8;
  int T_SHORT = 9;
  int T_INT = 10;
  int T_LONG = 11;

  // Possible values for the reference_kind field of CONSTANT_MethodHandle_info structures.
  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4.8.

  int H_GETFIELD = 1;
  int H_GETSTATIC = 2;
  int H_PUTFIELD = 3;
  int H_PUTSTATIC = 4;
  int H_INVOKEVIRTUAL = 5;
  int H_INVOKESTATIC = 6;
  int H_INVOKESPECIAL = 7;
  int H_NEWINVOKESPECIAL = 8;
  int H_INVOKEINTERFACE = 9;

  // ASM specific stack map frame types, used in {@link ClassVisitor#visitFrame}.

  /** An expanded frame. See {@link ClassReader#EXPAND_FRAMES}. */
  int F_NEW = -1;

  /** A compressed frame with complete frame data. */
  int F_FULL = 0;

  /**
   * A compressed frame where locals are the same as the locals in the previous frame, except that
   * additional 1-3 locals are defined, and with an empty stack.
   */
  int F_APPEND = 1;

  /**
   * A compressed frame where locals are the same as the locals in the previous frame, except that
   * the last 1-3 locals are absent and with an empty stack.
   */
  int F_CHOP = 2;

  /**
   * A compressed frame with exactly the same locals as the previous frame and with an empty stack.
   */
  int F_SAME = 3;

  /**
   * A compressed frame with exactly the same locals as the previous frame and with a single value
   * on the stack.
   */
  int F_SAME1 = 4;

  // Standard stack map frame element types, used in {@link ClassVisitor#visitFrame}.

  Integer TOP = Frame.ITEM_TOP;
  Integer INTEGER = Frame.ITEM_INTEGER;
  Integer FLOAT = Frame.ITEM_FLOAT;
  Integer DOUBLE = Frame.ITEM_DOUBLE;
  Integer LONG = Frame.ITEM_LONG;
  Integer NULL = Frame.ITEM_NULL;
  Integer UNINITIALIZED_THIS = Frame.ITEM_UNINITIALIZED_THIS;

  // The JVM opcode values (with the MethodVisitor method name used to visit them in comment, and
  // where '-' means 'same method name as on the previous line').
  // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html.

  int NOP = 0; // visitInsn
  int ACONST_NULL = 1; // -
  int ICONST_M1 = 2; // -
  int ICONST_0 = 3; // -
  int ICONST_1 = 4; // -
  int ICONST_2 = 5; // -
  int ICONST_3 = 6; // -
  int ICONST_4 = 7; // -
  int ICONST_5 = 8; // -
  int LCONST_0 = 9; // -
  int LCONST_1 = 10; // -
  int FCONST_0 = 11; // -
  int FCONST_1 = 12; // -
  int FCONST_2 = 13; // -
  int DCONST_0 = 14; // -
  int DCONST_1 = 15; // -
  int BIPUSH = 16; // visitIntInsn
  int SIPUSH = 17; // -
  int LDC = 18; // visitLdcInsn
  int ILOAD = 21; // visitVarInsn
  int LLOAD = 22; // -
  int FLOAD = 23; // -
  int DLOAD = 24; // -
  int ALOAD = 25; // -
  int IALOAD = 46; // visitInsn
  int LALOAD = 47; // -
  int FALOAD = 48; // -
  int DALOAD = 49; // -
  int AALOAD = 50; // -
  int BALOAD = 51; // -
  int CALOAD = 52; // -
  int SALOAD = 53; // -
  int ISTORE = 54; // visitVarInsn
  int LSTORE = 55; // -
  int FSTORE = 56; // -
  int DSTORE = 57; // -
  int ASTORE = 58; // -
  int IASTORE = 79; // visitInsn
  int LASTORE = 80; // -
  int FASTORE = 81; // -
  int DASTORE = 82; // -
  int AASTORE = 83; // -
  int BASTORE = 84; // -
  int CASTORE = 85; // -
  int SASTORE = 86; // -
  int POP = 87; // -
  int POP2 = 88; // -
  int DUP = 89; // -
  int DUP_X1 = 90; // -
  int DUP_X2 = 91; // -
  int DUP2 = 92; // -
  int DUP2_X1 = 93; // -
  int DUP2_X2 = 94; // -
  int SWAP = 95; // -
  int IADD = 96; // -
  int LADD = 97; // -
  int FADD = 98; // -
  int DADD = 99; // -
  int ISUB = 100; // -
  int LSUB = 101; // -
  int FSUB = 102; // -
  int DSUB = 103; // -
  int IMUL = 104; // -
  int LMUL = 105; // -
  int FMUL = 106; // -
  int DMUL = 107; // -
  int IDIV = 108; // -
  int LDIV = 109; // -
  int FDIV = 110; // -
  int DDIV = 111; // -
  int IREM = 112; // -
  int LREM = 113; // -
  int FREM = 114; // -
  int DREM = 115; // -
  int INEG = 116; // -
  int LNEG = 117; // -
  int FNEG = 118; // -
  int DNEG = 119; // -
  int ISHL = 120; // -
  int LSHL = 121; // -
  int ISHR = 122; // -
  int LSHR = 123; // -
  int IUSHR = 124; // -
  int LUSHR = 125; // -
  int IAND = 126; // -
  int LAND = 127; // -
  int IOR = 128; // -
  int LOR = 129; // -
  int IXOR = 130; // -
  int LXOR = 131; // -
  int IINC = 132; // visitIincInsn
  int I2L = 133; // visitInsn
  int I2F = 134; // -
  int I2D = 135; // -
  int L2I = 136; // -
  int L2F = 137; // -
  int L2D = 138; // -
  int F2I = 139; // -
  int F2L = 140; // -
  int F2D = 141; // -
  int D2I = 142; // -
  int D2L = 143; // -
  int D2F = 144; // -
  int I2B = 145; // -
  int I2C = 146; // -
  int I2S = 147; // -
  int LCMP = 148; // -
  int FCMPL = 149; // -
  int FCMPG = 150; // -
  int DCMPL = 151; // -
  int DCMPG = 152; // -
  int IFEQ = 153; // visitJumpInsn
  int IFNE = 154; // -
  int IFLT = 155; // -
  int IFGE = 156; // -
  int IFGT = 157; // -
  int IFLE = 158; // -
  int IF_ICMPEQ = 159; // -
  int IF_ICMPNE = 160; // -
  int IF_ICMPLT = 161; // -
  int IF_ICMPGE = 162; // -
  int IF_ICMPGT = 163; // -
  int IF_ICMPLE = 164; // -
  int IF_ACMPEQ = 165; // -
  int IF_ACMPNE = 166; // -
  int GOTO = 167; // -
  int JSR = 168; // -
  int RET = 169; // visitVarInsn
  int TABLESWITCH = 170; // visiTableSwitchInsn
  int LOOKUPSWITCH = 171; // visitLookupSwitch
  int IRETURN = 172; // visitInsn
  int LRETURN = 173; // -
  int FRETURN = 174; // -
  int DRETURN = 175; // -
  int ARETURN = 176; // -
  int RETURN = 177; // -
  int GETSTATIC = 178; // visitFieldInsn
  int PUTSTATIC = 179; // -
  int GETFIELD = 180; // -
  int PUTFIELD = 181; // -
  int INVOKEVIRTUAL = 182; // visitMethodInsn
  int INVOKESPECIAL = 183; // -
  int INVOKESTATIC = 184; // -
  int INVOKEINTERFACE = 185; // -
  int INVOKEDYNAMIC = 186; // visitInvokeDynamicInsn
  int NEW = 187; // visitTypeInsn
  int NEWARRAY = 188; // visitIntInsn
  int ANEWARRAY = 189; // visitTypeInsn
  int ARRAYLENGTH = 190; // visitInsn
  int ATHROW = 191; // -
  int CHECKCAST = 192; // visitTypeInsn
  int INSTANCEOF = 193; // -
  int MONITORENTER = 194; // visitInsn
  int MONITOREXIT = 195; // -
  int MULTIANEWARRAY = 197; // visitMultiANewArrayInsn
  int IFNULL = 198; // visitJumpInsn
  int IFNONNULL = 199; // -
}

package org.objectweb.asm;

/**
 * An entry of the constant pool, of the BootstrapMethods attribute, or of the (ASM specific) type
 * table of a class.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4">JVMS
 *     4.4</a>
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23">JVMS
 *     4.7.23</a>
 * @author Eric Bruneton
 */
abstract class Symbol {

  // Tag values for the constant pool entries (using the same order as in the JVMS).

  /** The tag value of CONSTANT_Class_info JVMS structures. */
  static final int CONSTANT_CLASS_TAG = 7;

  /** The tag value of CONSTANT_Fieldref_info JVMS structures. */
  static final int CONSTANT_FIELDREF_TAG = 9;

  /** The tag value of CONSTANT_Methodref_info JVMS structures. */
  static final int CONSTANT_METHODREF_TAG = 10;

  /** The tag value of CONSTANT_InterfaceMethodref_info JVMS structures. */
  static final int CONSTANT_INTERFACE_METHODREF_TAG = 11;

  /** The tag value of CONSTANT_String_info JVMS structures. */
  static final int CONSTANT_STRING_TAG = 8;

  /** The tag value of CONSTANT_Integer_info JVMS structures. */
  static final int CONSTANT_INTEGER_TAG = 3;

  /** The tag value of CONSTANT_Float_info JVMS structures. */
  static final int CONSTANT_FLOAT_TAG = 4;

  /** The tag value of CONSTANT_Long_info JVMS structures. */
  static final int CONSTANT_LONG_TAG = 5;

  /** The tag value of CONSTANT_Double_info JVMS structures. */
  static final int CONSTANT_DOUBLE_TAG = 6;

  /** The tag value of CONSTANT_NameAndType_info JVMS structures. */
  static final int CONSTANT_NAME_AND_TYPE_TAG = 12;

  /** The tag value of CONSTANT_Utf8_info JVMS structures. */
  static final int CONSTANT_UTF8_TAG = 1;

  /** The tag value of CONSTANT_MethodHandle_info JVMS structures. */
  static final int CONSTANT_METHOD_HANDLE_TAG = 15;

  /** The tag value of CONSTANT_MethodType_info JVMS structures. */
  static final int CONSTANT_METHOD_TYPE_TAG = 16;

  /** The tag value of CONSTANT_Dynamic_info JVMS structures. */
  static final int CONSTANT_DYNAMIC_TAG = 17;

  /** The tag value of CONSTANT_InvokeDynamic_info JVMS structures. */
  static final int CONSTANT_INVOKE_DYNAMIC_TAG = 18;

  /** The tag value of CONSTANT_Module_info JVMS structures. */
  static final int CONSTANT_MODULE_TAG = 19;

  /** The tag value of CONSTANT_Package_info JVMS structures. */
  static final int CONSTANT_PACKAGE_TAG = 20;

  // Tag values for the BootstrapMethods attribute entries (ASM specific tag).

  /** The tag value of the BootstrapMethods attribute entries. */
  static final int BOOTSTRAP_METHOD_TAG = 64;

  // Tag values for the type table entries (ASM specific tags).

  /** The tag value of a normal type entry in the (ASM specific) type table of a class. */
  static final int TYPE_TAG = 128;

  /**
   * The tag value of an uninitialized type entry in the type table of a class. This type is used
   * for the normal case where the NEW instruction is before the &lt;init&gt; constructor call (in
   * bytecode offset order), i.e. when the label of the NEW instruction is resolved when the
   * constructor call is visited. If the NEW instruction is after the constructor call, use the
   * {@link #FORWARD_UNINITIALIZED_TYPE_TAG} tag value instead.
   */
  static final int UNINITIALIZED_TYPE_TAG = 129;

  /**
   * The tag value of an uninitialized type entry in the type table of a class. This type is used
   * for the unusual case where the NEW instruction is after the &lt;init&gt; constructor call (in
   * bytecode offset order), i.e. when the label of the NEW instruction is not resolved when the
   * constructor call is visited. If the NEW instruction is before the constructor call, use the
   * {@link #UNINITIALIZED_TYPE_TAG} tag value instead.
   */
  static final int FORWARD_UNINITIALIZED_TYPE_TAG = 130;

  /** The tag value of a merged type entry in the (ASM specific) type table of a class. */
  static final int MERGED_TYPE_TAG = 131;

  // Instance fields.

  /**
   * The index of this symbol in the constant pool, in the BootstrapMethods attribute, or in the
   * (ASM specific) type table of a class (depending on the {@link #tag} value).
   */
  final int index;

  /**
   * A tag indicating the type of this symbol. Must be one of the static tag values defined in this
   * class.
   */
  final int tag;

  /**
   * The internal name of the owner class of this symbol. Only used for {@link
   * #CONSTANT_FIELDREF_TAG}, {@link #CONSTANT_METHODREF_TAG}, {@link
   * #CONSTANT_INTERFACE_METHODREF_TAG}, and {@link #CONSTANT_METHOD_HANDLE_TAG} symbols.
   */
  final @InternalForm String owner;

  /**
   * The name of the class field or method corresponding to this symbol. Only used for {@link
   * #CONSTANT_FIELDREF_TAG}, {@link #CONSTANT_METHODREF_TAG}, {@link
   * #CONSTANT_INTERFACE_METHODREF_TAG}, {@link #CONSTANT_NAME_AND_TYPE_TAG}, {@link
   * #CONSTANT_METHOD_HANDLE_TAG}, {@link #CONSTANT_DYNAMIC_TAG} and {@link
   * #CONSTANT_INVOKE_DYNAMIC_TAG} symbols.
   */
  final String name;

  /**
   * The string value of this symbol. This is:
   *
   * <ul>
   *   <li>a field or method descriptor for {@link #CONSTANT_FIELDREF_TAG}, {@link
   *       #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG}, {@link
   *       #CONSTANT_NAME_AND_TYPE_TAG}, {@link #CONSTANT_METHOD_HANDLE_TAG}, {@link
   *       #CONSTANT_METHOD_TYPE_TAG}, {@link #CONSTANT_DYNAMIC_TAG} and {@link
   *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,
   *   <li>an arbitrary string for {@link #CONSTANT_UTF8_TAG} and {@link #CONSTANT_STRING_TAG}
   *       symbols,
   *   <li>an internal class name for {@link #CONSTANT_CLASS_TAG}, {@link #TYPE_TAG}, {@link
   *       #UNINITIALIZED_TYPE_TAG} and {@link #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,
   *   <li>{@literal null} for the other types of symbol.
   * </ul>
   */
  final String value;

  /**
   * The numeric value of this symbol. This is:
   *
   * <ul>
   *   <li>the symbol's value for {@link #CONSTANT_INTEGER_TAG},{@link #CONSTANT_FLOAT_TAG}, {@link
   *       #CONSTANT_LONG_TAG}, {@link #CONSTANT_DOUBLE_TAG},
   *   <li>the CONSTANT_MethodHandle_info reference_kind field value for {@link
   *       #CONSTANT_METHOD_HANDLE_TAG} symbols (or this value left shifted by 8 bits for
   *       reference_kind values larger than or equal to H_INVOKEVIRTUAL and if the method owner is
   *       an interface),
   *   <li>the CONSTANT_InvokeDynamic_info bootstrap_method_attr_index field value for {@link
   *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,
   *   <li>the offset of a bootstrap method in the BootstrapMethods boostrap_methods array, for
   *       {@link #CONSTANT_DYNAMIC_TAG} or {@link #BOOTSTRAP_METHOD_TAG} symbols,
   *   <li>the bytecode offset of the NEW instruction that created an {@link
   *       Frame#ITEM_UNINITIALIZED} type for {@link #UNINITIALIZED_TYPE_TAG} symbols,
   *   <li>the index of the {@link Label} (in the {@link SymbolTable#labelTable} table) of the NEW
   *       instruction that created an {@link Frame#ITEM_UNINITIALIZED} type for {@link
   *       #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,
   *   <li>the indices (in the class' type table) of two {@link #TYPE_TAG} source types for {@link
   *       #MERGED_TYPE_TAG} symbols,
   *   <li>0 for the other types of symbol.
   * </ul>
   */
  final long data;

  /**
   * Additional information about this symbol, generally computed lazily. <i>Warning: the value of
   * this field is ignored when comparing Symbol instances</i> (to avoid duplicate entries in a
   * SymbolTable). Therefore, this field should only contain data that can be computed from the
   * other fields of this class. It contains:
   *
   * <ul>
   *   <li>the {@link Type#getArgumentsAndReturnSizes} of the symbol's method descriptor for {@link
   *       #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG} and {@link
   *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,
   *   <li>the index in the InnerClasses_attribute 'classes' array (plus one) corresponding to this
   *       class, for {@link #CONSTANT_CLASS_TAG} symbols,
   *   <li>the index (in the class' type table) of the merged type of the two source types for
   *       {@link #MERGED_TYPE_TAG} symbols,
   *   <li>0 for the other types of symbol, or if this field has not been computed yet.
   * </ul>
   */
  int info;

  /**
   * Constructs a new Symbol. This constructor can't be used directly because the Symbol class is
   * abstract. Instead, use the factory methods of the {@link SymbolTable} class.
   *
   * @param index the symbol index in the constant pool, in the BootstrapMethods attribute, or in
   *     the (ASM specific) type table of a class (depending on 'tag').
   * @param tag the symbol type. Must be one of the static tag values defined in this class.
   * @param owner The internal name of the symbol's owner class. Maybe {@literal null}.
   * @param name The name of the symbol's corresponding class field or method. Maybe {@literal
   *     null}.
   * @param value The string value of this symbol. Maybe {@literal null}.
   * @param data The numeric value of this symbol.
   */
  Symbol(
      final int index,
      final int tag,
      final @Nullable @InternalForm String owner,
      final String name,
      final String value,
      final long data) {
    this.index = index;
    this.tag = tag;
    this.owner = owner;
    this.name = name;
    this.value = value;
    this.data = data;
  }

  /**
   * Returns the result {@link Type#getArgumentsAndReturnSizes} on {@link #value}.
   *
   * @return the result {@link Type#getArgumentsAndReturnSizes} on {@link #value} (memoized in
   *     {@link #info} for efficiency). This should only be used for {@link
   *     #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG} and {@link
   *     #CONSTANT_INVOKE_DYNAMIC_TAG} symbols.
   */
  int getArgumentsAndReturnSizes() {
    if (info == 0) {
      info = Type.getArgumentsAndReturnSizes(value);
    }
    return info;
  }
}


package org.objectweb.asm;

/**
 * Information about the input stack map frame at the "current" instruction of a method. This is
 * implemented as a Frame subclass for a "basic block" containing only one instruction.
 *
 * @author Eric Bruneton
 */
final class CurrentFrame extends Frame {

  CurrentFrame(final Label owner) {
    super(owner);
  }

  /**
   * Sets this CurrentFrame to the input stack map frame of the next "current" instruction, i.e. the
   * instruction just after the given one. It is assumed that the value of this object when this
   * method is called is the stack map frame status just before the given instruction is executed.
   */
  @Override
  void execute(
      final int opcode, final int arg, final Symbol symbolArg, final SymbolTable symbolTable) {
    super.execute(opcode, arg, symbolArg, symbolTable);
    Frame successor = new Frame(null);
    merge(symbolTable, successor, 0);
    copyFrom(successor);
  }
}

package org.objectweb.asm;

/**
 * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream
 * on top of a ByteArrayOutputStream, but is more efficient.
 *
 * @author Eric Bruneton
 */
public class ByteVector {

  /** The content of this vector. Only the first {@link #length} bytes contain real data. */
  byte[] data;

  /** The actual number of bytes in this vector. */
  int length;

  /** Constructs a new {@link ByteVector} with a default initial capacity. */
  public ByteVector() {
    data = new byte[64];
  }

  /**
   * Constructs a new {@link ByteVector} with the given initial capacity.
   *
   * @param initialCapacity the initial capacity of the byte vector to be constructed.
   */
  public ByteVector(final int initialCapacity) {
    data = new byte[initialCapacity];
  }

  /**
   * Constructs a new {@link ByteVector} from the given initial data.
   *
   * @param data the initial data of the new byte vector.
   */
  ByteVector(final byte[] data) {
    this.data = data;
    this.length = data.length;
  }

  /**
   * Returns the actual number of bytes in this vector.
   *
   * @return the actual number of bytes in this vector.
   */
  public int size() {
    return length;
  }

  /**
   * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.
   *
   * @param byteValue a byte.
   * @return this byte vector.
   */
  public ByteVector putByte(final int byteValue) {
    int currentLength = length;
    if (currentLength + 1 > data.length) {
      enlarge(1);
    }
    data[currentLength++] = (byte) byteValue;
    length = currentLength;
    return this;
  }

  /**
   * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.
   *
   * @param byteValue1 a byte.
   * @param byteValue2 another byte.
   * @return this byte vector.
   */
  final ByteVector put11(final int byteValue1, final int byteValue2) {
    int currentLength = length;
    if (currentLength + 2 > data.length) {
      enlarge(2);
    }
    byte[] currentData = data;
    currentData[currentLength++] = (byte) byteValue1;
    currentData[currentLength++] = (byte) byteValue2;
    length = currentLength;
    return this;
  }

  /**
   * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.
   *
   * @param shortValue a short.
   * @return this byte vector.
   */
  public ByteVector putShort(final int shortValue) {
    int currentLength = length;
    if (currentLength + 2 > data.length) {
      enlarge(2);
    }
    byte[] currentData = data;
    currentData[currentLength++] = (byte) (shortValue >>> 8);
    currentData[currentLength++] = (byte) shortValue;
    length = currentLength;
    return this;
  }

  /**
   * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if
   * necessary.
   *
   * @param byteValue a byte.
   * @param shortValue a short.
   * @return this byte vector.
   */
  final ByteVector put12(final int byteValue, final int shortValue) {
    int currentLength = length;
    if (currentLength + 3 > data.length) {
      enlarge(3);
    }
    byte[] currentData = data;
    currentData[currentLength++] = (byte) byteValue;
    currentData[currentLength++] = (byte) (shortValue >>> 8);
    currentData[currentLength++] = (byte) shortValue;
    length = currentLength;
    return this;
  }

  /**
   * Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if
   * necessary.
   *
   * @param byteValue1 a byte.
   * @param byteValue2 another byte.
   * @param shortValue a short.
   * @return this byte vector.
   */
  final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) {
    int currentLength = length;
    if (currentLength + 4 > data.length) {
      enlarge(4);
    }
    byte[] currentData = data;
    currentData[currentLength++] = (byte) byteValue1;
    currentData[currentLength++] = (byte) byteValue2;
    currentData[currentLength++] = (byte) (shortValue >>> 8);
    currentData[currentLength++] = (byte) shortValue;
    length = currentLength;
    return this;
  }

  /**
   * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.
   *
   * @param intValue an int.
   * @return this byte vector.
   */
  public ByteVector putInt(final int intValue) {
    int currentLength = length;
    if (currentLength + 4 > data.length) {
      enlarge(4);
    }
    byte[] currentData = data;
    currentData[currentLength++] = (byte) (intValue >>> 24);
    currentData[currentLength++] = (byte) (intValue >>> 16);
    currentData[currentLength++] = (byte) (intValue >>> 8);
    currentData[currentLength++] = (byte) intValue;
    length = currentLength;
    return this;
  }

  /**
   * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged
   * if necessary.
   *
   * @param byteValue a byte.
   * @param shortValue1 a short.
   * @param shortValue2 another short.
   * @return this byte vector.
   */
  final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {
    int currentLength = length;
    if (currentLength + 5 > data.length) {
      enlarge(5);
    }
    byte[] currentData = data;
    currentData[currentLength++] = (byte) byteValue;
    currentData[currentLength++] = (byte) (shortValue1 >>> 8);
    currentData[currentLength++] = (byte) shortValue1;
    currentData[currentLength++] = (byte) (shortValue2 >>> 8);
    currentData[currentLength++] = (byte) shortValue2;
    length = currentLength;
    return this;
  }

  /**
   * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.
   *
   * @param longValue a long.
   * @return this byte vector.
   */
  public ByteVector putLong(final long longValue) {
    int currentLength = length;
    if (currentLength + 8 > data.length) {
      enlarge(8);
    }
    byte[] currentData = data;
    int intValue = (int) (longValue >>> 32);
    currentData[currentLength++] = (byte) (intValue >>> 24);
    currentData[currentLength++] = (byte) (intValue >>> 16);
    currentData[currentLength++] = (byte) (intValue >>> 8);
    currentData[currentLength++] = (byte) intValue;
    intValue = (int) longValue;
    currentData[currentLength++] = (byte) (intValue >>> 24);
    currentData[currentLength++] = (byte) (intValue >>> 16);
    currentData[currentLength++] = (byte) (intValue >>> 8);
    currentData[currentLength++] = (byte) intValue;
    length = currentLength;
    return this;
  }

  /**
   * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if
   * necessary.
   *
   * @param stringValue a String whose UTF8 encoded length must be less than 65536.
   * @return this byte vector.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  public ByteVector putUTF8(final String stringValue) {
    int charLength = stringValue.length();
    if (charLength > 65535) {
      throw new IllegalArgumentException("UTF8 string too large");
    }
    int currentLength = length;
    if (currentLength + 2 + charLength > data.length) {
      enlarge(2 + charLength);
    }
    byte[] currentData = data;
    // Optimistic algorithm: instead of computing the byte length and then serializing the string
    // (which requires two loops), we assume the byte length is equal to char length (which is the
    // most frequent case), and we start serializing the string right away. During the
    // serialization, if we find that this assumption is wrong, we continue with the general method.
    currentData[currentLength++] = (byte) (charLength >>> 8);
    currentData[currentLength++] = (byte) charLength;
    for (int i = 0; i < charLength; ++i) {
      char charValue = stringValue.charAt(i);
      if (charValue >= '\u0001' && charValue <= '\u007F') {
        currentData[currentLength++] = (byte) charValue;
      } else {
        length = currentLength;
        return encodeUtf8(stringValue, i, 65535);
      }
    }
    length = currentLength;
    return this;
  }

  /**
   * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if
   * necessary. The string length is encoded in two bytes before the encoded characters, if there is
   * space for that (i.e. if this.length - offset - 2 &gt;= 0).
   *
   * @param stringValue the String to encode.
   * @param offset the index of the first character to encode. The previous characters are supposed
   *     to have already been encoded, using only one byte per character.
   * @param maxByteLength the maximum byte length of the encoded string, including the already
   *     encoded characters.
   * @return this byte vector.
   */
  final ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {
    int charLength = stringValue.length();
    int byteLength = offset;
    for (int i = offset; i < charLength; ++i) {
      char charValue = stringValue.charAt(i);
      if (charValue >= 0x0001 && charValue <= 0x007F) {
        byteLength++;
      } else if (charValue <= 0x07FF) {
        byteLength += 2;
      } else {
        byteLength += 3;
      }
    }
    if (byteLength > maxByteLength) {
      throw new IllegalArgumentException("UTF8 string too large");
    }
    // Compute where 'byteLength' must be stored in 'data', and store it at this location.
    int byteLengthOffset = length - offset - 2;
    if (byteLengthOffset >= 0) {
      data[byteLengthOffset] = (byte) (byteLength >>> 8);
      data[byteLengthOffset + 1] = (byte) byteLength;
    }
    if (length + byteLength - offset > data.length) {
      enlarge(byteLength - offset);
    }
    int currentLength = length;
    for (int i = offset; i < charLength; ++i) {
      char charValue = stringValue.charAt(i);
      if (charValue >= 0x0001 && charValue <= 0x007F) {
        data[currentLength++] = (byte) charValue;
      } else if (charValue <= 0x07FF) {
        data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);
        data[currentLength++] = (byte) (0x80 | charValue & 0x3F);
      } else {
        data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);
        data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);
        data[currentLength++] = (byte) (0x80 | charValue & 0x3F);
      }
    }
    length = currentLength;
    return this;
  }

  /**
   * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if
   * necessary.
   *
   * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null
   *     bytes into this byte vector.
   * @param byteOffset index of the first byte of byteArrayValue that must be copied.
   * @param byteLength number of bytes of byteArrayValue that must be copied.
   * @return this byte vector.
   */
  public ByteVector putByteArray(
      final byte[] byteArrayValue, final int byteOffset, final int byteLength) {
    if (length + byteLength > data.length) {
      enlarge(byteLength);
    }
    if (byteArrayValue != null) {
      System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);
    }
    length += byteLength;
    return this;
  }

  /**
   * Enlarges this byte vector so that it can receive 'size' more bytes.
   *
   * @param size number of additional bytes that this byte vector should be able to receive.
   */
  private void enlarge(final int size) {
    if (length > data.length) {
      throw new AssertionError("Internal error");
    }
    int doubleCapacity = 2 * data.length;
    int minimalCapacity = length + size;
    byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];
    System.arraycopy(data, 0, newData, 0, length);
    data = newData;
  }
}

package org.objectweb.asm;

/**
 * A {@link MethodVisitor} that generates a corresponding 'method_info' structure, as defined in the
 * Java Virtual Machine Specification (JVMS).
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6">JVMS
 *     4.6</a>
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
final class MethodWriter extends MethodVisitor {

  /** Indicates that nothing must be computed. */
  static final int COMPUTE_NOTHING = 0;

  /**
   * Indicates that the maximum stack size and the maximum number of local variables must be
   * computed, from scratch.
   */
  static final int COMPUTE_MAX_STACK_AND_LOCAL = 1;

  /**
   * Indicates that the maximum stack size and the maximum number of local variables must be
   * computed, from the existing stack map frames. This can be done more efficiently than with the
   * control flow graph algorithm used for {@link #COMPUTE_MAX_STACK_AND_LOCAL}, by using a linear
   * scan of the bytecode instructions.
   */
  static final int COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES = 2;

  /**
   * Indicates that the stack map frames of type F_INSERT must be computed. The other frames are not
   * computed. They should all be of type F_NEW and should be sufficient to compute the content of
   * the F_INSERT frames, together with the bytecode instructions between a F_NEW and a F_INSERT
   * frame - and without any knowledge of the type hierarchy (by definition of F_INSERT).
   */
  static final int COMPUTE_INSERTED_FRAMES = 3;

  /**
   * Indicates that all the stack map frames must be computed. In this case the maximum stack size
   * and the maximum number of local variables is also computed.
   */
  static final int COMPUTE_ALL_FRAMES = 4;

  /** Indicates that {@link #STACK_SIZE_DELTA} is not applicable (not constant or never used). */
  private static final int NA = 0;

  /**
   * The stack size variation corresponding to each JVM opcode. The stack size variation for opcode
   * 'o' is given by the array element at index 'o'.
   *
   * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html">JVMS 6</a>
   */
  private static final int[] STACK_SIZE_DELTA = {
    0, // nop = 0 (0x0)
    1, // aconst_null = 1 (0x1)
    1, // iconst_m1 = 2 (0x2)
    1, // iconst_0 = 3 (0x3)
    1, // iconst_1 = 4 (0x4)
    1, // iconst_2 = 5 (0x5)
    1, // iconst_3 = 6 (0x6)
    1, // iconst_4 = 7 (0x7)
    1, // iconst_5 = 8 (0x8)
    2, // lconst_0 = 9 (0x9)
    2, // lconst_1 = 10 (0xa)
    1, // fconst_0 = 11 (0xb)
    1, // fconst_1 = 12 (0xc)
    1, // fconst_2 = 13 (0xd)
    2, // dconst_0 = 14 (0xe)
    2, // dconst_1 = 15 (0xf)
    1, // bipush = 16 (0x10)
    1, // sipush = 17 (0x11)
    1, // ldc = 18 (0x12)
    NA, // ldc_w = 19 (0x13)
    NA, // ldc2_w = 20 (0x14)
    1, // iload = 21 (0x15)
    2, // lload = 22 (0x16)
    1, // fload = 23 (0x17)
    2, // dload = 24 (0x18)
    1, // aload = 25 (0x19)
    NA, // iload_0 = 26 (0x1a)
    NA, // iload_1 = 27 (0x1b)
    NA, // iload_2 = 28 (0x1c)
    NA, // iload_3 = 29 (0x1d)
    NA, // lload_0 = 30 (0x1e)
    NA, // lload_1 = 31 (0x1f)
    NA, // lload_2 = 32 (0x20)
    NA, // lload_3 = 33 (0x21)
    NA, // fload_0 = 34 (0x22)
    NA, // fload_1 = 35 (0x23)
    NA, // fload_2 = 36 (0x24)
    NA, // fload_3 = 37 (0x25)
    NA, // dload_0 = 38 (0x26)
    NA, // dload_1 = 39 (0x27)
    NA, // dload_2 = 40 (0x28)
    NA, // dload_3 = 41 (0x29)
    NA, // aload_0 = 42 (0x2a)
    NA, // aload_1 = 43 (0x2b)
    NA, // aload_2 = 44 (0x2c)
    NA, // aload_3 = 45 (0x2d)
    -1, // iaload = 46 (0x2e)
    0, // laload = 47 (0x2f)
    -1, // faload = 48 (0x30)
    0, // daload = 49 (0x31)
    -1, // aaload = 50 (0x32)
    -1, // baload = 51 (0x33)
    -1, // caload = 52 (0x34)
    -1, // saload = 53 (0x35)
    -1, // istore = 54 (0x36)
    -2, // lstore = 55 (0x37)
    -1, // fstore = 56 (0x38)
    -2, // dstore = 57 (0x39)
    -1, // astore = 58 (0x3a)
    NA, // istore_0 = 59 (0x3b)
    NA, // istore_1 = 60 (0x3c)
    NA, // istore_2 = 61 (0x3d)
    NA, // istore_3 = 62 (0x3e)
    NA, // lstore_0 = 63 (0x3f)
    NA, // lstore_1 = 64 (0x40)
    NA, // lstore_2 = 65 (0x41)
    NA, // lstore_3 = 66 (0x42)
    NA, // fstore_0 = 67 (0x43)
    NA, // fstore_1 = 68 (0x44)
    NA, // fstore_2 = 69 (0x45)
    NA, // fstore_3 = 70 (0x46)
    NA, // dstore_0 = 71 (0x47)
    NA, // dstore_1 = 72 (0x48)
    NA, // dstore_2 = 73 (0x49)
    NA, // dstore_3 = 74 (0x4a)
    NA, // astore_0 = 75 (0x4b)
    NA, // astore_1 = 76 (0x4c)
    NA, // astore_2 = 77 (0x4d)
    NA, // astore_3 = 78 (0x4e)
    -3, // iastore = 79 (0x4f)
    -4, // lastore = 80 (0x50)
    -3, // fastore = 81 (0x51)
    -4, // dastore = 82 (0x52)
    -3, // aastore = 83 (0x53)
    -3, // bastore = 84 (0x54)
    -3, // castore = 85 (0x55)
    -3, // sastore = 86 (0x56)
    -1, // pop = 87 (0x57)
    -2, // pop2 = 88 (0x58)
    1, // dup = 89 (0x59)
    1, // dup_x1 = 90 (0x5a)
    1, // dup_x2 = 91 (0x5b)
    2, // dup2 = 92 (0x5c)
    2, // dup2_x1 = 93 (0x5d)
    2, // dup2_x2 = 94 (0x5e)
    0, // swap = 95 (0x5f)
    -1, // iadd = 96 (0x60)
    -2, // ladd = 97 (0x61)
    -1, // fadd = 98 (0x62)
    -2, // dadd = 99 (0x63)
    -1, // isub = 100 (0x64)
    -2, // lsub = 101 (0x65)
    -1, // fsub = 102 (0x66)
    -2, // dsub = 103 (0x67)
    -1, // imul = 104 (0x68)
    -2, // lmul = 105 (0x69)
    -1, // fmul = 106 (0x6a)
    -2, // dmul = 107 (0x6b)
    -1, // idiv = 108 (0x6c)
    -2, // ldiv = 109 (0x6d)
    -1, // fdiv = 110 (0x6e)
    -2, // ddiv = 111 (0x6f)
    -1, // irem = 112 (0x70)
    -2, // lrem = 113 (0x71)
    -1, // frem = 114 (0x72)
    -2, // drem = 115 (0x73)
    0, // ineg = 116 (0x74)
    0, // lneg = 117 (0x75)
    0, // fneg = 118 (0x76)
    0, // dneg = 119 (0x77)
    -1, // ishl = 120 (0x78)
    -1, // lshl = 121 (0x79)
    -1, // ishr = 122 (0x7a)
    -1, // lshr = 123 (0x7b)
    -1, // iushr = 124 (0x7c)
    -1, // lushr = 125 (0x7d)
    -1, // iand = 126 (0x7e)
    -2, // land = 127 (0x7f)
    -1, // ior = 128 (0x80)
    -2, // lor = 129 (0x81)
    -1, // ixor = 130 (0x82)
    -2, // lxor = 131 (0x83)
    0, // iinc = 132 (0x84)
    1, // i2l = 133 (0x85)
    0, // i2f = 134 (0x86)
    1, // i2d = 135 (0x87)
    -1, // l2i = 136 (0x88)
    -1, // l2f = 137 (0x89)
    0, // l2d = 138 (0x8a)
    0, // f2i = 139 (0x8b)
    1, // f2l = 140 (0x8c)
    1, // f2d = 141 (0x8d)
    -1, // d2i = 142 (0x8e)
    0, // d2l = 143 (0x8f)
    -1, // d2f = 144 (0x90)
    0, // i2b = 145 (0x91)
    0, // i2c = 146 (0x92)
    0, // i2s = 147 (0x93)
    -3, // lcmp = 148 (0x94)
    -1, // fcmpl = 149 (0x95)
    -1, // fcmpg = 150 (0x96)
    -3, // dcmpl = 151 (0x97)
    -3, // dcmpg = 152 (0x98)
    -1, // ifeq = 153 (0x99)
    -1, // ifne = 154 (0x9a)
    -1, // iflt = 155 (0x9b)
    -1, // ifge = 156 (0x9c)
    -1, // ifgt = 157 (0x9d)
    -1, // ifle = 158 (0x9e)
    -2, // if_icmpeq = 159 (0x9f)
    -2, // if_icmpne = 160 (0xa0)
    -2, // if_icmplt = 161 (0xa1)
    -2, // if_icmpge = 162 (0xa2)
    -2, // if_icmpgt = 163 (0xa3)
    -2, // if_icmple = 164 (0xa4)
    -2, // if_acmpeq = 165 (0xa5)
    -2, // if_acmpne = 166 (0xa6)
    0, // goto = 167 (0xa7)
    1, // jsr = 168 (0xa8)
    0, // ret = 169 (0xa9)
    -1, // tableswitch = 170 (0xaa)
    -1, // lookupswitch = 171 (0xab)
    -1, // ireturn = 172 (0xac)
    -2, // lreturn = 173 (0xad)
    -1, // freturn = 174 (0xae)
    -2, // dreturn = 175 (0xaf)
    -1, // areturn = 176 (0xb0)
    0, // return = 177 (0xb1)
    NA, // getstatic = 178 (0xb2)
    NA, // putstatic = 179 (0xb3)
    NA, // getfield = 180 (0xb4)
    NA, // putfield = 181 (0xb5)
    NA, // invokevirtual = 182 (0xb6)
    NA, // invokespecial = 183 (0xb7)
    NA, // invokestatic = 184 (0xb8)
    NA, // invokeinterface = 185 (0xb9)
    NA, // invokedynamic = 186 (0xba)
    1, // new = 187 (0xbb)
    0, // newarray = 188 (0xbc)
    0, // anewarray = 189 (0xbd)
    0, // arraylength = 190 (0xbe)
    NA, // athrow = 191 (0xbf)
    0, // checkcast = 192 (0xc0)
    0, // instanceof = 193 (0xc1)
    -1, // monitorenter = 194 (0xc2)
    -1, // monitorexit = 195 (0xc3)
    NA, // wide = 196 (0xc4)
    NA, // multianewarray = 197 (0xc5)
    -1, // ifnull = 198 (0xc6)
    -1, // ifnonnull = 199 (0xc7)
    NA, // goto_w = 200 (0xc8)
    NA // jsr_w = 201 (0xc9)
  };

  /** Where the constants used in this MethodWriter must be stored. */
  private final SymbolTable symbolTable;

  // Note: fields are ordered as in the method_info structure, and those related to attributes are
  // ordered as in Section 4.7 of the JVMS.

  /**
   * The access_flags field of the method_info JVMS structure. This field can contain ASM specific
   * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the
   * ClassFile structure.
   */
  private final int accessFlags;

  /** The name_index field of the method_info JVMS structure. */
  private final int nameIndex;

  /** The name of this method. */
  private final String name;

  /** The descriptor_index field of the method_info JVMS structure. */
  private final int descriptorIndex;

  /** The descriptor of this method. */
  private final String descriptor;

  // Code attribute fields and sub attributes:

  /** The max_stack field of the Code attribute. */
  private int maxStack;

  /** The max_locals field of the Code attribute. */
  private int maxLocals;

  /** The 'code' field of the Code attribute. */
  private final ByteVector code = new ByteVector();

  /**
   * The first element in the exception handler list (used to generate the exception_table of the
   * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May
   * be {@literal null}.
   */
  private Handler firstHandler;

  /**
   * The last element in the exception handler list (used to generate the exception_table of the
   * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May
   * be {@literal null}.
   */
  private Handler lastHandler;

  /** The line_number_table_length field of the LineNumberTable code attribute. */
  private int lineNumberTableLength;

  /** The line_number_table array of the LineNumberTable code attribute, or {@literal null}. */
  private ByteVector lineNumberTable;

  /** The local_variable_table_length field of the LocalVariableTable code attribute. */
  private int localVariableTableLength;

  /**
   * The local_variable_table array of the LocalVariableTable code attribute, or {@literal null}.
   */
  private ByteVector localVariableTable;

  /** The local_variable_type_table_length field of the LocalVariableTypeTable code attribute. */
  private int localVariableTypeTableLength;

  /**
   * The local_variable_type_table array of the LocalVariableTypeTable code attribute, or {@literal
   * null}.
   */
  private ByteVector localVariableTypeTable;

  /** The number_of_entries field of the StackMapTable code attribute. */
  private int stackMapTableNumberOfEntries;

  /** The 'entries' array of the StackMapTable code attribute. */
  private ByteVector stackMapTableEntries;

  /**
   * The last runtime visible type annotation of the Code attribute. The previous ones can be
   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastCodeRuntimeVisibleTypeAnnotation;

  /**
   * The last runtime invisible type annotation of the Code attribute. The previous ones can be
   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastCodeRuntimeInvisibleTypeAnnotation;

  /**
   * The first non standard attribute of the Code attribute. The next ones can be accessed with the
   * {@link Attribute#nextAttribute} field. May be {@literal null}.
   *
   * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.
   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link
   * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the
   * reverse order specified by the user.
   */
  private Attribute firstCodeAttribute;

  // Other method_info attributes:

  /** The number_of_exceptions field of the Exceptions attribute. */
  private final int numberOfExceptions;

  /** The exception_index_table array of the Exceptions attribute, or {@literal null}. */
  private final int[] exceptionIndexTable;

  /** The signature_index field of the Signature attribute. */
  private final int signatureIndex;

  /**
   * The last runtime visible annotation of this method. The previous ones can be accessed with the
   * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeVisibleAnnotation;

  /**
   * The last runtime invisible annotation of this method. The previous ones can be accessed with
   * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeInvisibleAnnotation;

  /** The number of method parameters that can have runtime visible annotations, or 0. */
  private int visibleAnnotableParameterCount;

  /**
   * The runtime visible parameter annotations of this method. Each array element contains the last
   * annotation of a parameter (which can be {@literal null} - the previous ones can be accessed
   * with the {@link AnnotationWriter#previousAnnotation} field). May be {@literal null}.
   */
  private AnnotationWriter[] lastRuntimeVisibleParameterAnnotations;

  /** The number of method parameters that can have runtime visible annotations, or 0. */
  private int invisibleAnnotableParameterCount;

  /**
   * The runtime invisible parameter annotations of this method. Each array element contains the
   * last annotation of a parameter (which can be {@literal null} - the previous ones can be
   * accessed with the {@link AnnotationWriter#previousAnnotation} field). May be {@literal null}.
   */
  private AnnotationWriter[] lastRuntimeInvisibleParameterAnnotations;

  /**
   * The last runtime visible type annotation of this method. The previous ones can be accessed with
   * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeVisibleTypeAnnotation;

  /**
   * The last runtime invisible type annotation of this method. The previous ones can be accessed
   * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;

  /** The default_value field of the AnnotationDefault attribute, or {@literal null}. */
  private ByteVector defaultValue;

  /** The parameters_count field of the MethodParameters attribute. */
  private int parametersCount;

  /** The 'parameters' array of the MethodParameters attribute, or {@literal null}. */
  private ByteVector parameters;

  /**
   * The first non standard attribute of this method. The next ones can be accessed with the {@link
   * Attribute#nextAttribute} field. May be {@literal null}.
   *
   * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.
   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link
   * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the
   * reverse order specified by the user.
   */
  private Attribute firstAttribute;

  // -----------------------------------------------------------------------------------------------
  // Fields used to compute the maximum stack size and number of locals, and the stack map frames
  // -----------------------------------------------------------------------------------------------

  /**
   * Indicates what must be computed. Must be one of {@link #COMPUTE_ALL_FRAMES}, {@link
   * #COMPUTE_INSERTED_FRAMES}, {@link COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link
   * #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_NOTHING}.
   */
  private final int compute;

  /**
   * The first basic block of the method. The next ones (in bytecode offset order) can be accessed
   * with the {@link Label#nextBasicBlock} field.
   */
  private Label firstBasicBlock;

  /**
   * The last basic block of the method (in bytecode offset order). This field is updated each time
   * a basic block is encountered, and is used to append it at the end of the basic block list.
   */
  private Label lastBasicBlock;

  /**
   * The current basic block, i.e. the basic block of the last visited instruction. When {@link
   * #compute} is equal to {@link #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_ALL_FRAMES}, this
   * field is {@literal null} for unreachable code. When {@link #compute} is equal to {@link
   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES} or {@link #COMPUTE_INSERTED_FRAMES}, this field stays
   * unchanged throughout the whole method (i.e. the whole code is seen as a single basic block;
   * indeed, the existing frames are sufficient by hypothesis to compute any intermediate frame -
   * and the maximum stack size as well - without using any control flow graph).
   */
  private Label currentBasicBlock;

  /**
   * The relative stack size after the last visited instruction. This size is relative to the
   * beginning of {@link #currentBasicBlock}, i.e. the true stack size after the last visited
   * instruction is equal to the {@link Label#inputStackSize} of the current basic block plus {@link
   * #relativeStackSize}. When {@link #compute} is equal to {@link
   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of
   * the method, so this relative size is also equal to the absolute stack size after the last
   * visited instruction.
   */
  private int relativeStackSize;

  /**
   * The maximum relative stack size after the last visited instruction. This size is relative to
   * the beginning of {@link #currentBasicBlock}, i.e. the true maximum stack size after the last
   * visited instruction is equal to the {@link Label#inputStackSize} of the current basic block
   * plus {@link #maxRelativeStackSize}.When {@link #compute} is equal to {@link
   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of
   * the method, so this relative size is also equal to the absolute maximum stack size after the
   * last visited instruction.
   */
  private int maxRelativeStackSize;

  /** The number of local variables in the last visited stack map frame. */
  private int currentLocals;

  /** The bytecode offset of the last frame that was written in {@link #stackMapTableEntries}. */
  private int previousFrameOffset;

  /**
   * The last frame that was written in {@link #stackMapTableEntries}. This field has the same
   * format as {@link #currentFrame}.
   */
  private int[] previousFrame;

  /**
   * The current stack map frame. The first element contains the bytecode offset of the instruction
   * to which the frame corresponds, the second element is the number of locals and the third one is
   * the number of stack elements. The local variables start at index 3 and are followed by the
   * operand stack elements. In summary frame[0] = offset, frame[1] = numLocal, frame[2] = numStack.
   * Local variables and operand stack entries contain abstract types, as defined in {@link Frame},
   * but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND}, {@link
   * Frame#UNINITIALIZED_KIND} or {@link Frame#FORWARD_UNINITIALIZED_KIND} abstract types. Long and
   * double types use only one array entry.
   */
  private int[] currentFrame;

  /** Whether this method contains subroutines. */
  private boolean hasSubroutines;

  // -----------------------------------------------------------------------------------------------
  // Other miscellaneous status fields
  // -----------------------------------------------------------------------------------------------

  /** Whether the bytecode of this method contains ASM specific instructions. */
  private boolean hasAsmInstructions;

  /**
   * The start offset of the last visited instruction. Used to set the offset field of type
   * annotations of type 'offset_target' (see <a
   * href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1">JVMS
   * 4.7.20.1</a>).
   */
  private int lastBytecodeOffset;

  /**
   * The offset in bytes in {@link SymbolTable#getSource} from which the method_info for this method
   * (excluding its first 6 bytes) must be copied, or 0.
   */
  private int sourceOffset;

  /**
   * The length in bytes in {@link SymbolTable#getSource} which must be copied to get the
   * method_info for this method (excluding its first 6 bytes for access_flags, name_index and
   * descriptor_index).
   */
  private int sourceLength;

  // -----------------------------------------------------------------------------------------------
  // Constructor and accessors
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link MethodWriter}.
   *
   * @param symbolTable where the constants used in this AnnotationWriter must be stored.
   * @param access the method's access flags (see {@link Opcodes}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param signature the method's signature. May be {@literal null}.
   * @param exceptions the internal names of the method's exceptions. May be {@literal null}.
   * @param compute indicates what must be computed (see #compute).
   */
  MethodWriter(
      final SymbolTable symbolTable,
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String @Nullable [] exceptions,
      final int compute) {
    super(/* latest api = */ Opcodes.ASM9);
    this.symbolTable = symbolTable;
    this.accessFlags = "<init>".equals(name) ? access | Constants.ACC_CONSTRUCTOR : access;
    this.nameIndex = symbolTable.addConstantUtf8(name);
    this.name = name;
    this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);
    this.descriptor = descriptor;
    this.signatureIndex = signature == null ? 0 : symbolTable.addConstantUtf8(signature);
    if (exceptions != null && exceptions.length > 0) {
      numberOfExceptions = exceptions.length;
      this.exceptionIndexTable = new int[numberOfExceptions];
      for (int i = 0; i < numberOfExceptions; ++i) {
        this.exceptionIndexTable[i] = symbolTable.addConstantClass(exceptions[i]).index;
      }
    } else {
      numberOfExceptions = 0;
      this.exceptionIndexTable = null;
    }
    this.compute = compute;
    if (compute != COMPUTE_NOTHING) {
      // Update maxLocals and currentLocals.
      int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;
      if ((access & Opcodes.ACC_STATIC) != 0) {
        --argumentsSize;
      }
      maxLocals = argumentsSize;
      currentLocals = argumentsSize;
      // Create and visit the label for the first basic block.
      firstBasicBlock = new Label();
      visitLabel(firstBasicBlock);
    }
  }

  boolean hasFrames() {
    return stackMapTableNumberOfEntries > 0;
  }

  boolean hasAsmInstructions() {
    return hasAsmInstructions;
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the MethodVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visitParameter(final String name, final int access) {
    if (parameters == null) {
      parameters = new ByteVector();
    }
    ++parametersCount;
    parameters.putShort((name == null) ? 0 : symbolTable.addConstantUtf8(name)).putShort(access);
  }

  @Override
  public AnnotationVisitor visitAnnotationDefault() {
    defaultValue = new ByteVector();
    return new AnnotationWriter(symbolTable, /* useNamedValues= */ false, defaultValue, null);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (visible) {
      return lastRuntimeVisibleAnnotation =
          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);
    } else {
      return lastRuntimeInvisibleAnnotation =
          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);
    }
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (visible) {
      return lastRuntimeVisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);
    } else {
      return lastRuntimeInvisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);
    }
  }

  @Override
  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    if (visible) {
      visibleAnnotableParameterCount = parameterCount;
    } else {
      invisibleAnnotableParameterCount = parameterCount;
    }
  }

  @Override
  public AnnotationVisitor visitParameterAnnotation(
      final int parameter, final String annotationDescriptor, final boolean visible) {
    if (visible) {
      if (lastRuntimeVisibleParameterAnnotations == null) {
        lastRuntimeVisibleParameterAnnotations =
            new AnnotationWriter[Type.getArgumentCount(descriptor)];
      }
      return lastRuntimeVisibleParameterAnnotations[parameter] =
          AnnotationWriter.create(
              symbolTable, annotationDescriptor, lastRuntimeVisibleParameterAnnotations[parameter]);
    } else {
      if (lastRuntimeInvisibleParameterAnnotations == null) {
        lastRuntimeInvisibleParameterAnnotations =
            new AnnotationWriter[Type.getArgumentCount(descriptor)];
      }
      return lastRuntimeInvisibleParameterAnnotations[parameter] =
          AnnotationWriter.create(
              symbolTable,
              annotationDescriptor,
              lastRuntimeInvisibleParameterAnnotations[parameter]);
    }
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    // Store the attributes in the <i>reverse</i> order of their visit by this method.
    if (attribute.isCodeAttribute()) {
      attribute.nextAttribute = firstCodeAttribute;
      firstCodeAttribute = attribute;
    } else {
      attribute.nextAttribute = firstAttribute;
      firstAttribute = attribute;
    }
  }

  @Override
  public void visitCode() {
    // Nothing to do.
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    if (compute == COMPUTE_ALL_FRAMES) {
      return;
    }

    if (compute == COMPUTE_INSERTED_FRAMES) {
      if (currentBasicBlock.frame == null) {
        // This should happen only once, for the implicit first frame (which is explicitly visited
        // in ClassReader if the EXPAND_ASM_INSNS option is used - and COMPUTE_INSERTED_FRAMES
        // can't be set if EXPAND_ASM_INSNS is not used).
        currentBasicBlock.frame = new CurrentFrame(currentBasicBlock);
        currentBasicBlock.frame.setInputFrameFromDescriptor(
            symbolTable, accessFlags, descriptor, numLocal);
        currentBasicBlock.frame.accept(this);
      } else {
        if (type == Opcodes.F_NEW) {
          currentBasicBlock.frame.setInputFrameFromApiFormat(
              symbolTable, numLocal, local, numStack, stack);
        }
        // If type is not F_NEW then it is F_INSERT by hypothesis, and currentBlock.frame contains
        // the stack map frame at the current instruction, computed from the last F_NEW frame and
        // the bytecode instructions in between (via calls to CurrentFrame#execute).
        currentBasicBlock.frame.accept(this);
      }
    } else if (type == Opcodes.F_NEW) {
      if (previousFrame == null) {
        int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) >> 2;
        Frame implicitFirstFrame = new Frame(new Label());
        implicitFirstFrame.setInputFrameFromDescriptor(
            symbolTable, accessFlags, descriptor, argumentsSize);
        implicitFirstFrame.accept(this);
      }
      currentLocals = numLocal;
      int frameIndex = visitFrameStart(code.length, numLocal, numStack);
      for (int i = 0; i < numLocal; ++i) {
        currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, local[i]);
      }
      for (int i = 0; i < numStack; ++i) {
        currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, stack[i]);
      }
      visitFrameEnd();
    } else {
      if (symbolTable.getMajorVersion() < Opcodes.V1_6) {
        throw new IllegalArgumentException("Class versions V1_5 or less must use F_NEW frames.");
      }
      int offsetDelta;
      if (stackMapTableEntries == null) {
        stackMapTableEntries = new ByteVector();
        offsetDelta = code.length;
      } else {
        offsetDelta = code.length - previousFrameOffset - 1;
        if (offsetDelta < 0) {
          if (type == Opcodes.F_SAME) {
            return;
          } else {
            throw new IllegalStateException();
          }
        }
      }

      switch (type) {
        case Opcodes.F_FULL:
          currentLocals = numLocal;
          stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);
          for (int i = 0; i < numLocal; ++i) {
            putFrameType(local[i]);
          }
          stackMapTableEntries.putShort(numStack);
          for (int i = 0; i < numStack; ++i) {
            putFrameType(stack[i]);
          }
          break;
        case Opcodes.F_APPEND:
          currentLocals += numLocal;
          stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocal).putShort(offsetDelta);
          for (int i = 0; i < numLocal; ++i) {
            putFrameType(local[i]);
          }
          break;
        case Opcodes.F_CHOP:
          currentLocals -= numLocal;
          stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED - numLocal).putShort(offsetDelta);
          break;
        case Opcodes.F_SAME:
          if (offsetDelta < 64) {
            stackMapTableEntries.putByte(offsetDelta);
          } else {
            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);
          }
          break;
        case Opcodes.F_SAME1:
          if (offsetDelta < 64) {
            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);
          } else {
            stackMapTableEntries
                .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
                .putShort(offsetDelta);
          }
          putFrameType(stack[0]);
          break;
        default:
          throw new IllegalArgumentException();
      }

      previousFrameOffset = code.length;
      ++stackMapTableNumberOfEntries;
    }

    if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {
      relativeStackSize = numStack;
      for (int i = 0; i < numStack; ++i) {
        if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {
          relativeStackSize++;
        }
      }
      if (relativeStackSize > maxRelativeStackSize) {
        maxRelativeStackSize = relativeStackSize;
      }
    }

    maxStack = Math.max(maxStack, numStack);
    maxLocals = Math.max(maxLocals, currentLocals);
  }

  @Override
  public void visitInsn(final int opcode) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    code.putByte(opcode);
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(opcode, 0, null, null);
      } else {
        int size = relativeStackSize + STACK_SIZE_DELTA[opcode];
        if (size > maxRelativeStackSize) {
          maxRelativeStackSize = size;
        }
        relativeStackSize = size;
      }
      if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {
        endCurrentBasicBlockWithNoSuccessor();
      }
    }
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    if (opcode == Opcodes.SIPUSH) {
      code.put12(opcode, operand);
    } else { // BIPUSH or NEWARRAY
      code.put11(opcode, operand);
    }
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(opcode, operand, null, null);
      } else if (opcode != Opcodes.NEWARRAY) {
        // The stack size delta is 1 for BIPUSH or SIPUSH, and 0 for NEWARRAY.
        int size = relativeStackSize + 1;
        if (size > maxRelativeStackSize) {
          maxRelativeStackSize = size;
        }
        relativeStackSize = size;
      }
    }
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    if (varIndex < 4 && opcode != Opcodes.RET) {
      int optimizedOpcode;
      if (opcode < Opcodes.ISTORE) {
        optimizedOpcode = Constants.ILOAD_0 + ((opcode - Opcodes.ILOAD) << 2) + varIndex;
      } else {
        optimizedOpcode = Constants.ISTORE_0 + ((opcode - Opcodes.ISTORE) << 2) + varIndex;
      }
      code.putByte(optimizedOpcode);
    } else if (varIndex >= 256) {
      code.putByte(Constants.WIDE).put12(opcode, varIndex);
    } else {
      code.put11(opcode, varIndex);
    }
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(opcode, varIndex, null, null);
      } else {
        if (opcode == Opcodes.RET) {
          // No stack size delta.
          currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_END;
          currentBasicBlock.outputStackSize = (short) relativeStackSize;
          endCurrentBasicBlockWithNoSuccessor();
        } else { // xLOAD or xSTORE
          int size = relativeStackSize + STACK_SIZE_DELTA[opcode];
          if (size > maxRelativeStackSize) {
            maxRelativeStackSize = size;
          }
          relativeStackSize = size;
        }
      }
    }
    if (compute != COMPUTE_NOTHING) {
      int currentMaxLocals;
      if (opcode == Opcodes.LLOAD
          || opcode == Opcodes.DLOAD
          || opcode == Opcodes.LSTORE
          || opcode == Opcodes.DSTORE) {
        currentMaxLocals = varIndex + 2;
      } else {
        currentMaxLocals = varIndex + 1;
      }
      if (currentMaxLocals > maxLocals) {
        maxLocals = currentMaxLocals;
      }
    }
    if (opcode >= Opcodes.ISTORE && compute == COMPUTE_ALL_FRAMES && firstHandler != null) {
      // If there are exception handler blocks, each instruction within a handler range is, in
      // theory, a basic block (since execution can jump from this instruction to the exception
      // handler). As a consequence, the local variable types at the beginning of the handler
      // block should be the merge of the local variable types at all the instructions within the
      // handler range. However, instead of creating a basic block for each instruction, we can
      // get the same result in a more efficient way. Namely, by starting a new basic block after
      // each xSTORE instruction, which is what we do here.
      visitLabel(new Label());
    }
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    Symbol typeSymbol = symbolTable.addConstantClass(type);
    code.put12(opcode, typeSymbol.index);
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);
      } else if (opcode == Opcodes.NEW) {
        // The stack size delta is 1 for NEW, and 0 for ANEWARRAY, CHECKCAST, or INSTANCEOF.
        int size = relativeStackSize + 1;
        if (size > maxRelativeStackSize) {
          maxRelativeStackSize = size;
        }
        relativeStackSize = size;
      }
    }
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    Symbol fieldrefSymbol = symbolTable.addConstantFieldref(owner, name, descriptor);
    code.put12(opcode, fieldrefSymbol.index);
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);
      } else {
        int size;
        char firstDescChar = descriptor.charAt(0);
        switch (opcode) {
          case Opcodes.GETSTATIC:
            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 2 : 1);
            break;
          case Opcodes.PUTSTATIC:
            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -2 : -1);
            break;
          case Opcodes.GETFIELD:
            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 1 : 0);
            break;
          case Opcodes.PUTFIELD:
          default:
            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -3 : -2);
            break;
        }
        if (size > maxRelativeStackSize) {
          maxRelativeStackSize = size;
        }
        relativeStackSize = size;
      }
    }
  }

  @Override
  public void visitMethodInsn(
      final int opcode,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    Symbol methodrefSymbol = symbolTable.addConstantMethodref(owner, name, descriptor, isInterface);
    if (opcode == Opcodes.INVOKEINTERFACE) {
      code.put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index)
          .put11(methodrefSymbol.getArgumentsAndReturnSizes() >> 2, 0);
    } else {
      code.put12(opcode, methodrefSymbol.index);
    }
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(opcode, 0, methodrefSymbol, symbolTable);
      } else {
        int argumentsAndReturnSize = methodrefSymbol.getArgumentsAndReturnSizes();
        int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2);
        int size;
        if (opcode == Opcodes.INVOKESTATIC) {
          size = relativeStackSize + stackSizeDelta + 1;
        } else {
          size = relativeStackSize + stackSizeDelta;
        }
        if (size > maxRelativeStackSize) {
          maxRelativeStackSize = size;
        }
        relativeStackSize = size;
      }
    }
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    Symbol invokeDynamicSymbol =
        symbolTable.addConstantInvokeDynamic(
            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
    code.put12(Opcodes.INVOKEDYNAMIC, invokeDynamicSymbol.index);
    code.putShort(0);
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, invokeDynamicSymbol, symbolTable);
      } else {
        int argumentsAndReturnSize = invokeDynamicSymbol.getArgumentsAndReturnSizes();
        int stackSizeDelta = (argumentsAndReturnSize & 3) - (argumentsAndReturnSize >> 2) + 1;
        int size = relativeStackSize + stackSizeDelta;
        if (size > maxRelativeStackSize) {
          maxRelativeStackSize = size;
        }
        relativeStackSize = size;
      }
    }
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    // Compute the 'base' opcode, i.e. GOTO or JSR if opcode is GOTO_W or JSR_W, otherwise opcode.
    int baseOpcode =
        opcode >= Constants.GOTO_W ? opcode - Constants.WIDE_JUMP_OPCODE_DELTA : opcode;
    boolean nextInsnIsJumpTarget = false;
    if ((label.flags & Label.FLAG_RESOLVED) != 0
        && label.bytecodeOffset - code.length < Short.MIN_VALUE) {
      // Case of a backward jump with an offset < -32768. In this case we automatically replace GOTO
      // with GOTO_W, JSR with JSR_W and IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:..., where
      // IFNOTxxx is the "opposite" opcode of IFxxx (e.g. IFNE for IFEQ) and where <L> designates
      // the instruction just after the GOTO_W.
      if (baseOpcode == Opcodes.GOTO) {
        code.putByte(Constants.GOTO_W);
      } else if (baseOpcode == Opcodes.JSR) {
        code.putByte(Constants.JSR_W);
      } else {
        // Put the "opposite" opcode of baseOpcode. This can be done by flipping the least
        // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ (with a
        // pre and post offset by 1). The jump offset is 8 bytes (3 for IFNOTxxx, 5 for GOTO_W).
        code.putByte(baseOpcode >= Opcodes.IFNULL ? baseOpcode ^ 1 : ((baseOpcode + 1) ^ 1) - 1);
        code.putShort(8);
        // Here we could put a GOTO_W in theory, but if ASM specific instructions are used in this
        // method or another one, and if the class has frames, we will need to insert a frame after
        // this GOTO_W during the additional ClassReader -> ClassWriter round trip to remove the ASM
        // specific instructions. To not miss this additional frame, we need to use an ASM_GOTO_W
        // here, which has the unfortunate effect of forcing this additional round trip (which in
        // some case would not have been really necessary, but we can't know this at this point).
        code.putByte(Constants.ASM_GOTO_W);
        hasAsmInstructions = true;
        // The instruction after the GOTO_W becomes the target of the IFNOT instruction.
        nextInsnIsJumpTarget = true;
      }
      label.put(code, code.length - 1, true);
    } else if (baseOpcode != opcode) {
      // Case of a GOTO_W or JSR_W specified by the user (normally ClassReader when used to remove
      // ASM specific instructions). In this case we keep the original instruction.
      code.putByte(opcode);
      label.put(code, code.length - 1, true);
    } else {
      // Case of a jump with an offset >= -32768, or of a jump with an unknown offset. In these
      // cases we store the offset in 2 bytes (which will be increased via a ClassReader ->
      // ClassWriter round trip if it turns out that 2 bytes are not sufficient).
      code.putByte(baseOpcode);
      label.put(code, code.length - 1, false);
    }

    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      Label nextBasicBlock = null;
      if (compute == COMPUTE_ALL_FRAMES) {
        currentBasicBlock.frame.execute(baseOpcode, 0, null, null);
        // Record the fact that 'label' is the target of a jump instruction.
        label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;
        // Add 'label' as a successor of the current basic block.
        addSuccessorToCurrentBasicBlock(Edge.JUMP, label);
        if (baseOpcode != Opcodes.GOTO) {
          // The next instruction starts a new basic block (except for GOTO: by default the code
          // following a goto is unreachable - unless there is an explicit label for it - and we
          // should not compute stack frame types for its instructions).
          nextBasicBlock = new Label();
        }
      } else if (compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(baseOpcode, 0, null, null);
      } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {
        // No need to update maxRelativeStackSize (the stack size delta is always negative).
        relativeStackSize += STACK_SIZE_DELTA[baseOpcode];
      } else {
        if (baseOpcode == Opcodes.JSR) {
          // Record the fact that 'label' designates a subroutine, if not already done.
          if ((label.flags & Label.FLAG_SUBROUTINE_START) == 0) {
            label.flags |= Label.FLAG_SUBROUTINE_START;
            hasSubroutines = true;
          }
          currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_CALLER;
          // Note that, by construction in this method, a block which calls a subroutine has at
          // least two successors in the control flow graph: the first one (added below) leads to
          // the instruction after the JSR, while the second one (added here) leads to the JSR
          // target. Note that the first successor is virtual (it does not correspond to a possible
          // execution path): it is only used to compute the successors of the basic blocks ending
          // with a ret, in {@link Label#addSubroutineRetSuccessors}.
          addSuccessorToCurrentBasicBlock(relativeStackSize + 1, label);
          // The instruction after the JSR starts a new basic block.
          nextBasicBlock = new Label();
        } else {
          // No need to update maxRelativeStackSize (the stack size delta is always negative).
          relativeStackSize += STACK_SIZE_DELTA[baseOpcode];
          addSuccessorToCurrentBasicBlock(relativeStackSize, label);
        }
      }
      // If the next instruction starts a new basic block, call visitLabel to add the label of this
      // instruction as a successor of the current block, and to start a new basic block.
      if (nextBasicBlock != null) {
        if (nextInsnIsJumpTarget) {
          nextBasicBlock.flags |= Label.FLAG_JUMP_TARGET;
        }
        visitLabel(nextBasicBlock);
      }
      if (baseOpcode == Opcodes.GOTO) {
        endCurrentBasicBlockWithNoSuccessor();
      }
    }
  }

  @Override
  public void visitLabel(final Label label) {
    // Resolve the forward references to this label, if any.
    hasAsmInstructions |= label.resolve(code.data, stackMapTableEntries, code.length);
    // visitLabel starts a new basic block (except for debug only labels), so we need to update the
    // previous and current block references and list of successors.
    if ((label.flags & Label.FLAG_DEBUG_ONLY) != 0) {
      return;
    }
    if (compute == COMPUTE_ALL_FRAMES) {
      if (currentBasicBlock != null) {
        if (label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {
          // We use {@link Label#getCanonicalInstance} to store the state of a basic block in only
          // one place, but this does not work for labels which have not been visited yet.
          // Therefore, when we detect here two labels having the same bytecode offset, we need to
          // - consolidate the state scattered in these two instances into the canonical instance:
          currentBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);
          // - make sure the two instances share the same Frame instance (the implementation of
          // {@link Label#getCanonicalInstance} relies on this property; here label.frame should be
          // null):
          label.frame = currentBasicBlock.frame;
          // - and make sure to NOT assign 'label' into 'currentBasicBlock' or 'lastBasicBlock', so
          // that they still refer to the canonical instance for this bytecode offset.
          return;
        }
        // End the current basic block (with one new successor).
        addSuccessorToCurrentBasicBlock(Edge.JUMP, label);
      }
      // Append 'label' at the end of the basic block list.
      if (lastBasicBlock != null) {
        if (label.bytecodeOffset == lastBasicBlock.bytecodeOffset) {
          // Same comment as above.
          lastBasicBlock.flags |= (label.flags & Label.FLAG_JUMP_TARGET);
          // Here label.frame should be null.
          label.frame = lastBasicBlock.frame;
          currentBasicBlock = lastBasicBlock;
          return;
        }
        lastBasicBlock.nextBasicBlock = label;
      }
      lastBasicBlock = label;
      // Make it the new current basic block.
      currentBasicBlock = label;
      // Here label.frame should be null.
      label.frame = new Frame(label);
    } else if (compute == COMPUTE_INSERTED_FRAMES) {
      if (currentBasicBlock == null) {
        // This case should happen only once, for the visitLabel call in the constructor. Indeed, if
        // compute is equal to COMPUTE_INSERTED_FRAMES, currentBasicBlock stays unchanged.
        currentBasicBlock = label;
      } else {
        // Update the frame owner so that a correct frame offset is computed in Frame.accept().
        currentBasicBlock.frame.owner = label;
      }
    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {
      if (currentBasicBlock != null) {
        // End the current basic block (with one new successor).
        currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;
        addSuccessorToCurrentBasicBlock(relativeStackSize, label);
      }
      // Start a new current basic block, and reset the current and maximum relative stack sizes.
      currentBasicBlock = label;
      relativeStackSize = 0;
      maxRelativeStackSize = 0;
      // Append the new basic block at the end of the basic block list.
      if (lastBasicBlock != null) {
        lastBasicBlock.nextBasicBlock = label;
      }
      lastBasicBlock = label;
    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES && currentBasicBlock == null) {
      // This case should happen only once, for the visitLabel call in the constructor. Indeed, if
      // compute is equal to COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES, currentBasicBlock stays
      // unchanged.
      currentBasicBlock = label;
    }
  }

  @Override
  public void visitLdcInsn(final Object value) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    Symbol constantSymbol = symbolTable.addConstant(value);
    int constantIndex = constantSymbol.index;
    char firstDescriptorChar;
    boolean isLongOrDouble =
        constantSymbol.tag == Symbol.CONSTANT_LONG_TAG
            || constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG
            || (constantSymbol.tag == Symbol.CONSTANT_DYNAMIC_TAG
                && ((firstDescriptorChar = constantSymbol.value.charAt(0)) == 'J'
                    || firstDescriptorChar == 'D'));
    if (isLongOrDouble) {
      code.put12(Constants.LDC2_W, constantIndex);
    } else if (constantIndex >= 256) {
      code.put12(Constants.LDC_W, constantIndex);
    } else {
      code.put11(Opcodes.LDC, constantIndex);
    }
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);
      } else {
        int size = relativeStackSize + (isLongOrDouble ? 2 : 1);
        if (size > maxRelativeStackSize) {
          maxRelativeStackSize = size;
        }
        relativeStackSize = size;
      }
    }
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    if ((varIndex > 255) || (increment > 127) || (increment < -128)) {
      code.putByte(Constants.WIDE).put12(Opcodes.IINC, varIndex).putShort(increment);
    } else {
      code.putByte(Opcodes.IINC).put11(varIndex, increment);
    }
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null
        && (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES)) {
      currentBasicBlock.frame.execute(Opcodes.IINC, varIndex, null, null);
    }
    if (compute != COMPUTE_NOTHING) {
      int currentMaxLocals = varIndex + 1;
      if (currentMaxLocals > maxLocals) {
        maxLocals = currentMaxLocals;
      }
    }
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    code.putByte(Opcodes.TABLESWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);
    dflt.put(code, lastBytecodeOffset, true);
    code.putInt(min).putInt(max);
    for (Label label : labels) {
      label.put(code, lastBytecodeOffset, true);
    }
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    visitSwitchInsn(dflt, labels);
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    code.putByte(Opcodes.LOOKUPSWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);
    dflt.put(code, lastBytecodeOffset, true);
    code.putInt(labels.length);
    for (int i = 0; i < labels.length; ++i) {
      code.putInt(keys[i]);
      labels[i].put(code, lastBytecodeOffset, true);
    }
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    visitSwitchInsn(dflt, labels);
  }

  private void visitSwitchInsn(final Label dflt, final Label[] labels) {
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES) {
        currentBasicBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);
        // Add all the labels as successors of the current basic block.
        addSuccessorToCurrentBasicBlock(Edge.JUMP, dflt);
        dflt.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;
        for (Label label : labels) {
          addSuccessorToCurrentBasicBlock(Edge.JUMP, label);
          label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;
        }
      } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {
        // No need to update maxRelativeStackSize (the stack size delta is always negative).
        --relativeStackSize;
        // Add all the labels as successors of the current basic block.
        addSuccessorToCurrentBasicBlock(relativeStackSize, dflt);
        for (Label label : labels) {
          addSuccessorToCurrentBasicBlock(relativeStackSize, label);
        }
      }
      // End the current basic block.
      endCurrentBasicBlockWithNoSuccessor();
    }
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    lastBytecodeOffset = code.length;
    // Add the instruction to the bytecode of the method.
    Symbol descSymbol = symbolTable.addConstantClass(descriptor);
    code.put12(Opcodes.MULTIANEWARRAY, descSymbol.index).putByte(numDimensions);
    // If needed, update the maximum stack size and number of locals, and stack map frames.
    if (currentBasicBlock != null) {
      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {
        currentBasicBlock.frame.execute(
            Opcodes.MULTIANEWARRAY, numDimensions, descSymbol, symbolTable);
      } else {
        // No need to update maxRelativeStackSize (the stack size delta is always negative).
        relativeStackSize += 1 - numDimensions;
      }
    }
  }

  @Override
  public AnnotationVisitor visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (visible) {
      return lastCodeRuntimeVisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable,
              (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8),
              typePath,
              descriptor,
              lastCodeRuntimeVisibleTypeAnnotation);
    } else {
      return lastCodeRuntimeInvisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable,
              (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8),
              typePath,
              descriptor,
              lastCodeRuntimeInvisibleTypeAnnotation);
    }
  }

  @Override
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @InternalForm String type) {
    Handler newHandler =
        new Handler(
            start, end, handler, type != null ? symbolTable.addConstantClass(type).index : 0, type);
    if (firstHandler == null) {
      firstHandler = newHandler;
    } else {
      lastHandler.nextHandler = newHandler;
    }
    lastHandler = newHandler;
  }

  @Override
  public AnnotationVisitor visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (visible) {
      return lastCodeRuntimeVisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeVisibleTypeAnnotation);
    } else {
      return lastCodeRuntimeInvisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);
    }
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    if (signature != null) {
      if (localVariableTypeTable == null) {
        localVariableTypeTable = new ByteVector();
      }
      ++localVariableTypeTableLength;
      localVariableTypeTable
          .putShort(start.bytecodeOffset)
          .putShort(end.bytecodeOffset - start.bytecodeOffset)
          .putShort(symbolTable.addConstantUtf8(name))
          .putShort(symbolTable.addConstantUtf8(signature))
          .putShort(index);
    }
    if (localVariableTable == null) {
      localVariableTable = new ByteVector();
    }
    ++localVariableTableLength;
    localVariableTable
        .putShort(start.bytecodeOffset)
        .putShort(end.bytecodeOffset - start.bytecodeOffset)
        .putShort(symbolTable.addConstantUtf8(name))
        .putShort(symbolTable.addConstantUtf8(descriptor))
        .putShort(index);
    if (compute != COMPUTE_NOTHING) {
      char firstDescChar = descriptor.charAt(0);
      int currentMaxLocals = index + (firstDescChar == 'J' || firstDescChar == 'D' ? 2 : 1);
      if (currentMaxLocals > maxLocals) {
        maxLocals = currentMaxLocals;
      }
    }
  }

  @Override
  public AnnotationVisitor visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    // Create a ByteVector to hold a 'type_annotation' JVMS structure.
    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.
    ByteVector typeAnnotation = new ByteVector();
    // Write target_type, target_info, and target_path.
    typeAnnotation.putByte(typeRef >>> 24).putShort(start.length);
    for (int i = 0; i < start.length; ++i) {
      typeAnnotation
          .putShort(start[i].bytecodeOffset)
          .putShort(end[i].bytecodeOffset - start[i].bytecodeOffset)
          .putShort(index[i]);
    }
    TypePath.put(typePath, typeAnnotation);
    // Write type_index and reserve space for num_element_value_pairs.
    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);
    if (visible) {
      return lastCodeRuntimeVisibleTypeAnnotation =
          new AnnotationWriter(
              symbolTable,
              /* useNamedValues= */ true,
              typeAnnotation,
              lastCodeRuntimeVisibleTypeAnnotation);
    } else {
      return lastCodeRuntimeInvisibleTypeAnnotation =
          new AnnotationWriter(
              symbolTable,
              /* useNamedValues= */ true,
              typeAnnotation,
              lastCodeRuntimeInvisibleTypeAnnotation);
    }
  }

  @Override
  public void visitLineNumber(final int line, final Label start) {
    if (lineNumberTable == null) {
      lineNumberTable = new ByteVector();
    }
    ++lineNumberTableLength;
    lineNumberTable.putShort(start.bytecodeOffset);
    lineNumberTable.putShort(line);
  }

  @Override
  public void visitMaxs(final int maxStack, final int maxLocals) {
    if (compute == COMPUTE_ALL_FRAMES) {
      computeAllFrames();
    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {
      computeMaxStackAndLocal();
    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {
      this.maxStack = maxRelativeStackSize;
    } else {
      this.maxStack = maxStack;
      this.maxLocals = maxLocals;
    }
  }

  /** Computes all the stack map frames of the method, from scratch. */
  private void computeAllFrames() {
    // Complete the control flow graph with exception handler blocks.
    Handler handler = firstHandler;
    while (handler != null) {
      String catchTypeDescriptor =
          handler.catchTypeDescriptor == null ? "java/lang/Throwable" : handler.catchTypeDescriptor;
      int catchType = Frame.getAbstractTypeFromInternalName(symbolTable, catchTypeDescriptor);
      // Mark handlerBlock as an exception handler.
      Label handlerBlock = handler.handlerPc.getCanonicalInstance();
      handlerBlock.flags |= Label.FLAG_JUMP_TARGET;
      // Add handlerBlock as a successor of all the basic blocks in the exception handler range.
      Label handlerRangeBlock = handler.startPc.getCanonicalInstance();
      Label handlerRangeEnd = handler.endPc.getCanonicalInstance();
      while (handlerRangeBlock != handlerRangeEnd) {
        handlerRangeBlock.outgoingEdges =
            new Edge(catchType, handlerBlock, handlerRangeBlock.outgoingEdges);
        handlerRangeBlock = handlerRangeBlock.nextBasicBlock;
      }
      handler = handler.nextHandler;
    }

    // Create and visit the first (implicit) frame.
    Frame firstFrame = firstBasicBlock.frame;
    firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);
    firstFrame.accept(this);

    // Fix point algorithm: add the first basic block to a list of blocks to process (i.e. blocks
    // whose stack map frame has changed) and, while there are blocks to process, remove one from
    // the list and update the stack map frames of its successor blocks in the control flow graph
    // (which might change them, in which case these blocks must be processed too, and are thus
    // added to the list of blocks to process). Also compute the maximum stack size of the method,
    // as a by-product.
    Label listOfBlocksToProcess = firstBasicBlock;
    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;
    int maxStackSize = 0;
    while (listOfBlocksToProcess != Label.EMPTY_LIST) {
      // Remove a basic block from the list of blocks to process.
      Label basicBlock = listOfBlocksToProcess;
      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;
      basicBlock.nextListElement = null;
      // By definition, basicBlock is reachable.
      basicBlock.flags |= Label.FLAG_REACHABLE;
      // Update the (absolute) maximum stack size.
      int maxBlockStackSize = basicBlock.frame.getInputStackSize() + basicBlock.outputStackMax;
      if (maxBlockStackSize > maxStackSize) {
        maxStackSize = maxBlockStackSize;
      }
      // Update the successor blocks of basicBlock in the control flow graph.
      Edge outgoingEdge = basicBlock.outgoingEdges;
      while (outgoingEdge != null) {
        Label successorBlock = outgoingEdge.successor.getCanonicalInstance();
        boolean successorBlockChanged =
            basicBlock.frame.merge(symbolTable, successorBlock.frame, outgoingEdge.info);
        if (successorBlockChanged && successorBlock.nextListElement == null) {
          // If successorBlock has changed it must be processed. Thus, if it is not already in the
          // list of blocks to process, add it to this list.
          successorBlock.nextListElement = listOfBlocksToProcess;
          listOfBlocksToProcess = successorBlock;
        }
        outgoingEdge = outgoingEdge.nextEdge;
      }
    }

    // Loop over all the basic blocks and visit the stack map frames that must be stored in the
    // StackMapTable attribute. Also replace unreachable code with NOP* ATHROW, and remove it from
    // exception handler ranges.
    Label basicBlock = firstBasicBlock;
    while (basicBlock != null) {
      if ((basicBlock.flags & (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE))
          == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {
        basicBlock.frame.accept(this);
      }
      if ((basicBlock.flags & Label.FLAG_REACHABLE) == 0) {
        // Find the start and end bytecode offsets of this unreachable block.
        Label nextBasicBlock = basicBlock.nextBasicBlock;
        int startOffset = basicBlock.bytecodeOffset;
        int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;
        if (endOffset >= startOffset) {
          // Replace its instructions with NOP ... NOP ATHROW.
          for (int i = startOffset; i < endOffset; ++i) {
            code.data[i] = Opcodes.NOP;
          }
          code.data[endOffset] = (byte) Opcodes.ATHROW;
          // Emit a frame for this unreachable block, with no local and a Throwable on the stack
          // (so that the ATHROW could consume this Throwable if it were reachable).
          int frameIndex = visitFrameStart(startOffset, /* numLocal= */ 0, /* numStack= */ 1);
          currentFrame[frameIndex] =
              Frame.getAbstractTypeFromInternalName(symbolTable, "java/lang/Throwable");
          visitFrameEnd();
          // Remove this unreachable basic block from the exception handler ranges.
          firstHandler = Handler.removeRange(firstHandler, basicBlock, nextBasicBlock);
          // The maximum stack size is now at least one, because of the Throwable declared above.
          maxStackSize = Math.max(maxStackSize, 1);
        }
      }
      basicBlock = basicBlock.nextBasicBlock;
    }

    this.maxStack = maxStackSize;
  }

  /** Computes the maximum stack size of the method. */
  private void computeMaxStackAndLocal() {
    // Complete the control flow graph with exception handler blocks.
    Handler handler = firstHandler;
    while (handler != null) {
      Label handlerBlock = handler.handlerPc;
      Label handlerRangeBlock = handler.startPc;
      Label handlerRangeEnd = handler.endPc;
      // Add handlerBlock as a successor of all the basic blocks in the exception handler range.
      while (handlerRangeBlock != handlerRangeEnd) {
        if ((handlerRangeBlock.flags & Label.FLAG_SUBROUTINE_CALLER) == 0) {
          handlerRangeBlock.outgoingEdges =
              new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges);
        } else {
          // If handlerRangeBlock is a JSR block, add handlerBlock after the first two outgoing
          // edges to preserve the hypothesis about JSR block successors order (see
          // {@link #visitJumpInsn}).
          handlerRangeBlock.outgoingEdges.nextEdge.nextEdge =
              new Edge(
                  Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges.nextEdge.nextEdge);
        }
        handlerRangeBlock = handlerRangeBlock.nextBasicBlock;
      }
      handler = handler.nextHandler;
    }

    // Complete the control flow graph with the successor blocks of subroutines, if needed.
    if (hasSubroutines) {
      // First step: find the subroutines. This step determines, for each basic block, to which
      // subroutine(s) it belongs. Start with the main "subroutine":
      short numSubroutines = 1;
      firstBasicBlock.markSubroutine(numSubroutines);
      // Then, mark the subroutines called by the main subroutine, then the subroutines called by
      // those called by the main subroutine, etc.
      for (short currentSubroutine = 1; currentSubroutine <= numSubroutines; ++currentSubroutine) {
        Label basicBlock = firstBasicBlock;
        while (basicBlock != null) {
          if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0
              && basicBlock.subroutineId == currentSubroutine) {
            Label jsrTarget = basicBlock.outgoingEdges.nextEdge.successor;
            if (jsrTarget.subroutineId == 0) {
              // If this subroutine has not been marked yet, find its basic blocks.
              jsrTarget.markSubroutine(++numSubroutines);
            }
          }
          basicBlock = basicBlock.nextBasicBlock;
        }
      }
      // Second step: find the successors in the control flow graph of each subroutine basic block
      // 'r' ending with a RET instruction. These successors are the virtual successors of the basic
      // blocks ending with JSR instructions (see {@link #visitJumpInsn)} that can reach 'r'.
      Label basicBlock = firstBasicBlock;
      while (basicBlock != null) {
        if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {
          // By construction, jsr targets are stored in the second outgoing edge of basic blocks
          // that ends with a jsr instruction (see {@link #FLAG_SUBROUTINE_CALLER}).
          Label subroutine = basicBlock.outgoingEdges.nextEdge.successor;
          subroutine.addSubroutineRetSuccessors(basicBlock);
        }
        basicBlock = basicBlock.nextBasicBlock;
      }
    }

    // Data flow algorithm: put the first basic block in a list of blocks to process (i.e. blocks
    // whose input stack size has changed) and, while there are blocks to process, remove one
    // from the list, update the input stack size of its successor blocks in the control flow
    // graph, and add these blocks to the list of blocks to process (if not already done).
    Label listOfBlocksToProcess = firstBasicBlock;
    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;
    int maxStackSize = maxStack;
    while (listOfBlocksToProcess != Label.EMPTY_LIST) {
      // Remove a basic block from the list of blocks to process. Note that we don't reset
      // basicBlock.nextListElement to null on purpose, to make sure we don't reprocess already
      // processed basic blocks.
      Label basicBlock = listOfBlocksToProcess;
      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;
      // Compute the (absolute) input stack size and maximum stack size of this block.
      int inputStackTop = basicBlock.inputStackSize;
      int maxBlockStackSize = inputStackTop + basicBlock.outputStackMax;
      // Update the absolute maximum stack size of the method.
      if (maxBlockStackSize > maxStackSize) {
        maxStackSize = maxBlockStackSize;
      }
      // Update the input stack size of the successor blocks of basicBlock in the control flow
      // graph, and add these blocks to the list of blocks to process, if not already done.
      Edge outgoingEdge = basicBlock.outgoingEdges;
      if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {
        // Ignore the first outgoing edge of the basic blocks ending with a jsr: these are virtual
        // edges which lead to the instruction just after the jsr, and do not correspond to a
        // possible execution path (see {@link #visitJumpInsn} and
        // {@link Label#FLAG_SUBROUTINE_CALLER}).
        outgoingEdge = outgoingEdge.nextEdge;
      }
      while (outgoingEdge != null) {
        Label successorBlock = outgoingEdge.successor;
        if (successorBlock.nextListElement == null) {
          successorBlock.inputStackSize =
              (short) (outgoingEdge.info == Edge.EXCEPTION ? 1 : inputStackTop + outgoingEdge.info);
          successorBlock.nextListElement = listOfBlocksToProcess;
          listOfBlocksToProcess = successorBlock;
        }
        outgoingEdge = outgoingEdge.nextEdge;
      }
    }
    this.maxStack = maxStackSize;
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods: control flow analysis algorithm
  // -----------------------------------------------------------------------------------------------

  /**
   * Adds a successor to {@link #currentBasicBlock} in the control flow graph.
   *
   * @param info information about the control flow edge to be added.
   * @param successor the successor block to be added to the current basic block.
   */
  private void addSuccessorToCurrentBasicBlock(final int info, final Label successor) {
    currentBasicBlock.outgoingEdges = new Edge(info, successor, currentBasicBlock.outgoingEdges);
  }

  /**
   * Ends the current basic block. This method must be used in the case where the current basic
   * block does not have any successor.
   *
   * <p>WARNING: this method must be called after the currently visited instruction has been put in
   * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic
   * block after the current instruction).
   */
  private void endCurrentBasicBlockWithNoSuccessor() {
    if (compute == COMPUTE_ALL_FRAMES) {
      Label nextBasicBlock = new Label();
      nextBasicBlock.frame = new Frame(nextBasicBlock);
      nextBasicBlock.resolve(code.data, stackMapTableEntries, code.length);
      lastBasicBlock.nextBasicBlock = nextBasicBlock;
      lastBasicBlock = nextBasicBlock;
      currentBasicBlock = null;
    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {
      currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;
      currentBasicBlock = null;
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods: stack map frames
  // -----------------------------------------------------------------------------------------------

  /**
   * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.
   *
   * @param offset the bytecode offset of the instruction to which the frame corresponds.
   * @param numLocal the number of local variables in the frame.
   * @param numStack the number of stack elements in the frame.
   * @return the index of the next element to be written in this frame.
   */
  int visitFrameStart(final int offset, final int numLocal, final int numStack) {
    int frameLength = 3 + numLocal + numStack;
    if (currentFrame == null || currentFrame.length < frameLength) {
      currentFrame = new int[frameLength];
    }
    currentFrame[0] = offset;
    currentFrame[1] = numLocal;
    currentFrame[2] = numStack;
    return 3;
  }

  /**
   * Sets an abstract type in {@link #currentFrame}.
   *
   * @param frameIndex the index of the element to be set in {@link #currentFrame}.
   * @param abstractType an abstract type.
   */
  void visitAbstractType(final int frameIndex, final int abstractType) {
    currentFrame[frameIndex] = abstractType;
  }

  /**
   * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by
   * updating the StackMapTable number_of_entries (except if the current frame is the first one,
   * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.
   */
  void visitFrameEnd() {
    if (previousFrame != null) {
      if (stackMapTableEntries == null) {
        stackMapTableEntries = new ByteVector();
      }
      putFrame();
      ++stackMapTableNumberOfEntries;
    }
    previousFrame = currentFrame;
    currentFrame = null;
  }

  /** Compresses and writes {@link #currentFrame} in a new StackMapTable entry. */
  private void putFrame() {
    final int numLocal = currentFrame[1];
    final int numStack = currentFrame[2];
    if (symbolTable.getMajorVersion() < Opcodes.V1_6) {
      // Generate a StackMap attribute entry, which are always uncompressed.
      stackMapTableEntries.putShort(currentFrame[0]).putShort(numLocal);
      putAbstractTypes(3, 3 + numLocal);
      stackMapTableEntries.putShort(numStack);
      putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);
      return;
    }
    final int offsetDelta =
        stackMapTableNumberOfEntries == 0
            ? currentFrame[0]
            : currentFrame[0] - previousFrame[0] - 1;
    final int previousNumlocal = previousFrame[1];
    final int numLocalDelta = numLocal - previousNumlocal;
    int type = Frame.FULL_FRAME;
    if (numStack == 0) {
      switch (numLocalDelta) {
        case -3:
        case -2:
        case -1:
          type = Frame.CHOP_FRAME;
          break;
        case 0:
          type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;
          break;
        case 1:
        case 2:
        case 3:
          type = Frame.APPEND_FRAME;
          break;
        default:
          // Keep the FULL_FRAME type.
          break;
      }
    } else if (numLocalDelta == 0 && numStack == 1) {
      type =
          offsetDelta < 63
              ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME
              : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
    }
    if (type != Frame.FULL_FRAME) {
      // Verify if locals are the same as in the previous frame.
      int frameIndex = 3;
      for (int i = 0; i < previousNumlocal && i < numLocal; i++) {
        if (currentFrame[frameIndex] != previousFrame[frameIndex]) {
          type = Frame.FULL_FRAME;
          break;
        }
        frameIndex++;
      }
    }
    switch (type) {
      case Frame.SAME_FRAME:
        stackMapTableEntries.putByte(offsetDelta);
        break;
      case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:
        stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);
        putAbstractTypes(3 + numLocal, 4 + numLocal);
        break;
      case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
        stackMapTableEntries
            .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
            .putShort(offsetDelta);
        putAbstractTypes(3 + numLocal, 4 + numLocal);
        break;
      case Frame.SAME_FRAME_EXTENDED:
        stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);
        break;
      case Frame.CHOP_FRAME:
        stackMapTableEntries
            .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)
            .putShort(offsetDelta);
        break;
      case Frame.APPEND_FRAME:
        stackMapTableEntries
            .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)
            .putShort(offsetDelta);
        putAbstractTypes(3 + previousNumlocal, 3 + numLocal);
        break;
      case Frame.FULL_FRAME:
      default:
        stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);
        putAbstractTypes(3, 3 + numLocal);
        stackMapTableEntries.putShort(numStack);
        putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);
        break;
    }
  }

  /**
   * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the
   * JVMS verification_type_info format used in StackMapTable attributes.
   *
   * @param start index of the first type in {@link #currentFrame} to write.
   * @param end index of last type in {@link #currentFrame} to write (exclusive).
   */
  private void putAbstractTypes(final int start, final int end) {
    for (int i = start; i < end; ++i) {
      Frame.putAbstractType(symbolTable, currentFrame[i], stackMapTableEntries);
    }
  }

  /**
   * Puts the given public API frame element type in {@link #stackMapTableEntries} , using the JVMS
   * verification_type_info format used in StackMapTable attributes.
   *
   * @param type a frame element type described using the same format as in {@link
   *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link
   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or
   *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating
   *     a NEW instruction (for uninitialized types).
   */
  private void putFrameType(final Object type) {
    if (type instanceof Integer) {
      stackMapTableEntries.putByte(((Integer) type).intValue());
    } else if (type instanceof String) {
      stackMapTableEntries
          .putByte(Frame.ITEM_OBJECT)
          .putShort(symbolTable.addConstantClass((String) type).index);
    } else {
      stackMapTableEntries.putByte(Frame.ITEM_UNINITIALIZED);
      ((Label) type).put(stackMapTableEntries);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns whether the attributes of this method can be copied from the attributes of the given
   * method (assuming there is no method visitor between the given ClassReader and this
   * MethodWriter). This method should only be called just after this MethodWriter has been created,
   * and before any content is visited. It returns true if the attributes corresponding to the
   * constructor arguments (at most a Signature, an Exception, a Deprecated and a Synthetic
   * attribute) are the same as the corresponding attributes in the given method.
   *
   * @param source the source ClassReader from which the attributes of this method might be copied.
   * @param hasSyntheticAttribute whether the method_info JVMS structure from which the attributes
   *     of this method might be copied contains a Synthetic attribute.
   * @param hasDeprecatedAttribute whether the method_info JVMS structure from which the attributes
   *     of this method might be copied contains a Deprecated attribute.
   * @param descriptorIndex the descriptor_index field of the method_info JVMS structure from which
   *     the attributes of this method might be copied.
   * @param signatureIndex the constant pool index contained in the Signature attribute of the
   *     method_info JVMS structure from which the attributes of this method might be copied, or 0.
   * @param exceptionsOffset the offset in 'source.b' of the Exceptions attribute of the method_info
   *     JVMS structure from which the attributes of this method might be copied, or 0.
   * @return whether the attributes of this method can be copied from the attributes of the
   *     method_info JVMS structure in 'source.b', between 'methodInfoOffset' and 'methodInfoOffset'
   *     + 'methodInfoLength'.
   */
  boolean canCopyMethodAttributes(
      final ClassReader source,
      final boolean hasSyntheticAttribute,
      final boolean hasDeprecatedAttribute,
      final int descriptorIndex,
      final int signatureIndex,
      final int exceptionsOffset) {
    // If the method descriptor has changed, with more locals than the max_locals field of the
    // original Code attribute, if any, then the original method attributes can't be copied. A
    // conservative check on the descriptor changes alone ensures this (being more precise is not
    // worth the additional complexity, because these cases should be rare -- if a transform changes
    // a method descriptor, most of the time it needs to change the method's code too).
    if (source != symbolTable.getSource()
        || descriptorIndex != this.descriptorIndex
        || signatureIndex != this.signatureIndex
        || hasDeprecatedAttribute != ((accessFlags & Opcodes.ACC_DEPRECATED) != 0)) {
      return false;
    }
    boolean needSyntheticAttribute =
        symbolTable.getMajorVersion() < Opcodes.V1_5 && (accessFlags & Opcodes.ACC_SYNTHETIC) != 0;
    if (hasSyntheticAttribute != needSyntheticAttribute) {
      return false;
    }
    if (exceptionsOffset == 0) {
      if (numberOfExceptions != 0) {
        return false;
      }
    } else if (source.readUnsignedShort(exceptionsOffset) == numberOfExceptions) {
      int currentExceptionOffset = exceptionsOffset + 2;
      for (int i = 0; i < numberOfExceptions; ++i) {
        if (source.readUnsignedShort(currentExceptionOffset) != exceptionIndexTable[i]) {
          return false;
        }
        currentExceptionOffset += 2;
      }
    }
    return true;
  }

  /**
   * Sets the source from which the attributes of this method will be copied.
   *
   * @param methodInfoOffset the offset in 'symbolTable.getSource()' of the method_info JVMS
   *     structure from which the attributes of this method will be copied.
   * @param methodInfoLength the length in 'symbolTable.getSource()' of the method_info JVMS
   *     structure from which the attributes of this method will be copied.
   */
  void setMethodAttributesSource(final int methodInfoOffset, final int methodInfoLength) {
    // Don't copy the attributes yet, instead store their location in the source class reader so
    // they can be copied later, in {@link #putMethodInfo}. Note that we skip the 6 header bytes
    // of the method_info JVMS structure.
    this.sourceOffset = methodInfoOffset + 6;
    this.sourceLength = methodInfoLength - 6;
  }

  /**
   * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the
   * names of the attributes of this method in the constant pool.
   *
   * @return the size in bytes of the method_info JVMS structure.
   */
  int computeMethodInfoSize() {
    // If this method_info must be copied from an existing one, the size computation is trivial.
    if (sourceOffset != 0) {
      // sourceLength excludes the first 6 bytes for access_flags, name_index and descriptor_index.
      return 6 + sourceLength;
    }
    // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.
    int size = 8;
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    if (code.length > 0) {
      if (code.length > 65535) {
        throw new MethodTooLargeException(
            symbolTable.getClassName(), name, descriptor, code.length);
      }
      symbolTable.addConstantUtf8(Constants.CODE);
      // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,
      // max_locals, code_length and attributes_count, plus the bytecode and the exception table.
      size += 16 + code.length + Handler.getExceptionTableSize(firstHandler);
      if (stackMapTableEntries != null) {
        boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;
        symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : "StackMap");
        // 6 header bytes and 2 bytes for number_of_entries.
        size += 8 + stackMapTableEntries.length;
      }
      if (lineNumberTable != null) {
        symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE);
        // 6 header bytes and 2 bytes for line_number_table_length.
        size += 8 + lineNumberTable.length;
      }
      if (localVariableTable != null) {
        symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE);
        // 6 header bytes and 2 bytes for local_variable_table_length.
        size += 8 + localVariableTable.length;
      }
      if (localVariableTypeTable != null) {
        symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE);
        // 6 header bytes and 2 bytes for local_variable_type_table_length.
        size += 8 + localVariableTypeTable.length;
      }
      if (lastCodeRuntimeVisibleTypeAnnotation != null) {
        size +=
            lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(
                Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);
      }
      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {
        size +=
            lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(
                Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
      }
      if (firstCodeAttribute != null) {
        size +=
            firstCodeAttribute.computeAttributesSize(
                symbolTable, code.data, code.length, maxStack, maxLocals);
      }
    }
    if (numberOfExceptions > 0) {
      symbolTable.addConstantUtf8(Constants.EXCEPTIONS);
      size += 8 + 2 * numberOfExceptions;
    }
    size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);
    size +=
        AnnotationWriter.computeAnnotationsSize(
            lastRuntimeVisibleAnnotation,
            lastRuntimeInvisibleAnnotation,
            lastRuntimeVisibleTypeAnnotation,
            lastRuntimeInvisibleTypeAnnotation);
    if (lastRuntimeVisibleParameterAnnotations != null) {
      size +=
          AnnotationWriter.computeParameterAnnotationsSize(
              Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS,
              lastRuntimeVisibleParameterAnnotations,
              visibleAnnotableParameterCount == 0
                  ? lastRuntimeVisibleParameterAnnotations.length
                  : visibleAnnotableParameterCount);
    }
    if (lastRuntimeInvisibleParameterAnnotations != null) {
      size +=
          AnnotationWriter.computeParameterAnnotationsSize(
              Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS,
              lastRuntimeInvisibleParameterAnnotations,
              invisibleAnnotableParameterCount == 0
                  ? lastRuntimeInvisibleParameterAnnotations.length
                  : invisibleAnnotableParameterCount);
    }
    if (defaultValue != null) {
      symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT);
      size += 6 + defaultValue.length;
    }
    if (parameters != null) {
      symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS);
      // 6 header bytes and 1 byte for parameters_count.
      size += 7 + parameters.length;
    }
    if (firstAttribute != null) {
      size += firstAttribute.computeAttributesSize(symbolTable);
    }
    return size;
  }

  /**
   * Puts the content of the method_info JVMS structure generated by this MethodWriter into the
   * given ByteVector.
   *
   * @param output where the method_info structure must be put.
   */
  void putMethodInfo(final ByteVector output) {
    boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;
    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;
    output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);
    // If this method_info must be copied from an existing one, copy it now and return early.
    if (sourceOffset != 0) {
      output.putByteArray(symbolTable.getSource().classFileBuffer, sourceOffset, sourceLength);
      return;
    }
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    int attributeCount = 0;
    if (code.length > 0) {
      ++attributeCount;
    }
    if (numberOfExceptions > 0) {
      ++attributeCount;
    }
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {
      ++attributeCount;
    }
    if (signatureIndex != 0) {
      ++attributeCount;
    }
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      ++attributeCount;
    }
    if (lastRuntimeVisibleAnnotation != null) {
      ++attributeCount;
    }
    if (lastRuntimeInvisibleAnnotation != null) {
      ++attributeCount;
    }
    if (lastRuntimeVisibleParameterAnnotations != null) {
      ++attributeCount;
    }
    if (lastRuntimeInvisibleParameterAnnotations != null) {
      ++attributeCount;
    }
    if (lastRuntimeVisibleTypeAnnotation != null) {
      ++attributeCount;
    }
    if (lastRuntimeInvisibleTypeAnnotation != null) {
      ++attributeCount;
    }
    if (defaultValue != null) {
      ++attributeCount;
    }
    if (parameters != null) {
      ++attributeCount;
    }
    if (firstAttribute != null) {
      attributeCount += firstAttribute.getAttributeCount();
    }
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    output.putShort(attributeCount);
    if (code.length > 0) {
      // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and
      // attributes_count, plus the bytecode and the exception table.
      int size = 10 + code.length + Handler.getExceptionTableSize(firstHandler);
      int codeAttributeCount = 0;
      if (stackMapTableEntries != null) {
        // 6 header bytes and 2 bytes for number_of_entries.
        size += 8 + stackMapTableEntries.length;
        ++codeAttributeCount;
      }
      if (lineNumberTable != null) {
        // 6 header bytes and 2 bytes for line_number_table_length.
        size += 8 + lineNumberTable.length;
        ++codeAttributeCount;
      }
      if (localVariableTable != null) {
        // 6 header bytes and 2 bytes for local_variable_table_length.
        size += 8 + localVariableTable.length;
        ++codeAttributeCount;
      }
      if (localVariableTypeTable != null) {
        // 6 header bytes and 2 bytes for local_variable_type_table_length.
        size += 8 + localVariableTypeTable.length;
        ++codeAttributeCount;
      }
      if (lastCodeRuntimeVisibleTypeAnnotation != null) {
        size +=
            lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(
                Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);
        ++codeAttributeCount;
      }
      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {
        size +=
            lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(
                Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);
        ++codeAttributeCount;
      }
      if (firstCodeAttribute != null) {
        size +=
            firstCodeAttribute.computeAttributesSize(
                symbolTable, code.data, code.length, maxStack, maxLocals);
        codeAttributeCount += firstCodeAttribute.getAttributeCount();
      }
      output
          .putShort(symbolTable.addConstantUtf8(Constants.CODE))
          .putInt(size)
          .putShort(maxStack)
          .putShort(maxLocals)
          .putInt(code.length)
          .putByteArray(code.data, 0, code.length);
      Handler.putExceptionTable(firstHandler, output);
      output.putShort(codeAttributeCount);
      if (stackMapTableEntries != null) {
        boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;
        output
            .putShort(
                symbolTable.addConstantUtf8(
                    useStackMapTable ? Constants.STACK_MAP_TABLE : "StackMap"))
            .putInt(2 + stackMapTableEntries.length)
            .putShort(stackMapTableNumberOfEntries)
            .putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);
      }
      if (lineNumberTable != null) {
        output
            .putShort(symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE))
            .putInt(2 + lineNumberTable.length)
            .putShort(lineNumberTableLength)
            .putByteArray(lineNumberTable.data, 0, lineNumberTable.length);
      }
      if (localVariableTable != null) {
        output
            .putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE))
            .putInt(2 + localVariableTable.length)
            .putShort(localVariableTableLength)
            .putByteArray(localVariableTable.data, 0, localVariableTable.length);
      }
      if (localVariableTypeTable != null) {
        output
            .putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE))
            .putInt(2 + localVariableTypeTable.length)
            .putShort(localVariableTypeTableLength)
            .putByteArray(localVariableTypeTable.data, 0, localVariableTypeTable.length);
      }
      if (lastCodeRuntimeVisibleTypeAnnotation != null) {
        lastCodeRuntimeVisibleTypeAnnotation.putAnnotations(
            symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);
      }
      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {
        lastCodeRuntimeInvisibleTypeAnnotation.putAnnotations(
            symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);
      }
      if (firstCodeAttribute != null) {
        firstCodeAttribute.putAttributes(
            symbolTable, code.data, code.length, maxStack, maxLocals, output);
      }
    }
    if (numberOfExceptions > 0) {
      output
          .putShort(symbolTable.addConstantUtf8(Constants.EXCEPTIONS))
          .putInt(2 + 2 * numberOfExceptions)
          .putShort(numberOfExceptions);
      for (int exceptionIndex : exceptionIndexTable) {
        output.putShort(exceptionIndex);
      }
    }
    Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);
    AnnotationWriter.putAnnotations(
        symbolTable,
        lastRuntimeVisibleAnnotation,
        lastRuntimeInvisibleAnnotation,
        lastRuntimeVisibleTypeAnnotation,
        lastRuntimeInvisibleTypeAnnotation,
        output);
    if (lastRuntimeVisibleParameterAnnotations != null) {
      AnnotationWriter.putParameterAnnotations(
          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS),
          lastRuntimeVisibleParameterAnnotations,
          visibleAnnotableParameterCount == 0
              ? lastRuntimeVisibleParameterAnnotations.length
              : visibleAnnotableParameterCount,
          output);
    }
    if (lastRuntimeInvisibleParameterAnnotations != null) {
      AnnotationWriter.putParameterAnnotations(
          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS),
          lastRuntimeInvisibleParameterAnnotations,
          invisibleAnnotableParameterCount == 0
              ? lastRuntimeInvisibleParameterAnnotations.length
              : invisibleAnnotableParameterCount,
          output);
    }
    if (defaultValue != null) {
      output
          .putShort(symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT))
          .putInt(defaultValue.length)
          .putByteArray(defaultValue.data, 0, defaultValue.length);
    }
    if (parameters != null) {
      output
          .putShort(symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS))
          .putInt(1 + parameters.length)
          .putByte(parametersCount)
          .putByteArray(parameters.data, 0, parameters.length);
    }
    if (firstAttribute != null) {
      firstAttribute.putAttributes(symbolTable, output);
    }
  }

  /**
   * Collects the attributes of this method into the given set of attribute prototypes.
   *
   * @param attributePrototypes a set of attribute prototypes.
   */
  final void collectAttributePrototypes(final Attribute.Set attributePrototypes) {
    attributePrototypes.addAttributes(firstAttribute);
    attributePrototypes.addAttributes(firstCodeAttribute);
  }
}

package org.objectweb.asm;

final class RecordComponentWriter extends RecordComponentVisitor {
  /** Where the constants used in this RecordComponentWriter must be stored. */
  private final SymbolTable symbolTable;

  // Note: fields are ordered as in the record_component_info structure, and those related to
  // attributes are ordered as in Section 4.7 of the JVMS.

  /** The name_index field of the Record attribute. */
  private final int nameIndex;

  /** The descriptor_index field of the Record attribute. */
  private final int descriptorIndex;

  /**
   * The signature_index field of the Signature attribute of this record component, or 0 if there is
   * no Signature attribute.
   */
  private int signatureIndex;

  /**
   * The last runtime visible annotation of this record component. The previous ones can be accessed
   * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeVisibleAnnotation;

  /**
   * The last runtime invisible annotation of this record component. The previous ones can be
   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeInvisibleAnnotation;

  /**
   * The last runtime visible type annotation of this record component. The previous ones can be
   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeVisibleTypeAnnotation;

  /**
   * The last runtime invisible type annotation of this record component. The previous ones can be
   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;

  /**
   * The first non standard attribute of this record component. The next ones can be accessed with
   * the {@link Attribute#nextAttribute} field. May be {@literal null}.
   *
   * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.
   * firstAttribute is actually the last attribute visited in {@link #visitAttribute(Attribute)}.
   * The {@link #putRecordComponentInfo(ByteVector)} method writes the attributes in the order
   * defined by this list, i.e. in the reverse order specified by the user.
   */
  private Attribute firstAttribute;

  /**
   * Constructs a new {@link RecordComponentWriter}.
   *
   * @param symbolTable where the constants used in this RecordComponentWriter must be stored.
   * @param name the record component name.
   * @param descriptor the record component descriptor (see {@link Type}).
   * @param signature the record component signature. May be {@literal null}.
   */
  RecordComponentWriter(
      final SymbolTable symbolTable,
      final String name,
      final String descriptor,
      final String signature) {
    super(/* latest api = */ Opcodes.ASM9);
    this.symbolTable = symbolTable;
    this.nameIndex = symbolTable.addConstantUtf8(name);
    this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);
    if (signature != null) {
      this.signatureIndex = symbolTable.addConstantUtf8(signature);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the FieldVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (visible) {
      return lastRuntimeVisibleAnnotation =
          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);
    } else {
      return lastRuntimeInvisibleAnnotation =
          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);
    }
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (visible) {
      return lastRuntimeVisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);
    } else {
      return lastRuntimeInvisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);
    }
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    // Store the attributes in the <i>reverse</i> order of their visit by this method.
    attribute.nextAttribute = firstAttribute;
    firstAttribute = attribute;
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the size of the record component JVMS structure generated by this
   * RecordComponentWriter. Also adds the names of the attributes of this record component in the
   * constant pool.
   *
   * @return the size in bytes of the record_component_info of the Record attribute.
   */
  int computeRecordComponentInfoSize() {
    // name_index, descriptor_index and attributes_count fields use 6 bytes.
    int size = 6;
    size += Attribute.computeAttributesSize(symbolTable, 0, signatureIndex);
    size +=
        AnnotationWriter.computeAnnotationsSize(
            lastRuntimeVisibleAnnotation,
            lastRuntimeInvisibleAnnotation,
            lastRuntimeVisibleTypeAnnotation,
            lastRuntimeInvisibleTypeAnnotation);
    if (firstAttribute != null) {
      size += firstAttribute.computeAttributesSize(symbolTable);
    }
    return size;
  }

  /**
   * Puts the content of the record component generated by this RecordComponentWriter into the given
   * ByteVector.
   *
   * @param output where the record_component_info structure must be put.
   */
  void putRecordComponentInfo(final ByteVector output) {
    output.putShort(nameIndex).putShort(descriptorIndex);
    // Compute and put the attributes_count field.
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    int attributesCount = 0;
    if (signatureIndex != 0) {
      ++attributesCount;
    }
    if (lastRuntimeVisibleAnnotation != null) {
      ++attributesCount;
    }
    if (lastRuntimeInvisibleAnnotation != null) {
      ++attributesCount;
    }
    if (lastRuntimeVisibleTypeAnnotation != null) {
      ++attributesCount;
    }
    if (lastRuntimeInvisibleTypeAnnotation != null) {
      ++attributesCount;
    }
    if (firstAttribute != null) {
      attributesCount += firstAttribute.getAttributeCount();
    }
    output.putShort(attributesCount);
    Attribute.putAttributes(symbolTable, 0, signatureIndex, output);
    AnnotationWriter.putAnnotations(
        symbolTable,
        lastRuntimeVisibleAnnotation,
        lastRuntimeInvisibleAnnotation,
        lastRuntimeVisibleTypeAnnotation,
        lastRuntimeInvisibleTypeAnnotation,
        output);
    if (firstAttribute != null) {
      firstAttribute.putAttributes(symbolTable, output);
    }
  }

  /**
   * Collects the attributes of this record component into the given set of attribute prototypes.
   *
   * @param attributePrototypes a set of attribute prototypes.
   */
  final void collectAttributePrototypes(final Attribute.Set attributePrototypes) {
    attributePrototypes.addAttributes(firstAttribute);
  }
}


package org.objectweb.asm;

/**
 * A reference to a field or a method.
 *
 * @author Remi Forax
 * @author Eric Bruneton
 */
public final class Handle {

  /**
   * The kind of field or method designated by this Handle. Should be {@link Opcodes#H_GETFIELD},
   * {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link
   * Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},
   * {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   */
  private final int tag;

  /** The internal name of the class that owns the field or method designated by this handle. */
  private final @InternalForm String owner;

  /** The name of the field or method designated by this handle. */
  private final String name;

  /** The descriptor of the field or method designated by this handle. */
  private final String descriptor;

  /** Whether the owner is an interface or not. */
  private final boolean isInterface;

  /**
   * Constructs a new field or method handle.
   *
   * @param tag the kind of field or method designated by this Handle. Must be {@link
   *     Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link
   *     Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC},
   *     {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or {@link
   *     Opcodes#H_INVOKEINTERFACE}.
   * @param owner the internal name of the class that owns the field or method designated by this
   *     handle (see {@link Type#getInternalName()}).
   * @param name the name of the field or method designated by this handle.
   * @param descriptor the descriptor of the field or method designated by this handle.
   * @deprecated this constructor has been superseded by {@link #Handle(int, String, String, String,
   *     boolean)}.
   */
  @Deprecated
  public Handle(final int tag, final @InternalForm String owner, final String name, final String descriptor) {
    this(tag, owner, name, descriptor, tag == Opcodes.H_INVOKEINTERFACE);
  }

  /**
   * Constructs a new field or method handle.
   *
   * @param tag the kind of field or method designated by this Handle. Must be {@link
   *     Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link
   *     Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC},
   *     {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or {@link
   *     Opcodes#H_INVOKEINTERFACE}.
   * @param owner the internal name of the class that owns the field or method designated by this
   *     handle (see {@link Type#getInternalName()}).
   * @param name the name of the field or method designated by this handle.
   * @param descriptor the descriptor of the field or method designated by this handle.
   * @param isInterface whether the owner is an interface or not.
   */
  public Handle(
      final int tag,
      final @InternalForm String owner,
      final String name,
      final String descriptor,
      final boolean isInterface) {
    this.tag = tag;
    this.owner = owner;
    this.name = name;
    this.descriptor = descriptor;
    this.isInterface = isInterface;
  }

  /**
   * Returns the kind of field or method designated by this handle.
   *
   * @return {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD},
   *     {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link
   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link
   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.
   */
  public int getTag() {
    return tag;
  }

  /**
   * Returns the internal name of the class that owns the field or method designated by this handle.
   *
   * @return the internal name of the class that owns the field or method designated by this handle
   *     (see {@link Type#getInternalName()}).
   */
  public @InternalForm String getOwner() {
    return owner;
  }

  /**
   * Returns the name of the field or method designated by this handle.
   *
   * @return the name of the field or method designated by this handle.
   */
  public String getName() {
    return name;
  }

  /**
   * Returns the descriptor of the field or method designated by this handle.
   *
   * @return the descriptor of the field or method designated by this handle.
   */
  public String getDesc() {
    return descriptor;
  }

  /**
   * Returns true if the owner of the field or method designated by this handle is an interface.
   *
   * @return true if the owner of the field or method designated by this handle is an interface.
   */
  public boolean isInterface() {
    return isInterface;
  }

  @Override
  public boolean equals(final Object object) {
    if (object == this) {
      return true;
    }
    if (!(object instanceof Handle)) {
      return false;
    }
    Handle handle = (Handle) object;
    return tag == handle.tag
        && isInterface == handle.isInterface
        && owner.equals(handle.owner)
        && name.equals(handle.name)
        && descriptor.equals(handle.descriptor);
  }

  @Override
  public int hashCode() {
    return tag
        + (isInterface ? 64 : 0)
        + owner.hashCode() * name.hashCode() * descriptor.hashCode();
  }

  /**
   * Returns the textual representation of this handle. The textual representation is:
   *
   * <ul>
   *   <li>for a reference to a class: owner "." name descriptor " (" tag ")",
   *   <li>for a reference to an interface: owner "." name descriptor " (" tag " itf)".
   * </ul>
   */
  @Override
  public String toString() {
    return owner + '.' + name + descriptor + " (" + tag + (isInterface ? " itf" : "") + ')';
  }
}

package org.objectweb.asm;

/**
 * A {@link FieldVisitor} that generates a corresponding 'field_info' structure, as defined in the
 * Java Virtual Machine Specification (JVMS).
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.5">JVMS
 *     4.5</a>
 * @author Eric Bruneton
 */
final class FieldWriter extends FieldVisitor {

  /** Where the constants used in this FieldWriter must be stored. */
  private final SymbolTable symbolTable;

  // Note: fields are ordered as in the field_info structure, and those related to attributes are
  // ordered as in Section 4.7 of the JVMS.

  /**
   * The access_flags field of the field_info JVMS structure. This field can contain ASM specific
   * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the
   * ClassFile structure.
   */
  private final int accessFlags;

  /** The name_index field of the field_info JVMS structure. */
  private final int nameIndex;

  /** The descriptor_index field of the field_info JVMS structure. */
  private final int descriptorIndex;

  /**
   * The signature_index field of the Signature attribute of this field_info, or 0 if there is no
   * Signature attribute.
   */
  private int signatureIndex;

  /**
   * The constantvalue_index field of the ConstantValue attribute of this field_info, or 0 if there
   * is no ConstantValue attribute.
   */
  private int constantValueIndex;

  /**
   * The last runtime visible annotation of this field. The previous ones can be accessed with the
   * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeVisibleAnnotation;

  /**
   * The last runtime invisible annotation of this field. The previous ones can be accessed with the
   * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeInvisibleAnnotation;

  /**
   * The last runtime visible type annotation of this field. The previous ones can be accessed with
   * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeVisibleTypeAnnotation;

  /**
   * The last runtime invisible type annotation of this field. The previous ones can be accessed
   * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.
   */
  private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;

  /**
   * The first non standard attribute of this field. The next ones can be accessed with the {@link
   * Attribute#nextAttribute} field. May be {@literal null}.
   *
   * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.
   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link
   * #putFieldInfo} method writes the attributes in the order defined by this list, i.e. in the
   * reverse order specified by the user.
   */
  private Attribute firstAttribute;

  // -----------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link FieldWriter}.
   *
   * @param symbolTable where the constants used in this FieldWriter must be stored.
   * @param access the field's access flags (see {@link Opcodes}).
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link Type}).
   * @param signature the field's signature. May be {@literal null}.
   * @param constantValue the field's constant value. May be {@literal null}.
   */
  FieldWriter(
      final SymbolTable symbolTable,
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object constantValue) {
    super(/* latest api = */ Opcodes.ASM9);
    this.symbolTable = symbolTable;
    this.accessFlags = access;
    this.nameIndex = symbolTable.addConstantUtf8(name);
    this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);
    if (signature != null) {
      this.signatureIndex = symbolTable.addConstantUtf8(signature);
    }
    if (constantValue != null) {
      this.constantValueIndex = symbolTable.addConstant(constantValue).index;
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the FieldVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (visible) {
      return lastRuntimeVisibleAnnotation =
          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);
    } else {
      return lastRuntimeInvisibleAnnotation =
          AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);
    }
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (visible) {
      return lastRuntimeVisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);
    } else {
      return lastRuntimeInvisibleTypeAnnotation =
          AnnotationWriter.create(
              symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);
    }
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    // Store the attributes in the <i>reverse</i> order of their visit by this method.
    attribute.nextAttribute = firstAttribute;
    firstAttribute = attribute;
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the
   * names of the attributes of this field in the constant pool.
   *
   * @return the size in bytes of the field_info JVMS structure.
   */
  int computeFieldInfoSize() {
    // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes.
    int size = 8;
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    if (constantValueIndex != 0) {
      // ConstantValue attributes always use 8 bytes.
      symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE);
      size += 8;
    }
    size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);
    size +=
        AnnotationWriter.computeAnnotationsSize(
            lastRuntimeVisibleAnnotation,
            lastRuntimeInvisibleAnnotation,
            lastRuntimeVisibleTypeAnnotation,
            lastRuntimeInvisibleTypeAnnotation);
    if (firstAttribute != null) {
      size += firstAttribute.computeAttributesSize(symbolTable);
    }
    return size;
  }

  /**
   * Puts the content of the field_info JVMS structure generated by this FieldWriter into the given
   * ByteVector.
   *
   * @param output where the field_info structure must be put.
   */
  void putFieldInfo(final ByteVector output) {
    boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;
    // Put the access_flags, name_index and descriptor_index fields.
    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;
    output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);
    // Compute and put the attributes_count field.
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    int attributesCount = 0;
    if (constantValueIndex != 0) {
      ++attributesCount;
    }
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {
      ++attributesCount;
    }
    if (signatureIndex != 0) {
      ++attributesCount;
    }
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      ++attributesCount;
    }
    if (lastRuntimeVisibleAnnotation != null) {
      ++attributesCount;
    }
    if (lastRuntimeInvisibleAnnotation != null) {
      ++attributesCount;
    }
    if (lastRuntimeVisibleTypeAnnotation != null) {
      ++attributesCount;
    }
    if (lastRuntimeInvisibleTypeAnnotation != null) {
      ++attributesCount;
    }
    if (firstAttribute != null) {
      attributesCount += firstAttribute.getAttributeCount();
    }
    output.putShort(attributesCount);
    // Put the field_info attributes.
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    if (constantValueIndex != 0) {
      output
          .putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE))
          .putInt(2)
          .putShort(constantValueIndex);
    }
    Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);
    AnnotationWriter.putAnnotations(
        symbolTable,
        lastRuntimeVisibleAnnotation,
        lastRuntimeInvisibleAnnotation,
        lastRuntimeVisibleTypeAnnotation,
        lastRuntimeInvisibleTypeAnnotation,
        output);
    if (firstAttribute != null) {
      firstAttribute.putAttributes(symbolTable, output);
    }
  }

  /**
   * Collects the attributes of this field into the given set of attribute prototypes.
   *
   * @param attributePrototypes a set of attribute prototypes.
   */
  final void collectAttributePrototypes(final Attribute.Set attributePrototypes) {
    attributePrototypes.addAttributes(firstAttribute);
  }
}

package org.objectweb.asm.signature;

import org.objectweb.asm.Opcodes;

/**
 * A SignatureVisitor that generates signature literals, as defined in the Java Virtual Machine
 * Specification (JVMS).
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1">JVMS
 *     4.7.9.1</a>
 * @author Thomas Hallgren
 * @author Eric Bruneton
 */
public class SignatureWriter extends SignatureVisitor {

  /** The builder used to construct the visited signature. */
  private final StringBuilder stringBuilder;

  /** Whether the visited signature contains formal type parameters. */
  private boolean hasFormals;

  /** Whether the visited signature contains method parameter types. */
  private boolean hasParameters;

  /**
   * The stack used to keep track of class types that have arguments. Each element of this stack is
   * a boolean encoded in one bit. The top of the stack is the least significant bit. The bottom of
   * the stack is a sentinel element always equal to 1 (used to detect when the stack is full).
   * Pushing false = {@code <<= 1}, pushing true = {@code ( <<= 1) | 1}, popping = {@code >>>= 1}.
   *
   * <p>Class type arguments must be surrounded with '&lt;' and '&gt;' and, because
   *
   * <ol>
   *   <li>class types can be nested (because type arguments can themselves be class types),
   *   <li>SignatureWriter always returns 'this' in each visit* method (to avoid allocating new
   *       SignatureWriter instances),
   * </ol>
   *
   * <p>we need a stack to properly balance these angle brackets. A new element is pushed on this
   * stack for each new visited type, and popped when the visit of this type ends (either in
   * visitEnd, or because visitInnerClassType is called).
   */
  private int argumentStack = 1;

  /** Constructs a new {@link SignatureWriter}. */
  public SignatureWriter() {
    this(new StringBuilder());
  }

  private SignatureWriter(final StringBuilder stringBuilder) {
    super(/* latest api =*/ Opcodes.ASM9);
    this.stringBuilder = stringBuilder;
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the SignatureVisitor interface
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visitFormalTypeParameter(final String name) {
    if (!hasFormals) {
      hasFormals = true;
      stringBuilder.append('<');
    }
    stringBuilder.append(name);
    stringBuilder.append(':');
  }

  @Override
  public SignatureVisitor visitClassBound() {
    return this;
  }

  @Override
  public SignatureVisitor visitInterfaceBound() {
    stringBuilder.append(':');
    return this;
  }

  @Override
  public SignatureVisitor visitSuperclass() {
    endFormals();
    return this;
  }

  @Override
  public SignatureVisitor visitInterface() {
    return this;
  }

  @Override
  public SignatureVisitor visitParameterType() {
    endFormals();
    if (!hasParameters) {
      hasParameters = true;
      stringBuilder.append('(');
    }
    return this;
  }

  @Override
  public SignatureVisitor visitReturnType() {
    endFormals();
    if (!hasParameters) {
      stringBuilder.append('(');
    }
    stringBuilder.append(')');
    return this;
  }

  @Override
  public SignatureVisitor visitExceptionType() {
    stringBuilder.append('^');
    return this;
  }

  @Override
  public void visitBaseType(final char descriptor) {
    stringBuilder.append(descriptor);
  }

  @Override
  public void visitTypeVariable(final String name) {
    stringBuilder.append('T');
    stringBuilder.append(name);
    stringBuilder.append(';');
  }

  @Override
  public SignatureVisitor visitArrayType() {
    stringBuilder.append('[');
    return this;
  }

  @Override
  public void visitClassType(final String name) {
    stringBuilder.append('L');
    stringBuilder.append(name);
    // Pushes 'false' on the stack, meaning that this type does not have type arguments (as far as
    // we can tell at this point).
    argumentStack <<= 1;
  }

  @Override
  public void visitInnerClassType(final String name) {
    endArguments();
    stringBuilder.append('.');
    stringBuilder.append(name);
    // Pushes 'false' on the stack, meaning that this type does not have type arguments (as far as
    // we can tell at this point).
    argumentStack <<= 1;
  }

  @Override
  public void visitTypeArgument() {
    // If the top of the stack is 'false', this means we are visiting the first type argument of the
    // currently visited type. We therefore need to append a '<', and to replace the top stack
    // element with 'true' (meaning that the current type does have type arguments).
    if ((argumentStack & 1) == 0) {
      argumentStack |= 1;
      stringBuilder.append('<');
    }
    stringBuilder.append('*');
  }

  @Override
  public SignatureVisitor visitTypeArgument(final char wildcard) {
    // If the top of the stack is 'false', this means we are visiting the first type argument of the
    // currently visited type. We therefore need to append a '<', and to replace the top stack
    // element with 'true' (meaning that the current type does have type arguments).
    if ((argumentStack & 1) == 0) {
      argumentStack |= 1;
      stringBuilder.append('<');
    }
    if (wildcard != '=') {
      stringBuilder.append(wildcard);
    }
    // If the stack is full, start a nested one by returning a new SignatureWriter.
    return (argumentStack & (1 << 31)) == 0 ? this : new SignatureWriter(stringBuilder);
  }

  @Override
  public void visitEnd() {
    endArguments();
    stringBuilder.append(';');
  }

  /**
   * Returns the signature that was built by this signature writer.
   *
   * @return the signature that was built by this signature writer.
   */
  @Override
  public String toString() {
    return stringBuilder.toString();
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /** Ends the formal type parameters section of the signature. */
  private void endFormals() {
    if (hasFormals) {
      hasFormals = false;
      stringBuilder.append('>');
    }
  }

  /** Ends the type arguments of a class or inner class type. */
  private void endArguments() {
    // If the top of the stack is 'true', this means that some type arguments have been visited for
    // the type whose visit is now ending. We therefore need to append a '>', and to pop one element
    // from the stack.
    if ((argumentStack & 1) == 1) {
      stringBuilder.append('>');
    }
    argumentStack >>>= 1;
  }
}
// ASM: a very small and fast Java bytecode manipulation framework
// Copyright (c) 2000-2011 INRIA, France Telecom
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
// THE POSSIBILITY OF SUCH DAMAGE.

package org.objectweb.asm.signature;

import org.objectweb.asm.Opcodes;

/**
 * A visitor to visit a generic signature. The methods of this interface must be called in one of
 * the three following orders (the last one is the only valid order for a {@link SignatureVisitor}
 * that is returned by a method of this interface):
 *
 * <ul>
 *   <li><i>ClassSignature</i> = ( {@code visitFormalTypeParameter} {@code visitClassBound}? {@code
 *       visitInterfaceBound}* )* ({@code visitSuperclass} {@code visitInterface}* )
 *   <li><i>MethodSignature</i> = ( {@code visitFormalTypeParameter} {@code visitClassBound}? {@code
 *       visitInterfaceBound}* )* ({@code visitParameterType}* {@code visitReturnType} {@code
 *       visitExceptionType}* )
 *   <li><i>TypeSignature</i> = {@code visitBaseType} | {@code visitTypeVariable} | {@code
 *       visitArrayType} | ( {@code visitClassType} {@code visitTypeArgument}* ( {@code
 *       visitInnerClassType} {@code visitTypeArgument}* )* {@code visitEnd} ) )
 * </ul>
 *
 * @author Thomas Hallgren
 * @author Eric Bruneton
 */
public abstract class SignatureVisitor {

  /** Wildcard for an "extends" type argument. */
  public static final char EXTENDS = '+';

  /** Wildcard for a "super" type argument. */
  public static final char SUPER = '-';

  /** Wildcard for a normal type argument. */
  public static final char INSTANCEOF = '=';

  /**
   * The ASM API version implemented by this visitor. The value of this field must be one of the
   * {@code ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected final int api;

  /**
   * Constructs a new {@link SignatureVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected SignatureVisitor(final int api) {
    if (api != Opcodes.ASM9
        && api != Opcodes.ASM8
        && api != Opcodes.ASM7
        && api != Opcodes.ASM6
        && api != Opcodes.ASM5
        && api != Opcodes.ASM4
        && api != Opcodes.ASM10_EXPERIMENTAL) {
      throw new IllegalArgumentException("Unsupported api " + api);
    }
    this.api = api;
  }

  /**
   * Visits a formal type parameter.
   *
   * @param name the name of the formal parameter.
   */
  public void visitFormalTypeParameter(final String name) {}

  /**
   * Visits the class bound of the last visited formal type parameter.
   *
   * @return a non null visitor to visit the signature of the class bound.
   */
  public SignatureVisitor visitClassBound() {
    return this;
  }

  /**
   * Visits an interface bound of the last visited formal type parameter.
   *
   * @return a non null visitor to visit the signature of the interface bound.
   */
  public SignatureVisitor visitInterfaceBound() {
    return this;
  }

  /**
   * Visits the type of the super class.
   *
   * @return a non null visitor to visit the signature of the super class type.
   */
  public SignatureVisitor visitSuperclass() {
    return this;
  }

  /**
   * Visits the type of an interface implemented by the class.
   *
   * @return a non null visitor to visit the signature of the interface type.
   */
  public SignatureVisitor visitInterface() {
    return this;
  }

  /**
   * Visits the type of a method parameter.
   *
   * @return a non null visitor to visit the signature of the parameter type.
   */
  public SignatureVisitor visitParameterType() {
    return this;
  }

  /**
   * Visits the return type of the method.
   *
   * @return a non null visitor to visit the signature of the return type.
   */
  public SignatureVisitor visitReturnType() {
    return this;
  }

  /**
   * Visits the type of a method exception.
   *
   * @return a non null visitor to visit the signature of the exception type.
   */
  public SignatureVisitor visitExceptionType() {
    return this;
  }

  /**
   * Visits a signature corresponding to a primitive type.
   *
   * @param descriptor the descriptor of the primitive type, or 'V' for {@code void} .
   */
  public void visitBaseType(final char descriptor) {}

  /**
   * Visits a signature corresponding to a type variable.
   *
   * @param name the name of the type variable.
   */
  public void visitTypeVariable(final String name) {}

  /**
   * Visits a signature corresponding to an array type.
   *
   * @return a non null visitor to visit the signature of the array element type.
   */
  public SignatureVisitor visitArrayType() {
    return this;
  }

  /**
   * Starts the visit of a signature corresponding to a class or interface type.
   *
   * @param name the internal name of the class or interface (see {@link
   *     org.objectweb.asm.Type#getInternalName()}).
   */
  public void visitClassType(final @InternalForm String name) {}

  /**
   * Visits an inner class.
   *
   * @param name the local name of the inner class in its enclosing class.
   */
  public void visitInnerClassType(final String name) {}

  /** Visits an unbounded type argument of the last visited class or inner class type. */
  public void visitTypeArgument() {}

  /**
   * Visits a type argument of the last visited class or inner class type.
   *
   * @param wildcard '+', '-' or '='.
   * @return a non null visitor to visit the signature of the type argument.
   */
  public SignatureVisitor visitTypeArgument(final char wildcard) {
    return this;
  }

  /** Ends the visit of a signature corresponding to a class or interface type. */
  public void visitEnd() {}
}

package org.objectweb.asm.signature;

/**
 * A parser for signature literals, as defined in the Java Virtual Machine Specification (JVMS), to
 * visit them with a SignatureVisitor.
 *
 * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1">JVMS
 *     4.7.9.1</a>
 * @author Thomas Hallgren
 * @author Eric Bruneton
 */
public class SignatureReader {

  /** The JVMS signature to be read. */
  private final String signatureValue;

  /**
   * Constructs a {@link SignatureReader} for the given signature.
   *
   * @param signature A <i>JavaTypeSignature</i>, <i>ClassSignature</i> or <i>MethodSignature</i>.
   */
  public SignatureReader(final String signature) {
    this.signatureValue = signature;
  }

  /**
   * Makes the given visitor visit the signature of this {@link SignatureReader}. This signature is
   * the one specified in the constructor (see {@link #SignatureReader}). This method is intended to
   * be called on a {@link SignatureReader} that was created using a <i>ClassSignature</i> (such as
   * the <code>signature</code> parameter of the {@link org.objectweb.asm.ClassVisitor#visit}
   * method) or a <i>MethodSignature</i> (such as the <code>signature</code> parameter of the {@link
   * org.objectweb.asm.ClassVisitor#visitMethod} method).
   *
   * @param signatureVistor the visitor that must visit this signature.
   */
  public void accept(final SignatureVisitor signatureVistor) {
    String signature = this.signatureValue;
    int length = signature.length();
    int offset; // Current offset in the parsed signature (parsed from left to right).
    char currentChar; // The signature character at 'offset', or just before.

    // If the signature starts with '<', it starts with TypeParameters, i.e. a formal type parameter
    // identifier, followed by one or more pair ':',ReferenceTypeSignature (for its class bound and
    // interface bounds).
    if (signature.charAt(0) == '<') {
      // Invariant: offset points to the second character of a formal type parameter name at the
      // beginning of each iteration of the loop below.
      offset = 2;
      do {
        // The formal type parameter name is everything between offset - 1 and the first ':'.
        int classBoundStartOffset = signature.indexOf(':', offset);
        signatureVistor.visitFormalTypeParameter(
            signature.substring(offset - 1, classBoundStartOffset));

        // If the character after the ':' class bound marker is not the start of a
        // ReferenceTypeSignature, it means the class bound is empty (which is a valid case).
        offset = classBoundStartOffset + 1;
        currentChar = signature.charAt(offset);
        if (currentChar == 'L' || currentChar == '[' || currentChar == 'T') {
          offset = parseType(signature, offset, signatureVistor.visitClassBound());
        }

        // While the character after the class bound or after the last parsed interface bound
        // is ':', we need to parse another interface bound.
        while ((currentChar = signature.charAt(offset++)) == ':') {
          offset = parseType(signature, offset, signatureVistor.visitInterfaceBound());
        }

        // At this point a TypeParameter has been fully parsed, and we need to parse the next one
        // (note that currentChar is now the first character of the next TypeParameter, and that
        // offset points to the second character), unless the character just after this
        // TypeParameter signals the end of the TypeParameters.
      } while (currentChar != '>');
    } else {
      offset = 0;
    }

    // If the (optional) TypeParameters is followed by '(' this means we are parsing a
    // MethodSignature, which has JavaTypeSignature type inside parentheses, followed by a Result
    // type and optional ThrowsSignature types.
    if (signature.charAt(offset) == '(') {
      offset++;
      while (signature.charAt(offset) != ')') {
        offset = parseType(signature, offset, signatureVistor.visitParameterType());
      }
      // Use offset + 1 to skip ')'.
      offset = parseType(signature, offset + 1, signatureVistor.visitReturnType());
      while (offset < length) {
        // Use offset + 1 to skip the first character of a ThrowsSignature, i.e. '^'.
        offset = parseType(signature, offset + 1, signatureVistor.visitExceptionType());
      }
    } else {
      // Otherwise we are parsing a ClassSignature (by hypothesis on the method input), which has
      // one or more ClassTypeSignature for the super class and the implemented interfaces.
      offset = parseType(signature, offset, signatureVistor.visitSuperclass());
      while (offset < length) {
        offset = parseType(signature, offset, signatureVistor.visitInterface());
      }
    }
  }

  /**
   * Makes the given visitor visit the signature of this {@link SignatureReader}. This signature is
   * the one specified in the constructor (see {@link #SignatureReader}). This method is intended to
   * be called on a {@link SignatureReader} that was created using a <i>JavaTypeSignature</i>, such
   * as the <code>signature</code> parameter of the {@link
   * org.objectweb.asm.ClassVisitor#visitField} or {@link
   * org.objectweb.asm.MethodVisitor#visitLocalVariable} methods.
   *
   * @param signatureVisitor the visitor that must visit this signature.
   */
  public void acceptType(final SignatureVisitor signatureVisitor) {
    parseType(signatureValue, 0, signatureVisitor);
  }

  /**
   * Parses a JavaTypeSignature and makes the given visitor visit it.
   *
   * @param signature a string containing the signature that must be parsed.
   * @param startOffset index of the first character of the signature to parsed.
   * @param signatureVisitor the visitor that must visit this signature.
   * @return the index of the first character after the parsed signature.
   */
  private static int parseType(
      final String signature, final int startOffset, final SignatureVisitor signatureVisitor) {
    int offset = startOffset; // Current offset in the parsed signature.
    char currentChar = signature.charAt(offset++); // The signature character at 'offset'.

    // Switch based on the first character of the JavaTypeSignature, which indicates its kind.
    switch (currentChar) {
      case 'Z':
      case 'C':
      case 'B':
      case 'S':
      case 'I':
      case 'F':
      case 'J':
      case 'D':
      case 'V':
        // Case of a BaseType or a VoidDescriptor.
        signatureVisitor.visitBaseType(currentChar);
        return offset;

      case '[':
        // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature.
        return parseType(signature, offset, signatureVisitor.visitArrayType());

      case 'T':
        // Case of TypeVariableSignature, an identifier between 'T' and ';'.
        int endOffset = signature.indexOf(';', offset);
        signatureVisitor.visitTypeVariable(signature.substring(offset, endOffset));
        return endOffset + 1;

      case 'L':
        // Case of a ClassTypeSignature, which ends with ';'.
        // These signatures have a main class type followed by zero or more inner class types
        // (separated by '.'). Each can have type arguments, inside '<' and '>'.
        int start = offset; // The start offset of the currently parsed main or inner class name.
        boolean visited = false; // Whether the currently parsed class name has been visited.
        boolean inner = false; // Whether we are currently parsing an inner class type.
        // Parses the signature, one character at a time.
        while (true) {
          currentChar = signature.charAt(offset++);
          if (currentChar == '.' || currentChar == ';') {
            // If a '.' or ';' is encountered, this means we have fully parsed the main class name
            // or an inner class name. This name may already have been visited it is was followed by
            // type arguments between '<' and '>'. If not, we need to visit it here.
            if (!visited) {
              String name = signature.substring(start, offset - 1);
              if (inner) {
                signatureVisitor.visitInnerClassType(name);
              } else {
                signatureVisitor.visitClassType(name);
              }
            }
            // If we reached the end of the ClassTypeSignature return, otherwise start the parsing
            // of a new class name, which is necessarily an inner class name.
            if (currentChar == ';') {
              signatureVisitor.visitEnd();
              break;
            }
            start = offset;
            visited = false;
            inner = true;
          } else if (currentChar == '<') {
            // If a '<' is encountered, this means we have fully parsed the main class name or an
            // inner class name, and that we now need to parse TypeArguments. First, we need to
            // visit the parsed class name.
            String name = signature.substring(start, offset - 1);
            if (inner) {
              signatureVisitor.visitInnerClassType(name);
            } else {
              signatureVisitor.visitClassType(name);
            }
            visited = true;
            // Now, parse the TypeArgument(s), one at a time.
            while ((currentChar = signature.charAt(offset)) != '>') {
              switch (currentChar) {
                case '*':
                  // Unbounded TypeArgument.
                  ++offset;
                  signatureVisitor.visitTypeArgument();
                  break;
                case '+':
                case '-':
                  // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'.
                  offset =
                      parseType(
                          signature, offset + 1, signatureVisitor.visitTypeArgument(currentChar));
                  break;
                default:
                  // Instanceof TypeArgument. The '=' is implicit.
                  offset = parseType(signature, offset, signatureVisitor.visitTypeArgument('='));
                  break;
              }
            }
          }
        }
        return offset;

      default:
        throw new IllegalArgumentException();
    }
  }
}

package org.objectweb.asm;

/**
 * A visitor to visit a Java class. The methods of this class must be called in the following order:
 * {@code visit} [ {@code visitSource} ] [ {@code visitModule} ][ {@code visitNestHost} ][ {@code
 * visitOuterClass} ] ( {@code visitAnnotation} | {@code visitTypeAnnotation} | {@code
 * visitAttribute} )* ( {@code visitNestMember} | [ {@code * visitPermittedSubclass} ] | {@code
 * visitInnerClass} | {@code visitRecordComponent} | {@code visitField} | {@code visitMethod} )*
 * {@code visitEnd}.
 *
 * @author Eric Bruneton
 */
public abstract class ClassVisitor {

  /**
   * The ASM API version implemented by this visitor. The value of this field must be one of the
   * {@code ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected final int api;

  /** The class visitor to which this visitor must delegate method calls. May be {@literal null}. */
  protected ClassVisitor cv;

  /**
   * Constructs a new {@link ClassVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected ClassVisitor(final int api) {
    this(api, null);
  }

  /**
   * Constructs a new {@link ClassVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param classVisitor the class visitor to which this visitor must delegate method calls. May be
   *     null.
   */
  protected ClassVisitor(final int api, final ClassVisitor classVisitor) {
    if (api != Opcodes.ASM9
        && api != Opcodes.ASM8
        && api != Opcodes.ASM7
        && api != Opcodes.ASM6
        && api != Opcodes.ASM5
        && api != Opcodes.ASM4
        && api != Opcodes.ASM10_EXPERIMENTAL) {
      throw new IllegalArgumentException("Unsupported api " + api);
    }
    if (api == Opcodes.ASM10_EXPERIMENTAL) {
      Constants.checkAsmExperimental(this);
    }
    this.api = api;
    this.cv = classVisitor;
  }

  /**
   * The class visitor to which this visitor must delegate method calls. May be {@literal null}.
   *
   * @return the class visitor to which this visitor must delegate method calls, or {@literal null}.
   */
  public ClassVisitor getDelegate() {
    return cv;
  }

  /**
   * Visits the header of the class.
   *
   * @param version the class version. The minor version is stored in the 16 most significant bits,
   *     and the major version in the 16 least significant bits.
   * @param access the class's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the class is deprecated {@link Opcodes#ACC_DEPRECATED} or a record {@link
   *     Opcodes#ACC_RECORD}.
   * @param name the internal name of the class (see {@link Type#getInternalName()}).
   * @param signature the signature of this class. May be {@literal null} if the class is not a
   *     generic one, and does not extend or implement generic classes or interfaces.
   * @param superName the internal of name of the super class (see {@link Type#getInternalName()}).
   *     For interfaces, the super class is {@link Object}. May be {@literal null}, but only for the
   *     {@link Object} class.
   * @param interfaces the internal names of the class's interfaces (see {@link
   *     Type#getInternalName()}). May be {@literal null}.
   */
  public void visit(
      final int version,
      final int access,
      final @InternalForm String name,
      final String signature,
      final String superName,
      final @InternalForm String @Nullable [] interfaces) {
    if (api < Opcodes.ASM8 && (access & Opcodes.ACC_RECORD) != 0) {
      throw new UnsupportedOperationException("Records requires ASM8");
    }
    if (cv != null) {
      cv.visit(version, access, name, signature, superName, interfaces);
    }
  }

  /**
   * Visits the source of the class.
   *
   * @param source the name of the source file from which the class was compiled. May be {@literal
   *     null}.
   * @param debug additional debug information to compute the correspondence between source and
   *     compiled elements of the class. May be {@literal null}.
   */
  public void visitSource(final String source, final String debug) {
    if (cv != null) {
      cv.visitSource(source, debug);
    }
  }

  /**
   * Visit the module corresponding to the class.
   *
   * @param name the fully qualified name (using dots) of the module.
   * @param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code
   *     ACC_MANDATED}.
   * @param version the module version, or {@literal null}.
   * @return a visitor to visit the module values, or {@literal null} if this visitor is not
   *     interested in visiting this module.
   */
  public ModuleVisitor visitModule(final String name, final int access, final String version) {
    if (api < Opcodes.ASM6) {
      throw new UnsupportedOperationException("Module requires ASM6");
    }
    if (cv != null) {
      return cv.visitModule(name, access, version);
    }
    return null;
  }

  /**
   * Visits the nest host class of the class. A nest is a set of classes of the same package that
   * share access to their private members. One of these classes, called the host, lists the other
   * members of the nest, which in turn should link to the host of their nest. This method must be
   * called only once and only if the visited class is a non-host member of a nest. A class is
   * implicitly its own nest, so it's invalid to call this method with the visited class name as
   * argument.
   *
   * @param nestHost the internal name of the host class of the nest (see {@link
   *     Type#getInternalName()}).
   */
  public void visitNestHost(final @InternalForm String nestHost) {
    if (api < Opcodes.ASM7) {
      throw new UnsupportedOperationException("NestHost requires ASM7");
    }
    if (cv != null) {
      cv.visitNestHost(nestHost);
    }
  }

  /**
   * Visits the enclosing class of the class. This method must be called only if this class is a
   * local or anonymous class. See the JVMS 4.7.7 section for more details.
   *
   * @param owner internal name of the enclosing class of the class (see {@link
   *     Type#getInternalName()}).
   * @param name the name of the method that contains the class, or {@literal null} if the class is
   *     not enclosed in a method or constructor of its enclosing class (e.g. if it is enclosed in
   *     an instance initializer, static initializer, instance variable initializer, or class
   *     variable initializer).
   * @param descriptor the descriptor of the method that contains the class, or {@literal null} if
   *     the class is not enclosed in a method or constructor of its enclosing class (e.g. if it is
   *     enclosed in an instance initializer, static initializer, instance variable initializer, or
   *     class variable initializer).
   */
  public void visitOuterClass(final @InternalForm String owner, final String name, final String descriptor) {
    if (cv != null) {
      cv.visitOuterClass(owner, name, descriptor);
    }
  }

  /**
   * Visits an annotation of the class.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (cv != null) {
      return cv.visitAnnotation(descriptor, visible);
    }
    return null;
  }

  /**
   * Visits an annotation on a type in the class signature.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link
   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See
   *     {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (api < Opcodes.ASM5) {
      throw new UnsupportedOperationException("TypeAnnotation requires ASM5");
    }
    if (cv != null) {
      return cv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a non standard attribute of the class.
   *
   * @param attribute an attribute.
   */
  public void visitAttribute(final Attribute attribute) {
    if (cv != null) {
      cv.visitAttribute(attribute);
    }
  }

  /**
   * Visits a member of the nest. A nest is a set of classes of the same package that share access
   * to their private members. One of these classes, called the host, lists the other members of the
   * nest, which in turn should link to the host of their nest. This method must be called only if
   * the visited class is the host of a nest. A nest host is implicitly a member of its own nest, so
   * it's invalid to call this method with the visited class name as argument.
   *
   * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).
   */
  public void visitNestMember(final @InternalForm String nestMember) {
    if (api < Opcodes.ASM7) {
      throw new UnsupportedOperationException("NestMember requires ASM7");
    }
    if (cv != null) {
      cv.visitNestMember(nestMember);
    }
  }

  /**
   * Visits a permitted subclasses. A permitted subclass is one of the allowed subclasses of the
   * current class.
   *
   * @param permittedSubclass the internal name of a permitted subclass (see {@link
   *     Type#getInternalName()}).
   */
  public void visitPermittedSubclass(final @InternalForm String permittedSubclass) {
    if (api < Opcodes.ASM9) {
      throw new UnsupportedOperationException("PermittedSubclasses requires ASM9");
    }
    if (cv != null) {
      cv.visitPermittedSubclass(permittedSubclass);
    }
  }

  /**
   * Visits information about an inner class. This inner class is not necessarily a member of the
   * class being visited. More precisely, every class or interface C which is referenced by this
   * class and which is not a package member must be visited with this method. This class must
   * reference its nested class or interface members, and its enclosing class, if any. See the JVMS
   * 4.7.6 section for more details.
   *
   * @param name the internal name of C (see {@link Type#getInternalName()}).
   * @param outerName the internal name of the class or interface C is a member of (see {@link
   *     Type#getInternalName()}). Must be {@literal null} if C is not the member of a class or
   *     interface (e.g. for local or anonymous classes).
   * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.
   * @param access the access flags of C originally declared in the source code from which this
   *     class was compiled.
   */
  public void visitInnerClass(
      final @InternalForm String name, final @InternalForm String outerName, final @Identifier String innerName, final int access) {
    if (cv != null) {
      cv.visitInnerClass(name, outerName, innerName, access);
    }
  }

  /**
   * Visits a record component of the class.
   *
   * @param name the record component name.
   * @param descriptor the record component descriptor (see {@link Type}).
   * @param signature the record component signature. May be {@literal null} if the record component
   *     type does not use generic types.
   * @return a visitor to visit this record component annotations and attributes, or {@literal null}
   *     if this class visitor is not interested in visiting these annotations and attributes.
   */
  public RecordComponentVisitor visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    if (api < Opcodes.ASM8) {
      throw new UnsupportedOperationException("Record requires ASM8");
    }
    if (cv != null) {
      return cv.visitRecordComponent(name, descriptor, signature);
    }
    return null;
  }

  /**
   * Visits a field of the class.
   *
   * @param access the field's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the field is synthetic and/or deprecated.
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link Type}).
   * @param signature the field's signature. May be {@literal null} if the field's type does not use
   *     generic types.
   * @param value the field's initial value. This parameter, which may be {@literal null} if the
   *     field does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link
   *     Long}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}
   *     or {@code String} fields respectively). <i>This parameter is only used for static
   *     fields</i>. Its value is ignored for non static fields, which must be initialized through
   *     bytecode instructions in constructors or methods.
   * @return a visitor to visit field annotations and attributes, or {@literal null} if this class
   *     visitor is not interested in visiting these annotations and attributes.
   */
  public FieldVisitor visitField(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    if (cv != null) {
      return cv.visitField(access, name, descriptor, signature, value);
    }
    return null;
  }

  /**
   * Visits a method of the class. This method <i>must</i> return a new {@link MethodVisitor}
   * instance (or {@literal null}) each time it is called, i.e., it should not return a previously
   * returned visitor.
   *
   * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the method is synthetic and/or deprecated.
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param signature the method's signature. May be {@literal null} if the method parameters,
   *     return type and exceptions do not use generic types.
   * @param exceptions the internal names of the method's exception classes (see {@link
   *     Type#getInternalName()}). May be {@literal null}.
   * @return an object to visit the byte code of the method, or {@literal null} if this class
   *     visitor is not interested in visiting the code of this method.
   */
  public MethodVisitor visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String @Nullable [] exceptions) {
    if (cv != null) {
      return cv.visitMethod(access, name, descriptor, signature, exceptions);
    }
    return null;
  }

  /**
   * Visits the end of the class. This method, which is the last one to be called, is used to inform
   * the visitor that all the fields and methods of the class have been visited.
   */
  public void visitEnd() {
    if (cv != null) {
      cv.visitEnd();
    }
  }
}

package org.objectweb.asm;

/**
 * A visitor to visit a Java annotation. The methods of this class must be called in the following
 * order: ( {@code visit} | {@code visitEnum} | {@code visitAnnotation} | {@code visitArray} )*
 * {@code visitEnd}.
 *
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
public abstract class AnnotationVisitor {

  /**
   * The ASM API version implemented by this visitor. The value of this field must be one of the
   * {@code ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected final int api;

  /**
   * The annotation visitor to which this visitor must delegate method calls. May be {@literal
   * null}.
   */
  protected AnnotationVisitor av;

  /**
   * Constructs a new {@link AnnotationVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected AnnotationVisitor(final int api) {
    this(api, null);
  }

  /**
   * Constructs a new {@link AnnotationVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param annotationVisitor the annotation visitor to which this visitor must delegate method
   *     calls. May be {@literal null}.
   */
  protected AnnotationVisitor(final int api, final AnnotationVisitor annotationVisitor) {
    if (api != Opcodes.ASM9
        && api != Opcodes.ASM8
        && api != Opcodes.ASM7
        && api != Opcodes.ASM6
        && api != Opcodes.ASM5
        && api != Opcodes.ASM4
        && api != Opcodes.ASM10_EXPERIMENTAL) {
      throw new IllegalArgumentException("Unsupported api " + api);
    }
    if (api == Opcodes.ASM10_EXPERIMENTAL) {
      Constants.checkAsmExperimental(this);
    }
    this.api = api;
    this.av = annotationVisitor;
  }

  /**
   * The annotation visitor to which this visitor must delegate method calls. May be {@literal
   * null}.
   *
   * @return the annotation visitor to which this visitor must delegate method calls, or {@literal
   *     null}.
   */
  public AnnotationVisitor getDelegate() {
    return av;
  }

  /**
   * Visits a primitive value of the annotation.
   *
   * @param name the value name.
   * @param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link
   *     Character}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},
   *     {@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This
   *     value can also be an array of byte, boolean, short, char, int, long, float or double values
   *     (this is equivalent to using {@link #visitArray} and visiting each array element in turn,
   *     but is more convenient).
   */
  public void visit(final String name, final Object value) {
    if (av != null) {
      av.visit(name, value);
    }
  }

  /**
   * Visits an enumeration value of the annotation.
   *
   * @param name the value name.
   * @param descriptor the class descriptor of the enumeration class.
   * @param value the actual enumeration value.
   */
  public void visitEnum(final String name, final String descriptor, final String value) {
    if (av != null) {
      av.visitEnum(name, descriptor, value);
    }
  }

  /**
   * Visits a nested annotation value of the annotation.
   *
   * @param name the value name.
   * @param descriptor the class descriptor of the nested annotation class.
   * @return a visitor to visit the actual nested annotation value, or {@literal null} if this
   *     visitor is not interested in visiting this nested annotation. <i>The nested annotation
   *     value must be fully visited before calling other methods on this annotation visitor</i>.
   */
  public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
    if (av != null) {
      return av.visitAnnotation(name, descriptor);
    }
    return null;
  }

  /**
   * Visits an array value of the annotation. Note that arrays of primitive values (such as byte,
   * boolean, short, char, int, long, float or double) can be passed as value to {@link #visit
   * visit}. This is what {@link ClassReader} does for non empty arrays of primitive values.
   *
   * @param name the value name.
   * @return a visitor to visit the actual array value elements, or {@literal null} if this visitor
   *     is not interested in visiting these values. The 'name' parameters passed to the methods of
   *     this visitor are ignored. <i>All the array values must be visited before calling other
   *     methods on this annotation visitor</i>.
   */
  public AnnotationVisitor visitArray(final String name) {
    if (av != null) {
      return av.visitArray(name);
    }
    return null;
  }

  /** Visits the end of the annotation. */
  public void visitEnd() {
    if (av != null) {
      av.visitEnd();
    }
  }
}

package org.objectweb.asm;

/**
 * A visitor to visit a record component. The methods of this class must be called in the following
 * order: ( {@code visitAnnotation} | {@code visitTypeAnnotation} | {@code visitAttribute} )* {@code
 * visitEnd}.
 *
 * @author Remi Forax
 * @author Eric Bruneton
 */
public abstract class RecordComponentVisitor {
  /**
   * The ASM API version implemented by this visitor. The value of this field must be one of {@link
   * Opcodes#ASM8} or {@link Opcodes#ASM9}.
   */
  protected final int api;

  /**
   * The record visitor to which this visitor must delegate method calls. May be {@literal null}.
   */
  protected RecordComponentVisitor delegate;

  /**
   * Constructs a new {@link RecordComponentVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM8}
   *     or {@link Opcodes#ASM9}.
   */
  protected RecordComponentVisitor(final int api) {
    this(api, null);
  }

  /**
   * Constructs a new {@link RecordComponentVisitor}.
   *
   * @param api the ASM API version implemented by this visitor. Must be {@link Opcodes#ASM8}.
   * @param recordComponentVisitor the record component visitor to which this visitor must delegate
   *     method calls. May be null.
   */
  protected RecordComponentVisitor(
      final int api, final RecordComponentVisitor recordComponentVisitor) {
    if (api != Opcodes.ASM9
        && api != Opcodes.ASM8
        && api != Opcodes.ASM7
        && api != Opcodes.ASM6
        && api != Opcodes.ASM5
        && api != Opcodes.ASM4
        && api != Opcodes.ASM10_EXPERIMENTAL) {
      throw new IllegalArgumentException("Unsupported api " + api);
    }
    if (api == Opcodes.ASM10_EXPERIMENTAL) {
      Constants.checkAsmExperimental(this);
    }
    this.api = api;
    this.delegate = recordComponentVisitor;
  }

  /**
   * The record visitor to which this visitor must delegate method calls. May be {@literal null}.
   *
   * @return the record visitor to which this visitor must delegate method calls, or {@literal
   *     null}.
   */
  public RecordComponentVisitor getDelegate() {
    return delegate;
  }

  /**
   * Visits an annotation of the record component.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    if (delegate != null) {
      return delegate.visitAnnotation(descriptor, visible);
    }
    return null;
  }

  /**
   * Visits an annotation on a type in the record component signature.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link
   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See
   *     {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    if (delegate != null) {
      return delegate.visitTypeAnnotation(typeRef, typePath, descriptor, visible);
    }
    return null;
  }

  /**
   * Visits a non standard attribute of the record component.
   *
   * @param attribute an attribute.
   */
  public void visitAttribute(final Attribute attribute) {
    if (delegate != null) {
      delegate.visitAttribute(attribute);
    }
  }

  /**
   * Visits the end of the record component. This method, which is the last one to be called, is
   * used to inform the visitor that everything have been visited.
   */
  public void visitEnd() {
    if (delegate != null) {
      delegate.visitEnd();
    }
  }
}

package org.objectweb.asm.tools;

import static java.lang.String.format;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
import static org.objectweb.asm.Opcodes.ACC_STATIC;
import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
import static org.objectweb.asm.Opcodes.ARETURN;
import static org.objectweb.asm.Opcodes.DUP;
import static org.objectweb.asm.Opcodes.ILOAD;
import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
import static org.objectweb.asm.Opcodes.INVOKESTATIC;
import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
import static org.objectweb.asm.Opcodes.NEW;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.lang.module.ModuleDescriptor;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Stream;
import java.util.zip.GZIPInputStream;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * A tool to transform classes in order to make them compatible with Java 1.5, and to check that
 * they use only the JDK 1.5 API and JDK 1.5 class file features. The original classes can either be
 * transformed "in place", or be copied first to destination directory and transformed here (leaving
 * the original classes unchanged).
 *
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
public final class Retrofitter {

  /** The name of the module-info file. */
  private static final String MODULE_INFO = "module-info.class";

  /** The name of the java.base module. */
  private static final String JAVA_BASE_MODULE = "java.base";

  /** Bootstrap method for the string concatenation using indy. */
  private static final Handle STRING_CONCAT_FACTORY_HANDLE =
      new Handle(
          Opcodes.H_INVOKESTATIC,
          "java/lang/invoke/StringConcatFactory",
          "makeConcatWithConstants",
          "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;",
          false);

  /**
   * The fields and methods of the JDK 1.5 API. Each string has the form
   * "&lt;owner&gt;&lt;name&gt;&lt;descriptor&gt;".
   */
  private final HashSet<String> jdkApi = new HashSet<>();

  /**
   * The class hierarchy of the JDK 1.5 API. Maps each class name to the name of its super class.
   */
  private final HashMap<String, String> jdkHierarchy = new HashMap<>();

  /** The internal names of the packages exported by the retrofitted classes. */
  private final HashSet<String> exports = new HashSet<>();

  /** The internal names of the packages imported by the retrofitted classes. */
  private final HashSet<String> imports = new HashSet<>();

  /**
   * Transforms the class files in the given directory, in place, in order to make them compatible
   * with the JDK 1.5. Also generates a module-info class in this directory, with the given module
   * version.
   *
   * @param args a directory containing compiled classes and the ASM release version.
   * @throws IOException if a file can't be read or written.
   */
  public static void main(final String[] args) throws IOException {
    if (args.length == 2) {
      new Retrofitter().retrofit(Paths.get(args[0]), args[1]);
    } else {
      System.err.println("Usage: Retrofitter <classes directory> <ASM release version>"); // NOPMD
    }
  }

  /**
   * Transforms the class files in the given directory, in place, in order to make them compatible
   * with the JDK 1.5. Also generates a module-info class in this directory, with the given module
   * version.
   *
   * @param classesDir a directory containing compiled classes.
   * @param version the module-info version.
   * @throws IOException if a file can't be read or written.
   */
  public void retrofit(final Path classesDir, final String version) throws IOException {
    for (Path classFile : getAllClasses(classesDir, /* includeModuleInfo= */ true)) {
      ClassReader classReader = new ClassReader(Files.readAllBytes(classFile));
      ClassWriter classWriter = new ClassWriter(0);
      classReader.accept(new ClassRetrofitter(classWriter), ClassReader.SKIP_FRAMES);
      Files.write(classFile, classWriter.toByteArray());
    }
    generateModuleInfoClass(classesDir, version);
  }

  /**
   * Verify that the class files in the given directory only use JDK 1.5 APIs, and that a
   * module-info class is present with the expected content.
   *
   * @param classesDir a directory containing compiled classes.
   * @param expectedVersion the expected module-info version.
   * @param expectedExports the expected module-info exported packages.
   * @param expectedRequires the expected module-info required modules.
   * @throws IOException if a file can't be read.
   * @throws IllegalArgumentException if the module-info class does not have the expected content.
   */
  public void verify(
      final Path classesDir,
      final String expectedVersion,
      final List<String> expectedExports,
      final List<String> expectedRequires)
      throws IOException {
    if (jdkApi.isEmpty()) {
      readJdkApi();
    }

    List<Path> classFiles = getAllClasses(classesDir, /* includeModuleInfo= */ false);
    List<ClassReader> classReaders = getClassReaders(classFiles);
    for (ClassReader classReader : classReaders) {
      classReader.accept(new ClassVerifier(), 0);
    }
    checkPrivateMemberAccess(classReaders);
    verifyModuleInfoClass(
        classesDir,
        expectedVersion,
        new HashSet<>(expectedExports),
        Stream.concat(expectedRequires.stream(), Stream.of(JAVA_BASE_MODULE)).collect(toSet()));
  }

  private List<ClassReader> getClassReaders(final List<Path> classFiles) throws IOException {
    ArrayList<ClassReader> classReaders = new ArrayList<>();
    for (Path classFile : classFiles) {
      classReaders.add(new ClassReader(Files.readAllBytes(classFile)));
    }
    return classReaders;
  }

  private List<Path> getAllClasses(final Path path, final boolean includeModuleInfo)
      throws IOException {
    try (Stream<Path> stream = Files.walk(path)) {
      return stream
          .filter(
              child -> {
                String filename = child.getFileName().toString();
                return filename.endsWith(".class")
                    && (includeModuleInfo || !filename.equals("module-info.class"));
              })
          .collect(toList());
    }
  }

  /**
   * Checks that no code accesses to a private member from another class. If there is a private
   * access, removing the nestmate attributes is not a legal transformation.
   */
  private static void checkPrivateMemberAccess(final List<ClassReader> readers) {
    // Compute all private members.
    HashMap<String, HashSet<String>> privateMemberMap = new HashMap<>();
    for (ClassReader reader : readers) {
      HashSet<String> privateMembers = new HashSet<>();
      reader.accept(
          new ClassVisitor(/* latest api =*/ Opcodes.ASM9) {
            @Override
            public void visit(
                final int version,
                final int access,
                final String name,
                final String signature,
                final String superName,
                final String[] interfaces) {
              privateMemberMap.put(name, privateMembers);
            }

            @Override
            public FieldVisitor visitField(
                final int access,
                final String name,
                final String descriptor,
                final String signature,
                final Object value) {
              if ((access & ACC_PRIVATE) != 0) {
                privateMembers.add(name + '/' + descriptor);
              }
              return null;
            }

            @Override
            public MethodVisitor visitMethod(
                final int access,
                final String name,
                final String descriptor,
                final String signature,
                final String[] exceptions) {
              if ((access & ACC_PRIVATE) != 0) {
                privateMembers.add(name + '/' + descriptor);
              }
              return null;
            }
          },
          0);
    }

    // Verify that there is no access to a private member of another class.
    for (ClassReader reader : readers) {
      reader.accept(
          new ClassVisitor(/* latest api =*/ Opcodes.ASM9) {
            /** The internal name of the visited class. */
            @InternalForm String className;

            /** The name and descriptor of the currently visited method. */
            String currentMethodName;

            @Override
            public void visit(
                final int version,
                final int access,
                final String name,
                final String signature,
                final String superName,
                final String[] interfaces) {
              className = name;
            }

            @Override
            public MethodVisitor visitMethod(
                final int access,
                final String name,
                final String descriptor,
                final String signature,
                final String[] exceptions) {
              currentMethodName = name + descriptor;
              return new MethodVisitor(/* latest api =*/ Opcodes.ASM9) {

                private void checkAccess(
                    final String owner, final String name, final String descriptor) {
                  if (owner.equals(className)) { // same class access
                    return;
                  }
                  HashSet<String> members = privateMemberMap.get(owner);
                  if (members == null) { // not a known class
                    return;
                  }
                  if (members.contains(name + '/' + descriptor)) {
                    throw new IllegalArgumentException(
                        format(
                            "ERROR: illegal access to a private member %s.%s called in %s %s",
                            owner, name + " " + descriptor, className, currentMethodName));
                  }
                }

                @Override
                public void visitFieldInsn(
                    final int opcode,
                    final @InternalForm String owner,
                    final @Identifier String name,
                    final String descriptor) {
                  checkAccess(owner, name, descriptor);
                }

                @Override
                public void visitMethodInsn(
                    final int opcode,
                    final @InternalForm String owner,
                    final @Identifier String name,
                    final String descriptor,
                    final boolean isInterface) {
                  checkAccess(owner, name, descriptor);
                }

                @Override
                public void visitLdcInsn(final Object value) {
                  if (value instanceof Handle) {
                    Handle handle = (Handle) value;
                    checkAccess(handle.getOwner(), handle.getName(), handle.getDesc());
                  }
                }
              };
            }
          },
          0);
    }
  }

  private void generateModuleInfoClass(final Path dstDir, final String version) throws IOException {
    ClassWriter classWriter = new ClassWriter(0);
    classWriter.visit(Opcodes.V9, Opcodes.ACC_MODULE, "module-info", null, null, null);
    ArrayList<String> moduleNames = new ArrayList<>();
    for (String exportName : exports) {
      if (isAsmModule(exportName)) {
        moduleNames.add(exportName);
      }
    }
    if (moduleNames.size() != 1) {
      throw new IllegalArgumentException("Module name can't be infered from classes");
    }
    ModuleVisitor moduleVisitor =
        classWriter.visitModule(moduleNames.get(0).replace('/', '.'), Opcodes.ACC_OPEN, version);

    for (String importName : imports) {
      if (isAsmModule(importName) && !exports.contains(importName)) {
        moduleVisitor.visitRequire(importName.replace('/', '.'), Opcodes.ACC_TRANSITIVE, null);
      }
    }
    moduleVisitor.visitRequire(JAVA_BASE_MODULE, Opcodes.ACC_MANDATED, null);

    for (String exportName : exports) {
      moduleVisitor.visitExport(exportName, 0);
    }
    moduleVisitor.visitEnd();
    classWriter.visitEnd();
    Files.write(dstDir.toAbsolutePath().resolve(MODULE_INFO), classWriter.toByteArray());
  }

  private void verifyModuleInfoClass(
      final Path dstDir,
      final String expectedVersion,
      final Set<String> expectedExports,
      final Set<String> expectedRequires)
      throws IOException {
    ModuleDescriptor module =
        ModuleDescriptor.read(Files.newInputStream(dstDir.toAbsolutePath().resolve(MODULE_INFO)));
    String version = module.version().map(ModuleDescriptor.Version::toString).orElse("");
    if (!version.equals(expectedVersion)) {
      throw new IllegalArgumentException(
          format("Wrong module-info version '%s' (expected '%s')", version, expectedVersion));
    }
    Set<String> exports =
        module.exports().stream().map(ModuleDescriptor.Exports::source).collect(toSet());
    if (!exports.equals(expectedExports)) {
      throw new IllegalArgumentException(
          format("Wrong module-info exports %s (expected %s)", exports, expectedExports));
    }
    Set<String> requires =
        module.requires().stream().map(ModuleDescriptor.Requires::name).collect(toSet());
    if (!requires.equals(expectedRequires)) {
      throw new IllegalArgumentException(
          format("Wrong module-info requires %s (expected %s)", requires, expectedRequires));
    }
  }

  private static boolean isAsmModule(final String packageName) {
    return packageName.startsWith("org/objectweb/asm")
        && !packageName.equals("org/objectweb/asm/signature");
  }

  private void readJdkApi() throws IOException {
    try (InputStream inputStream =
            new GZIPInputStream(
                Retrofitter.class.getClassLoader().getResourceAsStream("jdk1.5.0.12.txt.gz"));
        InputStreamReader inputStreamReader =
            new InputStreamReader(inputStream, StandardCharsets.UTF_8);
        BufferedReader reader = new LineNumberReader(inputStreamReader)) {
      String line;
      while ((line = reader.readLine()) != null) {
        if (line.startsWith("class")) {
          String className = line.substring(6, line.lastIndexOf(' '));
          String superClassName = line.substring(line.lastIndexOf(' ') + 1);
          jdkHierarchy.put(className, superClassName);
        } else {
          jdkApi.add(line);
        }
      }
    }
  }

  /** A ClassVisitor that retrofits classes to 1.5 version. */
  final class ClassRetrofitter extends ClassVisitor {
    /** The internal name of the visited class. */
    @InternalForm String owner;

    /** An id used to generate the name of the synthetic string concatenation methods. */
    int concatMethodId;

    public ClassRetrofitter(final ClassVisitor classVisitor) {
      super(/* latest api =*/ Opcodes.ASM9, classVisitor);
    }

    @Override
    public void visit(
        final int version,
        final int access,
        final String name,
        final String signature,
        final String superName,
        final String[] interfaces) {
      owner = name;
      concatMethodId = 0;
      addPackageReferences(Type.getObjectType(name), /* export= */ true);
      super.visit(Opcodes.V1_5, access, name, signature, superName, interfaces);
    }

    @Override
    public void visitNestHost(final String nestHost) {
      // Remove the NestHost attribute.
    }

    @Override
    public void visitNestMember(final String nestMember) {
      // Remove the NestMembers attribute.
    }

    @Override
    public FieldVisitor visitField(
        final int access,
        final String name,
        final String descriptor,
        final String signature,
        final Object value) {
      addPackageReferences(Type.getType(descriptor), /* export= */ false);
      return super.visitField(access, name, descriptor, signature, value);
    }

    @Override
    public MethodVisitor visitMethod(
        final int access,
        final String name,
        final String descriptor,
        final String signature,
        final String[] exceptions) {
      addPackageReferences(Type.getType(descriptor), /* export= */ false);
      return new MethodVisitor(
          api, super.visitMethod(access, name, descriptor, signature, exceptions)) {

        @Override
        public void visitParameter(final String name, final int access) {
          // Javac 21 generates a Parameter attribute for the synthetic/mandated parameters.
          // Remove the Parameter attribute.
        }

        @Override
        public void visitFieldInsn(
            final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
          addPackageReferences(Type.getType(descriptor), /* export= */ false);
          super.visitFieldInsn(opcode, owner, name, descriptor);
        }

        @Override
        public void visitMethodInsn(
            final int opcode,
            final @InternalForm String owner,
            final @Identifier String name,
            final String descriptor,
            final boolean isInterface) {
          addPackageReferences(Type.getType(descriptor), /* export= */ false);
          // Remove the addSuppressed() method calls generated for try-with-resources statements.
          // This method is not defined in JDK1.5.
          if (owner.equals("java/lang/Throwable")
              && name.equals("addSuppressed")
              && descriptor.equals("(Ljava/lang/Throwable;)V")) {
            visitInsn(Opcodes.POP2);
          } else {
            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
          }
        }

        @Override
        public void visitInvokeDynamicInsn(
            final String name,
            final String descriptor,
            final Handle bootstrapMethodHandle,
            final Object... bootstrapMethodArguments) {
          // For simple recipe, (if there is no constant pool constants used), rewrite the
          // concatenation using a StringBuilder instead.
          if (STRING_CONCAT_FACTORY_HANDLE.equals(bootstrapMethodHandle)
              && bootstrapMethodArguments.length == 1) {
            String recipe = (String) bootstrapMethodArguments[0];
            String methodName = "stringConcat$" + concatMethodId++;
            generateConcatMethod(methodName, descriptor, recipe);
            super.visitMethodInsn(INVOKESTATIC, owner, methodName, descriptor, false);
            return;
          }
          super.visitInvokeDynamicInsn(
              name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
        }

        private void generateConcatMethod(
            final String methodName, final String descriptor, final String recipe) {
          MethodVisitor mv =
              visitMethod(
                  ACC_STATIC | ACC_PRIVATE | ACC_SYNTHETIC, methodName, descriptor, null, null);
          mv.visitCode();
          mv.visitTypeInsn(NEW, "java/lang/StringBuilder");
          mv.visitInsn(DUP);
          mv.visitMethodInsn(INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
          int nexLocal = 0;
          int typeIndex = 0;
          int maxStack = 2;
          Type[] types = Type.getArgumentTypes(descriptor);
          StringBuilder text = new StringBuilder();
          for (int i = 0; i < recipe.length(); i++) {
            char c = recipe.charAt(i);
            if (c == '\1') {
              if (text.length() != 0) {
                generateConstantTextAppend(mv, text.toString());
                text.setLength(0);
              }
              Type type = types[typeIndex++];
              mv.visitVarInsn(type.getOpcode(ILOAD), nexLocal);
              maxStack = Math.max(maxStack, 1 + type.getSize());
              String desc = stringBuilderAppendDescriptor(type);
              mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", desc, false);
              nexLocal += type.getSize();
            } else {
              text.append(c);
            }
          }
          if (text.length() != 0) {
            generateConstantTextAppend(mv, text.toString());
          }
          mv.visitMethodInsn(
              INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
          mv.visitInsn(ARETURN);
          mv.visitMaxs(maxStack, nexLocal);
          mv.visitEnd();
        }

        private void generateConstantTextAppend(final MethodVisitor mv, final String text) {
          mv.visitLdcInsn(text);
          mv.visitMethodInsn(
              INVOKEVIRTUAL,
              "java/lang/StringBuilder",
              "append",
              "(Ljava/lang/String;)Ljava/lang/StringBuilder;",
              false);
        }

        private String stringBuilderAppendDescriptor(final Type type) {
          switch (type.getSort()) {
            case Type.BYTE:
            case Type.SHORT:
            case Type.INT:
              return "(I)Ljava/lang/StringBuilder;";
            case Type.OBJECT:
              return type.getDescriptor().equals("Ljava/lang/String;")
                  ? "(Ljava/lang/String;)Ljava/lang/StringBuilder;"
                  : "(Ljava/lang/Object;)Ljava/lang/StringBuilder;";
            default:
              return '(' + type.getDescriptor() + ")Ljava/lang/StringBuilder;";
          }
        }

        @Override
        public void visitTypeInsn(final int opcode, final @InternalForm String type) {
          addPackageReferences(Type.getObjectType(type), /* export= */ false);
          super.visitTypeInsn(opcode, type);
        }

        @Override
        public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
          addPackageReferences(Type.getType(descriptor), /* export= */ false);
          super.visitMultiANewArrayInsn(descriptor, numDimensions);
        }

        @Override
        public void visitTryCatchBlock(
            final Label start, final Label end, final Label handler, final @InternalForm String type) {
          if (type != null) {
            addPackageReferences(Type.getObjectType(type), /* export= */ false);
          }
          super.visitTryCatchBlock(start, end, handler, type);
        }
      };
    }

    private void addPackageReferences(final Type type, final boolean export) {
      switch (type.getSort()) {
        case Type.ARRAY:
          addPackageReferences(type.getElementType(), export);
          break;
        case Type.METHOD:
          for (Type argumentType : type.getArgumentTypes()) {
            addPackageReferences(argumentType, export);
          }
          addPackageReferences(type.getReturnType(), export);
          break;
        case Type.OBJECT:
          String internalName = type.getInternalName();
          int lastSlashIndex = internalName.lastIndexOf('/');
          if (lastSlashIndex != -1) {
            (export ? exports : imports).add(internalName.substring(0, lastSlashIndex));
          }
          break;
        default:
          break;
      }
    }
  }

  /**
   * A ClassVisitor checking that a class uses only JDK 1.5 class file features and the JDK 1.5 API.
   */
  final class ClassVerifier extends ClassVisitor {

    /** The internal name of the visited class. */
    @InternalForm String className;

    /** The name and descriptor of the currently visited method. */
    String currentMethodName;

    public ClassVerifier() {
      // Make sure use we don't use Java 9 or higher classfile features.
      // We also want to make sure we don't use Java 6, 7 or 8 classfile
      // features (invokedynamic), but this can't be done in the same way.
      // Instead, we use manual checks below.
      super(Opcodes.ASM4, null);
    }

    @Override
    public void visit(
        final int version,
        final int access,
        final String name,
        final String signature,
        final String superName,
        final String[] interfaces) {
      if ((version & 0xFFFF) > Opcodes.V1_5) {
        throw new IllegalArgumentException(format("ERROR: %d version is newer than 1.5", version));
      }
      className = name;
    }

    @Override
    public MethodVisitor visitMethod(
        final int access,
        final String name,
        final String descriptor,
        final String signature,
        final String[] exceptions) {
      currentMethodName = name + descriptor;
      MethodVisitor methodVisitor =
          super.visitMethod(access, name, descriptor, signature, exceptions);
      return new MethodVisitor(Opcodes.ASM4, methodVisitor) {
        @Override
        public void visitFieldInsn(
            final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
          check(owner, name);
        }

        @Override
        public void visitMethodInsn(
            final int opcode,
            final @InternalForm String owner,
            final @Identifier String name,
            final String descriptor,
            final boolean isInterface) {
          check(owner, name + descriptor);
        }

        @Override
        public void visitLdcInsn(final Object value) {
          if (value instanceof Type) {
            int sort = ((Type) value).getSort();
            if (sort == Type.METHOD) {
              throw new IllegalArgumentException(
                  format(
                      "ERROR: ldc with a MethodType called in %s %s is not available in JDK 1.5",
                      className, currentMethodName));
            }
          } else if (value instanceof Handle) {
            throw new IllegalArgumentException(
                format(
                    "ERROR: ldc with a MethodHandle called in %s %s is not available in JDK 1.5",
                    className, currentMethodName));
          }
        }

        @Override
        public void visitInvokeDynamicInsn(
            final String name,
            final String descriptor,
            final Handle bootstrapMethodHandle,
            final Object... bootstrapMethodArguments) {
          throw new IllegalArgumentException(
              format(
                  "ERROR: invokedynamic called in %s %s is not available in JDK 1.5",
                  className, currentMethodName));
        }
      };
    }

    /**
     * Checks whether or not a field or method is defined in the JDK 1.5 API.
     *
     * @param owner A class name.
     * @param member A field name or a method name and descriptor.
     */
    private void check(final @InternalForm String owner, final String member) {
      if (owner.startsWith("java/")) {
        String currentOwner = owner;
        while (currentOwner != null) {
          if (jdkApi.contains(currentOwner + ' ' + member)) {
            return;
          }
          currentOwner = jdkHierarchy.get(currentOwner);
        }
        throw new IllegalArgumentException(
            format(
                "ERROR: %s %s called in %s %s is not defined in the JDK 1.5 API",
                owner, member, className, currentMethodName));
      }
    }
  }
}

package org.objectweb.asm.commons;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * A {@link MethodVisitor} to insert before, after and around advices in methods and constructors.
 * For constructors, the code keeps track of the elements on the stack in order to detect when the
 * super class constructor is called (note that there can be multiple such calls in different
 * branches). {@code onMethodEnter} is called after each super class constructor call, because the
 * object cannot be used before it is properly initialized.
 *
 * @author Eugene Kuleshov
 * @author Eric Bruneton
 */
public abstract class AdviceAdapter extends GeneratorAdapter implements Opcodes {

  /** The "uninitialized this" value. */
  private static final Object UNINITIALIZED_THIS = new Object();

  /** Any value other than "uninitialized this". */
  private static final Object OTHER = new Object();

  /** Prefix of the error message when invalid opcodes are found. */
  private static final String INVALID_OPCODE = "Invalid opcode ";

  /** The access flags of the visited method. */
  protected int methodAccess;

  /** The descriptor of the visited method. */
  protected String methodDesc;

  /** Whether the visited method is a constructor. */
  private final boolean isConstructor;

  /**
   * Whether the super class constructor has been called (if the visited method is a constructor),
   * at the current instruction. There can be multiple call sites to the super constructor (e.g. for
   * Java code such as {@code super(expr ? value1 : value2);}), in different branches. When scanning
   * the bytecode linearly, we can move from one branch where the super constructor has been called
   * to another where it has not been called yet. Therefore, this value can change from false to
   * true, and vice-versa.
   */
  private boolean superClassConstructorCalled;

  /**
   * The values on the current execution stack frame (long and double are represented by two
   * elements). Each value is either {@link #UNINITIALIZED_THIS} (for the uninitialized this value),
   * or {@link #OTHER} (for any other value). This field is only maintained for constructors, in
   * branches where the super class constructor has not been called yet.
   */
  private List<Object> stackFrame;

  /**
   * The stack map frames corresponding to the labels of the forward jumps made *before* the super
   * class constructor has been called (note that the Java Virtual Machine forbids backward jumps
   * before the super class constructor is called). Note that by definition (cf. the 'before'), when
   * we reach a label from this map, {@link #superClassConstructorCalled} must be reset to false.
   * This field is only maintained for constructors.
   */
  private Map<Label, List<Object>> forwardJumpStackFrames;

  /**
   * Constructs a new {@link AdviceAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param methodVisitor the method visitor to which this adapter delegates calls.
   * @param access the method's access flags (see {@link Opcodes}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type Type}).
   */
  protected AdviceAdapter(
      final int api,
      final MethodVisitor methodVisitor,
      final int access,
      final String name,
      final String descriptor) {
    super(api, methodVisitor, access, name, descriptor);
    methodAccess = access;
    methodDesc = descriptor;
    isConstructor = "<init>".equals(name);
  }

  @Override
  public void visitCode() {
    super.visitCode();
    if (isConstructor) {
      stackFrame = new ArrayList<>();
      forwardJumpStackFrames = new HashMap<>();
    } else {
      onMethodEnter();
    }
  }

  @Override
  public void visitLabel(final Label label) {
    super.visitLabel(label);
    if (isConstructor && forwardJumpStackFrames != null) {
      List<Object> labelStackFrame = forwardJumpStackFrames.get(label);
      if (labelStackFrame != null) {
        stackFrame = labelStackFrame;
        superClassConstructorCalled = false;
        forwardJumpStackFrames.remove(label);
      }
    }
  }

  @Override
  public void visitInsn(final int opcode) {
    if (isConstructor && !superClassConstructorCalled) {
      int stackSize;
      switch (opcode) {
        case IRETURN:
        case FRETURN:
        case ARETURN:
        case LRETURN:
        case DRETURN:
          throw new IllegalArgumentException("Invalid return in constructor");
        case RETURN: // empty stack
          onMethodExit(opcode);
          endConstructorBasicBlockWithoutSuccessor();
          break;
        case ATHROW: // 1 before n/a after
          popValue();
          onMethodExit(opcode);
          endConstructorBasicBlockWithoutSuccessor();
          break;
        case NOP:
        case LALOAD: // remove 2 add 2
        case DALOAD: // remove 2 add 2
        case LNEG:
        case DNEG:
        case FNEG:
        case INEG:
        case L2D:
        case D2L:
        case F2I:
        case I2B:
        case I2C:
        case I2S:
        case I2F:
        case ARRAYLENGTH:
          break;
        case ACONST_NULL:
        case ICONST_M1:
        case ICONST_0:
        case ICONST_1:
        case ICONST_2:
        case ICONST_3:
        case ICONST_4:
        case ICONST_5:
        case FCONST_0:
        case FCONST_1:
        case FCONST_2:
        case F2L: // 1 before 2 after
        case F2D:
        case I2L:
        case I2D:
          pushValue(OTHER);
          break;
        case LCONST_0:
        case LCONST_1:
        case DCONST_0:
        case DCONST_1:
          pushValue(OTHER);
          pushValue(OTHER);
          break;
        case IALOAD: // remove 2 add 1
        case FALOAD: // remove 2 add 1
        case AALOAD: // remove 2 add 1
        case BALOAD: // remove 2 add 1
        case CALOAD: // remove 2 add 1
        case SALOAD: // remove 2 add 1
        case POP:
        case IADD:
        case FADD:
        case ISUB:
        case LSHL: // 3 before 2 after
        case LSHR: // 3 before 2 after
        case LUSHR: // 3 before 2 after
        case L2I: // 2 before 1 after
        case L2F: // 2 before 1 after
        case D2I: // 2 before 1 after
        case D2F: // 2 before 1 after
        case FSUB:
        case FMUL:
        case FDIV:
        case FREM:
        case FCMPL: // 2 before 1 after
        case FCMPG: // 2 before 1 after
        case IMUL:
        case IDIV:
        case IREM:
        case ISHL:
        case ISHR:
        case IUSHR:
        case IAND:
        case IOR:
        case IXOR:
        case MONITORENTER:
        case MONITOREXIT:
          popValue();
          break;
        case POP2:
        case LSUB:
        case LMUL:
        case LDIV:
        case LREM:
        case LADD:
        case LAND:
        case LOR:
        case LXOR:
        case DADD:
        case DMUL:
        case DSUB:
        case DDIV:
        case DREM:
          popValue();
          popValue();
          break;
        case IASTORE:
        case FASTORE:
        case AASTORE:
        case BASTORE:
        case CASTORE:
        case SASTORE:
        case LCMP: // 4 before 1 after
        case DCMPL:
        case DCMPG:
          popValue();
          popValue();
          popValue();
          break;
        case LASTORE:
        case DASTORE:
          popValue();
          popValue();
          popValue();
          popValue();
          break;
        case DUP:
          pushValue(peekValue());
          break;
        case DUP_X1:
          stackSize = stackFrame.size();
          stackFrame.add(stackSize - 2, stackFrame.get(stackSize - 1));
          break;
        case DUP_X2:
          stackSize = stackFrame.size();
          stackFrame.add(stackSize - 3, stackFrame.get(stackSize - 1));
          break;
        case DUP2:
          stackSize = stackFrame.size();
          stackFrame.add(stackSize - 2, stackFrame.get(stackSize - 1));
          stackFrame.add(stackSize - 2, stackFrame.get(stackSize - 1));
          break;
        case DUP2_X1:
          stackSize = stackFrame.size();
          stackFrame.add(stackSize - 3, stackFrame.get(stackSize - 1));
          stackFrame.add(stackSize - 3, stackFrame.get(stackSize - 1));
          break;
        case DUP2_X2:
          stackSize = stackFrame.size();
          stackFrame.add(stackSize - 4, stackFrame.get(stackSize - 1));
          stackFrame.add(stackSize - 4, stackFrame.get(stackSize - 1));
          break;
        case SWAP:
          stackSize = stackFrame.size();
          stackFrame.add(stackSize - 2, stackFrame.get(stackSize - 1));
          stackFrame.remove(stackSize);
          break;
        default:
          throw new IllegalArgumentException(INVALID_OPCODE + opcode);
      }
    } else {
      switch (opcode) {
        case RETURN:
        case IRETURN:
        case FRETURN:
        case ARETURN:
        case LRETURN:
        case DRETURN:
        case ATHROW:
          onMethodExit(opcode);
          break;
        default:
          break;
      }
    }
    super.visitInsn(opcode);
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    super.visitVarInsn(opcode, varIndex);
    if (isConstructor && !superClassConstructorCalled) {
      switch (opcode) {
        case ILOAD:
        case FLOAD:
          pushValue(OTHER);
          break;
        case LLOAD:
        case DLOAD:
          pushValue(OTHER);
          pushValue(OTHER);
          break;
        case ALOAD:
          pushValue(varIndex == 0 ? UNINITIALIZED_THIS : OTHER);
          break;
        case ASTORE:
        case ISTORE:
        case FSTORE:
          popValue();
          break;
        case LSTORE:
        case DSTORE:
          popValue();
          popValue();
          break;
        case RET:
          endConstructorBasicBlockWithoutSuccessor();
          break;
        default:
          throw new IllegalArgumentException(INVALID_OPCODE + opcode);
      }
    }
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    super.visitFieldInsn(opcode, owner, name, descriptor);
    if (isConstructor && !superClassConstructorCalled) {
      char firstDescriptorChar = descriptor.charAt(0);
      boolean longOrDouble = firstDescriptorChar == 'J' || firstDescriptorChar == 'D';
      switch (opcode) {
        case GETSTATIC:
          pushValue(OTHER);
          if (longOrDouble) {
            pushValue(OTHER);
          }
          break;
        case PUTSTATIC:
          popValue();
          if (longOrDouble) {
            popValue();
          }
          break;
        case PUTFIELD:
          popValue();
          popValue();
          if (longOrDouble) {
            popValue();
          }
          break;
        case GETFIELD:
          if (longOrDouble) {
            pushValue(OTHER);
          }
          break;
        default:
          throw new IllegalArgumentException(INVALID_OPCODE + opcode);
      }
    }
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    super.visitIntInsn(opcode, operand);
    if (isConstructor && !superClassConstructorCalled && opcode != NEWARRAY) {
      pushValue(OTHER);
    }
  }

  @Override
  public void visitLdcInsn(final Object value) {
    super.visitLdcInsn(value);
    if (isConstructor && !superClassConstructorCalled) {
      pushValue(OTHER);
      if (value instanceof Double
          || value instanceof Long
          || (value instanceof ConstantDynamic && ((ConstantDynamic) value).getSize() == 2)) {
        pushValue(OTHER);
      }
    }
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    super.visitMultiANewArrayInsn(descriptor, numDimensions);
    if (isConstructor && !superClassConstructorCalled) {
      for (int i = 0; i < numDimensions; i++) {
        popValue();
      }
      pushValue(OTHER);
    }
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    super.visitTypeInsn(opcode, type);
    // ANEWARRAY, CHECKCAST or INSTANCEOF don't change stack.
    if (isConstructor && !superClassConstructorCalled && opcode == NEW) {
      pushValue(OTHER);
    }
  }

  @Override
  public void visitMethodInsn(
      final int opcodeAndSource,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
      // Redirect the call to the deprecated version of this method.
      super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
      return;
    }
    super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
    int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;

    doVisitMethodInsn(opcode, name, descriptor);
  }

  private void doVisitMethodInsn(final int opcode, final String name, final String descriptor) {
    if (isConstructor && !superClassConstructorCalled) {
      for (Type argumentType : Type.getArgumentTypes(descriptor)) {
        popValue();
        if (argumentType.getSize() == 2) {
          popValue();
        }
      }
      switch (opcode) {
        case INVOKEINTERFACE:
        case INVOKEVIRTUAL:
          popValue();
          break;
        case INVOKESPECIAL:
          Object value = popValue();
          if (value == UNINITIALIZED_THIS
              && !superClassConstructorCalled
              && name.equals("<init>")) {
            superClassConstructorCalled = true;
            onMethodEnter();
          }
          break;
        default:
          break;
      }

      Type returnType = Type.getReturnType(descriptor);
      if (returnType != Type.VOID_TYPE) {
        pushValue(OTHER);
        if (returnType.getSize() == 2) {
          pushValue(OTHER);
        }
      }
    }
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
    doVisitMethodInsn(Opcodes.INVOKEDYNAMIC, name, descriptor);
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    super.visitJumpInsn(opcode, label);
    if (isConstructor && !superClassConstructorCalled) {
      switch (opcode) {
        case IFEQ:
        case IFNE:
        case IFLT:
        case IFGE:
        case IFGT:
        case IFLE:
        case IFNULL:
        case IFNONNULL:
          popValue();
          break;
        case IF_ICMPEQ:
        case IF_ICMPNE:
        case IF_ICMPLT:
        case IF_ICMPGE:
        case IF_ICMPGT:
        case IF_ICMPLE:
        case IF_ACMPEQ:
        case IF_ACMPNE:
          popValue();
          popValue();
          break;
        case JSR:
          pushValue(OTHER);
          break;
        case GOTO:
          endConstructorBasicBlockWithoutSuccessor();
          break;
        default:
          break;
      }
      addForwardJump(label);
    }
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    super.visitLookupSwitchInsn(dflt, keys, labels);
    if (isConstructor && !superClassConstructorCalled) {
      popValue();
      addForwardJumps(dflt, labels);
      endConstructorBasicBlockWithoutSuccessor();
    }
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    super.visitTableSwitchInsn(min, max, dflt, labels);
    if (isConstructor && !superClassConstructorCalled) {
      popValue();
      addForwardJumps(dflt, labels);
      endConstructorBasicBlockWithoutSuccessor();
    }
  }

  @Override
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @InternalForm String type) {
    super.visitTryCatchBlock(start, end, handler, type);
    // By definition of 'forwardJumpStackFrames', 'handler' should be pushed only if there is an
    // instruction between 'start' and 'end' at which the super class constructor is not yet
    // called. Unfortunately, try catch blocks must be visited before their labels, so we have no
    // way to know this at this point. Instead, we suppose that the super class constructor has not
    // been called at the start of *any* exception handler. If this is wrong, normally there should
    // not be a second super class constructor call in the exception handler (an object can't be
    // initialized twice), so this is not issue (in the sense that there is no risk to emit a wrong
    // 'onMethodEnter').
    if (isConstructor && !forwardJumpStackFrames.containsKey(handler)) {
      List<Object> handlerStackFrame = new ArrayList<>();
      handlerStackFrame.add(OTHER);
      forwardJumpStackFrames.put(handler, handlerStackFrame);
    }
  }

  private void addForwardJumps(final Label dflt, final Label[] labels) {
    addForwardJump(dflt);
    for (Label label : labels) {
      addForwardJump(label);
    }
  }

  private void addForwardJump(final Label label) {
    if (forwardJumpStackFrames.containsKey(label)) {
      return;
    }
    forwardJumpStackFrames.put(label, new ArrayList<>(stackFrame));
  }

  private void endConstructorBasicBlockWithoutSuccessor() {
    // The next instruction is not reachable from this instruction. If it is dead code, we
    // should not try to simulate stack operations, and there is no need to insert advices
    // here. If it is reachable with a backward jump, the only possible case is that the super
    // class constructor has already been called (backward jumps are forbidden before it is
    // called). If it is reachable with a forward jump, there are two sub-cases. Either the
    // super class constructor has already been called when reaching the next instruction, or
    // it has not been called. But in this case there must be a forwardJumpStackFrames entry
    // for a Label designating the next instruction, and superClassConstructorCalled will be
    // reset to false there. We can therefore always reset this field to true here.
    superClassConstructorCalled = true;
  }

  private Object popValue() {
    return stackFrame.remove(stackFrame.size() - 1);
  }

  private Object peekValue() {
    return stackFrame.get(stackFrame.size() - 1);
  }

  private void pushValue(final Object value) {
    stackFrame.add(value);
  }

  /**
   * Generates the "before" advice for the visited method. The default implementation of this method
   * does nothing. Subclasses can use or change all the local variables, but should not change state
   * of the stack. This method is called at the beginning of the method or after super class
   * constructor has been called (in constructors).
   */
  protected void onMethodEnter() {}

  /**
   * Generates the "after" advice for the visited method. The default implementation of this method
   * does nothing. Subclasses can use or change all the local variables, but should not change state
   * of the stack. This method is called at the end of the method, just before return and athrow
   * instructions. The top element on the stack contains the return value or the exception instance.
   * For example:
   *
   * <pre>
   * public void onMethodExit(final int opcode) {
   *   if (opcode == RETURN) {
   *     visitInsn(ACONST_NULL);
   *   } else if (opcode == ARETURN || opcode == ATHROW) {
   *     dup();
   *   } else {
   *     if (opcode == LRETURN || opcode == DRETURN) {
   *       dup2();
   *     } else {
   *       dup();
   *     }
   *     box(Type.getReturnType(this.methodDesc));
   *   }
   *   visitIntInsn(SIPUSH, opcode);
   *   visitMethodInsn(INVOKESTATIC, owner, "onExit", "(Ljava/lang/Object;I)V");
   * }
   *
   * // An actual call back method.
   * public static void onExit(final Object exitValue, final int opcode) {
   *   ...
   * }
   * </pre>
   *
   * @param opcode one of {@link Opcodes#RETURN}, {@link Opcodes#IRETURN}, {@link Opcodes#FRETURN},
   *     {@link Opcodes#ARETURN}, {@link Opcodes#LRETURN}, {@link Opcodes#DRETURN} or {@link
   *     Opcodes#ATHROW}.
   */
  protected void onMethodExit(final int opcode) {}
}


package org.objectweb.asm.commons;

import org.objectweb.asm.Attribute;
import org.objectweb.asm.ByteVector;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;

/**
 * A ModuleTarget attribute. This attribute is specific to the OpenJDK and may change in the future.
 *
 * @author Remi Forax
 */
public final class ModuleTargetAttribute extends Attribute {

  /** The name of the platform on which the module can run. */
  public String platform;

  /**
   * Constructs a new {@link ModuleTargetAttribute}.
   *
   * @param platform the name of the platform on which the module can run.
   */
  public ModuleTargetAttribute(final String platform) {
    super("ModuleTarget");
    this.platform = platform;
  }

  /**
   * Constructs an empty {@link ModuleTargetAttribute}. This object can be passed as a prototype to
   * the {@link ClassReader#accept(org.objectweb.asm.ClassVisitor, Attribute[], int)} method.
   */
  public ModuleTargetAttribute() {
    this(null);
  }

  @Override
  protected Attribute read(
      final ClassReader classReader,
      final int offset,
      final int length,
      final char[] charBuffer,
      final int codeOffset,
      final Label[] labels) {
    return new ModuleTargetAttribute(classReader.readUTF8(offset, charBuffer));
  }

  @Override
  protected ByteVector write(
      final ClassWriter classWriter,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    ByteVector byteVector = new ByteVector();
    byteVector.putShort(platform == null ? 0 : classWriter.newUTF8(platform));
    return byteVector;
  }
}


package org.objectweb.asm.commons;

import java.util.Collections;
import java.util.Map;

/**
 * A {@link Remapper} using a {@link Map} to define its mapping.
 *
 * @author Eugene Kuleshov
 */
public class SimpleRemapper extends Remapper {

  private final Map<String, String> mapping;

  /**
   * Constructs a new {@link SimpleRemapper} with the given mapping.
   *
   * @param mapping a map specifying a remapping as follows:
   *     <ul>
   *       <li>for method names, the key is the owner, name and descriptor of the method (in the
   *           form &lt;owner&gt;.&lt;name&gt;&lt;descriptor&gt;), and the value is the new method
   *           name.
   *       <li>for invokedynamic method names, the key is the name and descriptor of the method (in
   *           the form .&lt;name&gt;&lt;descriptor&gt;), and the value is the new method name.
   *       <li>for field names, the key is the owner and name of the field or attribute (in the form
   *           &lt;owner&gt;.&lt;name&gt;), and the value is the new field name.
   *       <li>for attribute names, the key is the annotation descriptor and the name of the
   *           attribute (in the form &lt;descriptor&gt;.&lt;name&gt;), and the value is the new
   *           attribute name.
   *       <li>for internal names, the key is the old internal name, and the value is the new
   *           internal name (see {@link org.objectweb.asm.Type#getInternalName()}).
   *     </ul>
   */
  public SimpleRemapper(final Map<String, String> mapping) {
    this.mapping = mapping;
  }

  /**
   * Constructs a new {@link SimpleRemapper} with the given mapping.
   *
   * @param oldName the key corresponding to a method, field or internal name (see {@link
   *     #SimpleRemapper(Map)} for the format of these keys).
   * @param newName the new method, field or internal name (see {@link
   *     org.objectweb.asm.Type#getInternalName()}).
   */
  public SimpleRemapper(final String oldName, final String newName) {
    this.mapping = Collections.singletonMap(oldName, newName);
  }

  @Override
  public String mapMethodName(final @InternalForm String owner, final String name, final String descriptor) {
    String remappedName = map(owner + '.' + name + descriptor);
    return remappedName == null ? name : remappedName;
  }

  @Override
  public String mapInvokeDynamicMethodName(final String name, final String descriptor) {
    String remappedName = map('.' + name + descriptor);
    return remappedName == null ? name : remappedName;
  }

  @Override
  public String mapAnnotationAttributeName(final String descriptor, final String name) {
    String remappedName = map(descriptor + '.' + name);
    return remappedName == null ? name : remappedName;
  }

  @Override
  public String mapFieldName(final @InternalForm String owner, final String name, final String descriptor) {
    String remappedName = map(owner + '.' + name);
    return remappedName == null ? name : remappedName;
  }

  @Override
  public String map(final String key) {
    return mapping.get(key);
  }
}


package org.objectweb.asm.commons;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;

/**
 * A {@link MethodVisitor} that remaps types with a {@link Remapper}.
 *
 * @author Eugene Kuleshov
 */
public class MethodRemapper extends MethodVisitor {

  /** The remapper used to remap the types in the visited field. */
  protected final Remapper remapper;

  /**
   * Constructs a new {@link MethodRemapper}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #MethodRemapper(int,MethodVisitor,Remapper)} version.
   *
   * @param methodVisitor the method visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited method.
   */
  public MethodRemapper(final MethodVisitor methodVisitor, final Remapper remapper) {
    this(/* latest api = */ Opcodes.ASM9, methodVisitor, remapper);
  }

  /**
   * Constructs a new {@link MethodRemapper}.
   *
   * @param api the ASM API version supported by this remapper. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param methodVisitor the method visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited method.
   */
  protected MethodRemapper(
      final int api, final MethodVisitor methodVisitor, final Remapper remapper) {
    super(api, methodVisitor);
    this.remapper = remapper;
  }

  @Override
  public AnnotationVisitor visitAnnotationDefault() {
    AnnotationVisitor annotationVisitor = super.visitAnnotationDefault();
    return annotationVisitor == null
        ? annotationVisitor
        : createAnnotationRemapper(/* descriptor= */ null, annotationVisitor);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitAnnotation(remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? annotationVisitor
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitTypeAnnotation(typeRef, typePath, remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? annotationVisitor
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public AnnotationVisitor visitParameterAnnotation(
      final int parameter, final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitParameterAnnotation(parameter, remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? annotationVisitor
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    super.visitFrame(
        type,
        numLocal,
        remapFrameTypes(numLocal, local),
        numStack,
        remapFrameTypes(numStack, stack));
  }

  private Object[] remapFrameTypes(final int numTypes, final Object[] frameTypes) {
    if (frameTypes == null) {
      return frameTypes;
    }
    Object[] remappedFrameTypes = null;
    for (int i = 0; i < numTypes; ++i) {
      if (frameTypes[i] instanceof String) {
        if (remappedFrameTypes == null) {
          remappedFrameTypes = new Object[numTypes];
          System.arraycopy(frameTypes, 0, remappedFrameTypes, 0, numTypes);
        }
        remappedFrameTypes[i] = remapper.mapType((String) frameTypes[i]);
      }
    }
    return remappedFrameTypes == null ? frameTypes : remappedFrameTypes;
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    super.visitFieldInsn(
        opcode,
        remapper.mapType(owner),
        remapper.mapFieldName(owner, name, descriptor),
        remapper.mapDesc(descriptor));
  }

  @Override
  public void visitMethodInsn(
      final int opcodeAndSource,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
      // Redirect the call to the deprecated version of this method.
      super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
      return;
    }
    super.visitMethodInsn(
        opcodeAndSource,
        remapper.mapType(owner),
        remapper.mapMethodName(owner, name, descriptor),
        remapper.mapMethodDesc(descriptor),
        isInterface);
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    Object[] remappedBootstrapMethodArguments = new Object[bootstrapMethodArguments.length];
    for (int i = 0; i < bootstrapMethodArguments.length; ++i) {
      remappedBootstrapMethodArguments[i] = remapper.mapValue(bootstrapMethodArguments[i]);
    }
    super.visitInvokeDynamicInsn(
        remapper.mapInvokeDynamicMethodName(name, descriptor),
        remapper.mapMethodDesc(descriptor),
        (Handle) remapper.mapValue(bootstrapMethodHandle),
        remappedBootstrapMethodArguments);
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    super.visitTypeInsn(opcode, remapper.mapType(type));
  }

  @Override
  public void visitLdcInsn(final Object value) {
    super.visitLdcInsn(remapper.mapValue(value));
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    super.visitMultiANewArrayInsn(remapper.mapDesc(descriptor), numDimensions);
  }

  @Override
  public AnnotationVisitor visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitInsnAnnotation(typeRef, typePath, remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? annotationVisitor
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @InternalForm String type) {
    super.visitTryCatchBlock(start, end, handler, type == null ? null : remapper.mapType(type));
  }

  @Override
  public AnnotationVisitor visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitTryCatchAnnotation(typeRef, typePath, remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? annotationVisitor
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    super.visitLocalVariable(
        name,
        remapper.mapDesc(descriptor),
        remapper.mapSignature(signature, true),
        start,
        end,
        index);
  }

  @Override
  public AnnotationVisitor visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitLocalVariableAnnotation(
            typeRef, typePath, start, end, index, remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? annotationVisitor
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   * @deprecated use {@link #createAnnotationRemapper(String, AnnotationVisitor)} instead.
   */
  @Deprecated
  protected AnnotationVisitor createAnnotationRemapper(final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, /* descriptor= */ null, annotationVisitor, remapper);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param descriptor the descriptor of the visited annotation.
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected AnnotationVisitor createAnnotationRemapper(
      final String descriptor, final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, descriptor, annotationVisitor, remapper)
        .orDeprecatedValue(createAnnotationRemapper(annotationVisitor));
  }
}


package org.objectweb.asm.commons;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ByteVector;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;

/**
 * A ModuleHashes attribute. This attribute is specific to the OpenJDK and may change in the future.
 *
 * @author Remi Forax
 */
public final class ModuleHashesAttribute extends Attribute {

  /** The name of the hashing algorithm. */
  public String algorithm;

  /** A list of module names. */
  public List<String> modules;

  /** The hash of the modules in {@link #modules}. The two lists must have the same size. */
  public List<byte[]> hashes;

  /**
   * Constructs a new {@link ModuleHashesAttribute}.
   *
   * @param algorithm the name of the hashing algorithm.
   * @param modules a list of module names.
   * @param hashes the hash of the modules in 'modules'. The two lists must have the same size.
   */
  public ModuleHashesAttribute(
      final String algorithm, final List<String> modules, final List<byte[]> hashes) {
    super("ModuleHashes");
    this.algorithm = algorithm;
    this.modules = modules;
    this.hashes = hashes;
  }

  /**
   * Constructs an empty {@link ModuleHashesAttribute}. This object can be passed as a prototype to
   * the {@link ClassReader#accept(org.objectweb.asm.ClassVisitor, Attribute[], int)} method.
   */
  public ModuleHashesAttribute() {
    this(null, null, null);
  }

  @Override
  protected Attribute read(
      final ClassReader classReader,
      final int offset,
      final int length,
      final char[] charBuffer,
      final int codeAttributeOffset,
      final Label[] labels) {
    int currentOffset = offset;

    String hashAlgorithm = classReader.readUTF8(currentOffset, charBuffer);
    currentOffset += 2;

    int numModules = classReader.readUnsignedShort(currentOffset);
    currentOffset += 2;

    ArrayList<String> moduleList = new ArrayList<>(numModules);
    ArrayList<byte[]> hashList = new ArrayList<>(numModules);

    for (int i = 0; i < numModules; ++i) {
      String module = classReader.readModule(currentOffset, charBuffer);
      currentOffset += 2;
      moduleList.add(module);

      int hashLength = classReader.readUnsignedShort(currentOffset);
      currentOffset += 2;
      byte[] hash = new byte[hashLength];
      for (int j = 0; j < hashLength; ++j) {
        hash[j] = (byte) classReader.readByte(currentOffset);
        currentOffset += 1;
      }
      hashList.add(hash);
    }
    return new ModuleHashesAttribute(hashAlgorithm, moduleList, hashList);
  }

  @Override
  protected ByteVector write(
      final ClassWriter classWriter,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    ByteVector byteVector = new ByteVector();
    byteVector.putShort(classWriter.newUTF8(algorithm));
    if (modules == null) {
      byteVector.putShort(0);
    } else {
      int numModules = modules.size();
      byteVector.putShort(numModules);
      for (int i = 0; i < numModules; ++i) {
        String module = modules.get(i);
        byte[] hash = hashes.get(i);
        byteVector
            .putShort(classWriter.newModule(module))
            .putShort(hash.length)
            .putByteArray(hash, 0, hash.length);
      }
    }
    return byteVector;
  }
}

package org.objectweb.asm.commons;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * A {@link MethodVisitor} with convenient methods to generate code. For example, using this
 * adapter, the class below
 *
 * <pre>
 * public class Example {
 *   public static void main(String[] args) {
 *     System.out.println(&quot;Hello world!&quot;);
 *   }
 * }
 * </pre>
 *
 * <p>can be generated as follows:
 *
 * <pre>
 * ClassWriter cw = new ClassWriter(0);
 * cw.visit(V1_1, ACC_PUBLIC, &quot;Example&quot;, null, &quot;java/lang/Object&quot;, null);
 *
 * Method m = Method.getMethod(&quot;void &lt;init&gt; ()&quot;);
 * GeneratorAdapter mg = new GeneratorAdapter(ACC_PUBLIC, m, null, null, cw);
 * mg.loadThis();
 * mg.invokeConstructor(Type.getType(Object.class), m);
 * mg.returnValue();
 * mg.endMethod();
 *
 * m = Method.getMethod(&quot;void main (String[])&quot;);
 * mg = new GeneratorAdapter(ACC_PUBLIC + ACC_STATIC, m, null, null, cw);
 * mg.getStatic(Type.getType(System.class), &quot;out&quot;, Type.getType(PrintStream.class));
 * mg.push(&quot;Hello world!&quot;);
 * mg.invokeVirtual(Type.getType(PrintStream.class),
 *         Method.getMethod(&quot;void println (String)&quot;));
 * mg.returnValue();
 * mg.endMethod();
 *
 * cw.visitEnd();
 * </pre>
 *
 * @author Juozas Baliuka
 * @author Chris Nokleberg
 * @author Eric Bruneton
 * @author Prashant Deva
 */
public class GeneratorAdapter extends LocalVariablesSorter {

  private static final String CLASS_DESCRIPTOR = "Ljava/lang/Class;";

  private static final Type BYTE_TYPE = Type.getObjectType("java/lang/Byte");

  private static final Type BOOLEAN_TYPE = Type.getObjectType("java/lang/Boolean");

  private static final Type SHORT_TYPE = Type.getObjectType("java/lang/Short");

  private static final Type CHARACTER_TYPE = Type.getObjectType("java/lang/Character");

  private static final Type INTEGER_TYPE = Type.getObjectType("java/lang/Integer");

  private static final Type FLOAT_TYPE = Type.getObjectType("java/lang/Float");

  private static final Type LONG_TYPE = Type.getObjectType("java/lang/Long");

  private static final Type DOUBLE_TYPE = Type.getObjectType("java/lang/Double");

  private static final Type NUMBER_TYPE = Type.getObjectType("java/lang/Number");

  private static final Type OBJECT_TYPE = Type.getObjectType("java/lang/Object");

  private static final Method BOOLEAN_VALUE = Method.getMethod("boolean booleanValue()");

  private static final Method CHAR_VALUE = Method.getMethod("char charValue()");

  private static final Method INT_VALUE = Method.getMethod("int intValue()");

  private static final Method FLOAT_VALUE = Method.getMethod("float floatValue()");

  private static final Method LONG_VALUE = Method.getMethod("long longValue()");

  private static final Method DOUBLE_VALUE = Method.getMethod("double doubleValue()");

  /** Constant for the {@link #math} method. */
  public static final int ADD = Opcodes.IADD;

  /** Constant for the {@link #math} method. */
  public static final int SUB = Opcodes.ISUB;

  /** Constant for the {@link #math} method. */
  public static final int MUL = Opcodes.IMUL;

  /** Constant for the {@link #math} method. */
  public static final int DIV = Opcodes.IDIV;

  /** Constant for the {@link #math} method. */
  public static final int REM = Opcodes.IREM;

  /** Constant for the {@link #math} method. */
  public static final int NEG = Opcodes.INEG;

  /** Constant for the {@link #math} method. */
  public static final int SHL = Opcodes.ISHL;

  /** Constant for the {@link #math} method. */
  public static final int SHR = Opcodes.ISHR;

  /** Constant for the {@link #math} method. */
  public static final int USHR = Opcodes.IUSHR;

  /** Constant for the {@link #math} method. */
  public static final int AND = Opcodes.IAND;

  /** Constant for the {@link #math} method. */
  public static final int OR = Opcodes.IOR;

  /** Constant for the {@link #math} method. */
  public static final int XOR = Opcodes.IXOR;

  /** Constant for the {@link #ifCmp} method. */
  public static final int EQ = Opcodes.IFEQ;

  /** Constant for the {@link #ifCmp} method. */
  public static final int NE = Opcodes.IFNE;

  /** Constant for the {@link #ifCmp} method. */
  public static final int LT = Opcodes.IFLT;

  /** Constant for the {@link #ifCmp} method. */
  public static final int GE = Opcodes.IFGE;

  /** Constant for the {@link #ifCmp} method. */
  public static final int GT = Opcodes.IFGT;

  /** Constant for the {@link #ifCmp} method. */
  public static final int LE = Opcodes.IFLE;

  /** The access flags of the visited method. */
  private final int access;

  /** The name of the visited method. */
  private final String name;

  /** The return type of the visited method. */
  private final Type returnType;

  /** The argument types of the visited method. */
  private final Type[] argumentTypes;

  /** The types of the local variables of the visited method. */
  private final List<Type> localTypes = new ArrayList<>();

  /**
   * Constructs a new {@link GeneratorAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #GeneratorAdapter(int, MethodVisitor, int, String, String)}
   * version.
   *
   * @param methodVisitor the method visitor to which this adapter delegates calls.
   * @param access the method's access flags (see {@link Opcodes}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @throws IllegalStateException if a subclass calls this constructor.
   */
  public GeneratorAdapter(
      final MethodVisitor methodVisitor,
      final int access,
      final String name,
      final String descriptor) {
    this(/* latest api = */ Opcodes.ASM9, methodVisitor, access, name, descriptor);
    if (getClass() != GeneratorAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link GeneratorAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param methodVisitor the method visitor to which this adapter delegates calls.
   * @param access the method's access flags (see {@link Opcodes}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   */
  protected GeneratorAdapter(
      final int api,
      final MethodVisitor methodVisitor,
      final int access,
      final String name,
      final String descriptor) {
    super(api, access, descriptor, methodVisitor);
    this.access = access;
    this.name = name;
    this.returnType = Type.getReturnType(descriptor);
    this.argumentTypes = Type.getArgumentTypes(descriptor);
  }

  /**
   * Constructs a new {@link GeneratorAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #GeneratorAdapter(int, MethodVisitor, int, String, String)}
   * version.
   *
   * @param access access flags of the adapted method.
   * @param method the adapted method.
   * @param methodVisitor the method visitor to which this adapter delegates calls.
   */
  public GeneratorAdapter(
      final int access, final Method method, final MethodVisitor methodVisitor) {
    this(methodVisitor, access, method.getName(), method.getDescriptor());
  }

  /**
   * Constructs a new {@link GeneratorAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #GeneratorAdapter(int, MethodVisitor, int, String, String)}
   * version.
   *
   * @param access access flags of the adapted method.
   * @param method the adapted method.
   * @param signature the signature of the adapted method (may be {@literal null}).
   * @param exceptions the exceptions thrown by the adapted method (may be {@literal null}).
   * @param classVisitor the class visitor to which this adapter delegates calls.
   */
  public GeneratorAdapter(
      final int access,
      final Method method,
      final String signature,
      final Type[] exceptions,
      final ClassVisitor classVisitor) {
    this(
        access,
        method,
        classVisitor.visitMethod(
            access,
            method.getName(),
            method.getDescriptor(),
            signature,
            exceptions == null ? null : getInternalNames(exceptions)));
  }

  /**
   * Returns the internal names of the given types.
   *
   * @param types a set of types.
   * @return the internal names of the given types (see {@link Type#getInternalName()}).
   */
  private static @InternalForm String[] getInternalNames(final Type[] types) {
    String[] names = new String[types.length];
    for (int i = 0; i < names.length; ++i) {
      names[i] = types[i].getInternalName();
    }
    return names;
  }

  public int getAccess() {
    return access;
  }

  public String getName() {
    return name;
  }

  public Type getReturnType() {
    return returnType;
  }

  public Type[] getArgumentTypes() {
    return argumentTypes.clone();
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to push constants on the stack
  // -----------------------------------------------------------------------------------------------

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param value the value to be pushed on the stack.
   */
  public void push(final boolean value) {
    push(value ? 1 : 0);
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param value the value to be pushed on the stack.
   */
  public void push(final int value) {
    if (value >= -1 && value <= 5) {
      mv.visitInsn(Opcodes.ICONST_0 + value);
    } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
      mv.visitIntInsn(Opcodes.BIPUSH, value);
    } else if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
      mv.visitIntInsn(Opcodes.SIPUSH, value);
    } else {
      mv.visitLdcInsn(value);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param value the value to be pushed on the stack.
   */
  public void push(final long value) {
    if (value == 0L || value == 1L) {
      mv.visitInsn(Opcodes.LCONST_0 + (int) value);
    } else {
      mv.visitLdcInsn(value);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param value the value to be pushed on the stack.
   */
  public void push(final float value) {
    int bits = Float.floatToIntBits(value);
    if (bits == 0L || bits == 0x3F800000 || bits == 0x40000000) { // 0..2
      mv.visitInsn(Opcodes.FCONST_0 + (int) value);
    } else {
      mv.visitLdcInsn(value);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param value the value to be pushed on the stack.
   */
  public void push(final double value) {
    long bits = Double.doubleToLongBits(value);
    if (bits == 0L || bits == 0x3FF0000000000000L) { // +0.0d and 1.0d
      mv.visitInsn(Opcodes.DCONST_0 + (int) value);
    } else {
      mv.visitLdcInsn(value);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param value the value to be pushed on the stack. May be {@literal null}.
   */
  public void push(final String value) {
    if (value == null) {
      mv.visitInsn(Opcodes.ACONST_NULL);
    } else {
      mv.visitLdcInsn(value);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param value the value to be pushed on the stack.
   */
  public void push(final Type value) {
    if (value == null) {
      mv.visitInsn(Opcodes.ACONST_NULL);
    } else {
      switch (value.getSort()) {
        case Type.VOID:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Void", "TYPE", CLASS_DESCRIPTOR);
          break;
        case Type.BOOLEAN:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Boolean", "TYPE", CLASS_DESCRIPTOR);
          break;
        case Type.CHAR:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Character", "TYPE", CLASS_DESCRIPTOR);
          break;
        case Type.BYTE:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Byte", "TYPE", CLASS_DESCRIPTOR);
          break;
        case Type.SHORT:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Short", "TYPE", CLASS_DESCRIPTOR);
          break;
        case Type.INT:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Integer", "TYPE", CLASS_DESCRIPTOR);
          break;
        case Type.FLOAT:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Float", "TYPE", CLASS_DESCRIPTOR);
          break;
        case Type.LONG:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Long", "TYPE", CLASS_DESCRIPTOR);
          break;
        case Type.DOUBLE:
          mv.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Double", "TYPE", CLASS_DESCRIPTOR);
          break;
        default:
          mv.visitLdcInsn(value);
          break;
      }
    }
  }

  /**
   * Generates the instruction to push a handle on the stack.
   *
   * @param handle the handle to be pushed on the stack.
   */
  public void push(final Handle handle) {
    if (handle == null) {
      mv.visitInsn(Opcodes.ACONST_NULL);
    } else {
      mv.visitLdcInsn(handle);
    }
  }

  /**
   * Generates the instruction to push a constant dynamic on the stack.
   *
   * @param constantDynamic the constant dynamic to be pushed on the stack.
   */
  public void push(final ConstantDynamic constantDynamic) {
    if (constantDynamic == null) {
      mv.visitInsn(Opcodes.ACONST_NULL);
    } else {
      mv.visitLdcInsn(constantDynamic);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to load and store method arguments
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the index of the given method argument in the frame's local variables array.
   *
   * @param arg the index of a method argument.
   * @return the index of the given method argument in the frame's local variables array.
   */
  private int getArgIndex(final int arg) {
    int index = (access & Opcodes.ACC_STATIC) == 0 ? 1 : 0;
    for (int i = 0; i < arg; i++) {
      index += argumentTypes[i].getSize();
    }
    return index;
  }

  /**
   * Generates the instruction to push a local variable on the stack.
   *
   * @param type the type of the local variable to be loaded.
   * @param index an index in the frame's local variables array.
   */
  private void loadInsn(final Type type, final int index) {
    mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);
  }

  /**
   * Generates the instruction to store the top stack value in a local variable.
   *
   * @param type the type of the local variable to be stored.
   * @param index an index in the frame's local variables array.
   */
  private void storeInsn(final Type type, final int index) {
    mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), index);
  }

  /** Generates the instruction to load 'this' on the stack. */
  public void loadThis() {
    if ((access & Opcodes.ACC_STATIC) != 0) {
      throw new IllegalStateException("no 'this' pointer within static method");
    }
    mv.visitVarInsn(Opcodes.ALOAD, 0);
  }

  /**
   * Generates the instruction to load the given method argument on the stack.
   *
   * @param arg the index of a method argument.
   */
  public void loadArg(final int arg) {
    loadInsn(argumentTypes[arg], getArgIndex(arg));
  }

  /**
   * Generates the instructions to load the given method arguments on the stack.
   *
   * @param arg the index of the first method argument to be loaded.
   * @param count the number of method arguments to be loaded.
   */
  public void loadArgs(final int arg, final int count) {
    int index = getArgIndex(arg);
    for (int i = 0; i < count; ++i) {
      Type argumentType = argumentTypes[arg + i];
      loadInsn(argumentType, index);
      index += argumentType.getSize();
    }
  }

  /** Generates the instructions to load all the method arguments on the stack. */
  public void loadArgs() {
    loadArgs(0, argumentTypes.length);
  }

  /**
   * Generates the instructions to load all the method arguments on the stack, as a single object
   * array.
   */
  public void loadArgArray() {
    push(argumentTypes.length);
    newArray(OBJECT_TYPE);
    for (int i = 0; i < argumentTypes.length; i++) {
      dup();
      push(i);
      loadArg(i);
      box(argumentTypes[i]);
      arrayStore(OBJECT_TYPE);
    }
  }

  /**
   * Generates the instruction to store the top stack value in the given method argument.
   *
   * @param arg the index of a method argument.
   */
  public void storeArg(final int arg) {
    storeInsn(argumentTypes[arg], getArgIndex(arg));
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to load and store local variables
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the type of the given local variable.
   *
   * @param local a local variable identifier, as returned by {@link
   *     LocalVariablesSorter#newLocal(Type)}.
   * @return the type of the given local variable.
   */
  public Type getLocalType(final int local) {
    return localTypes.get(local - firstLocal);
  }

  @Override
  protected void setLocalType(final int local, final Type type) {
    int index = local - firstLocal;
    while (localTypes.size() < index + 1) {
      localTypes.add(null);
    }
    localTypes.set(index, type);
  }

  /**
   * Generates the instruction to load the given local variable on the stack.
   *
   * @param local a local variable identifier, as returned by {@link
   *     LocalVariablesSorter#newLocal(Type)}.
   */
  public void loadLocal(final int local) {
    loadInsn(getLocalType(local), local);
  }

  /**
   * Generates the instruction to load the given local variable on the stack.
   *
   * @param local a local variable identifier, as returned by {@link
   *     LocalVariablesSorter#newLocal(Type)}.
   * @param type the type of this local variable.
   */
  public void loadLocal(final int local, final Type type) {
    setLocalType(local, type);
    loadInsn(type, local);
  }

  /**
   * Generates the instruction to store the top stack value in the given local variable.
   *
   * @param local a local variable identifier, as returned by {@link
   *     LocalVariablesSorter#newLocal(Type)}.
   */
  public void storeLocal(final int local) {
    storeInsn(getLocalType(local), local);
  }

  /**
   * Generates the instruction to store the top stack value in the given local variable.
   *
   * @param local a local variable identifier, as returned by {@link
   *     LocalVariablesSorter#newLocal(Type)}.
   * @param type the type of this local variable.
   */
  public void storeLocal(final int local, final Type type) {
    setLocalType(local, type);
    storeInsn(type, local);
  }

  /**
   * Generates the instruction to load an element from an array.
   *
   * @param type the type of the array element to be loaded.
   */
  public void arrayLoad(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IALOAD));
  }

  /**
   * Generates the instruction to store an element in an array.
   *
   * @param type the type of the array element to be stored.
   */
  public void arrayStore(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IASTORE));
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to manage the stack
  // -----------------------------------------------------------------------------------------------

  /** Generates a POP instruction. */
  public void pop() {
    mv.visitInsn(Opcodes.POP);
  }

  /** Generates a POP2 instruction. */
  public void pop2() {
    mv.visitInsn(Opcodes.POP2);
  }

  /** Generates a DUP instruction. */
  public void dup() {
    mv.visitInsn(Opcodes.DUP);
  }

  /** Generates a DUP2 instruction. */
  public void dup2() {
    mv.visitInsn(Opcodes.DUP2);
  }

  /** Generates a DUP_X1 instruction. */
  public void dupX1() {
    mv.visitInsn(Opcodes.DUP_X1);
  }

  /** Generates a DUP_X2 instruction. */
  public void dupX2() {
    mv.visitInsn(Opcodes.DUP_X2);
  }

  /** Generates a DUP2_X1 instruction. */
  public void dup2X1() {
    mv.visitInsn(Opcodes.DUP2_X1);
  }

  /** Generates a DUP2_X2 instruction. */
  public void dup2X2() {
    mv.visitInsn(Opcodes.DUP2_X2);
  }

  /** Generates a SWAP instruction. */
  public void swap() {
    mv.visitInsn(Opcodes.SWAP);
  }

  /**
   * Generates the instructions to swap the top two stack values.
   *
   * @param prev type of the top - 1 stack value.
   * @param type type of the top stack value.
   */
  public void swap(final Type prev, final Type type) {
    if (type.getSize() == 1) {
      if (prev.getSize() == 1) {
        swap(); // Same as dupX1 pop.
      } else {
        dupX2();
        pop();
      }
    } else {
      if (prev.getSize() == 1) {
        dup2X1();
        pop2();
      } else {
        dup2X2();
        pop2();
      }
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to do mathematical and logical operations
  // -----------------------------------------------------------------------------------------------

  /**
   * Generates the instruction to do the specified mathematical or logical operation.
   *
   * @param op a mathematical or logical operation. Must be one of ADD, SUB, MUL, DIV, REM, NEG,
   *     SHL, SHR, USHR, AND, OR, XOR.
   * @param type the type of the operand(s) for this operation.
   */
  public void math(final int op, final Type type) {
    mv.visitInsn(type.getOpcode(op));
  }

  /** Generates the instructions to compute the bitwise negation of the top stack value. */
  public void not() {
    mv.visitInsn(Opcodes.ICONST_1);
    mv.visitInsn(Opcodes.IXOR);
  }

  /**
   * Generates the instruction to increment the given local variable.
   *
   * @param local the local variable to be incremented.
   * @param amount the amount by which the local variable must be incremented.
   */
  public void iinc(final int local, final int amount) {
    mv.visitIincInsn(local, amount);
  }

  /**
   * Generates the instructions to cast a numerical value from one type to another.
   *
   * @param from the type of the top stack value
   * @param to the type into which this value must be cast.
   */
  public void cast(final Type from, final Type to) {
    if (from != to) {
      if (from.getSort() < Type.BOOLEAN
          || from.getSort() > Type.DOUBLE
          || to.getSort() < Type.BOOLEAN
          || to.getSort() > Type.DOUBLE) {
        throw new IllegalArgumentException("Cannot cast from " + from + " to " + to);
      }
      InstructionAdapter.cast(mv, from, to);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to do boxing and unboxing operations
  // -----------------------------------------------------------------------------------------------

  private static Type getBoxedType(final Type type) {
    switch (type.getSort()) {
      case Type.BYTE:
        return BYTE_TYPE;
      case Type.BOOLEAN:
        return BOOLEAN_TYPE;
      case Type.SHORT:
        return SHORT_TYPE;
      case Type.CHAR:
        return CHARACTER_TYPE;
      case Type.INT:
        return INTEGER_TYPE;
      case Type.FLOAT:
        return FLOAT_TYPE;
      case Type.LONG:
        return LONG_TYPE;
      case Type.DOUBLE:
        return DOUBLE_TYPE;
      default:
        return type;
    }
  }

  /**
   * Generates the instructions to box the top stack value. This value is replaced by its boxed
   * equivalent on top of the stack.
   *
   * @param type the type of the top stack value.
   */
  public void box(final Type type) {
    if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {
      return;
    }
    if (type == Type.VOID_TYPE) {
      push((String) null);
    } else {
      Type boxedType = getBoxedType(type);
      newInstance(boxedType);
      if (type.getSize() == 2) {
        // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o
        dupX2();
        dupX2();
        pop();
      } else {
        // p -> po -> opo -> oop -> o
        dupX1();
        swap();
      }
      invokeConstructor(boxedType, new Method("<init>", Type.VOID_TYPE, new Type[] {type}));
    }
  }

  /**
   * Generates the instructions to box the top stack value using Java 5's valueOf() method. This
   * value is replaced by its boxed equivalent on top of the stack.
   *
   * @param type the type of the top stack value.
   */
  public void valueOf(final Type type) {
    if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {
      return;
    }
    if (type == Type.VOID_TYPE) {
      push((String) null);
    } else {
      Type boxedType = getBoxedType(type);
      invokeStatic(boxedType, new Method("valueOf", boxedType, new Type[] {type}));
    }
  }

  /**
   * Generates the instructions to unbox the top stack value. This value is replaced by its unboxed
   * equivalent on top of the stack.
   *
   * @param type the type of the top stack value.
   */
  public void unbox(final Type type) {
    Type boxedType = NUMBER_TYPE;
    Method unboxMethod;
    switch (type.getSort()) {
      case Type.VOID:
        return;
      case Type.CHAR:
        boxedType = CHARACTER_TYPE;
        unboxMethod = CHAR_VALUE;
        break;
      case Type.BOOLEAN:
        boxedType = BOOLEAN_TYPE;
        unboxMethod = BOOLEAN_VALUE;
        break;
      case Type.DOUBLE:
        unboxMethod = DOUBLE_VALUE;
        break;
      case Type.FLOAT:
        unboxMethod = FLOAT_VALUE;
        break;
      case Type.LONG:
        unboxMethod = LONG_VALUE;
        break;
      case Type.INT:
      case Type.SHORT:
      case Type.BYTE:
        unboxMethod = INT_VALUE;
        break;
      default:
        unboxMethod = null;
        break;
    }
    if (unboxMethod == null) {
      checkCast(type);
    } else {
      checkCast(boxedType);
      invokeVirtual(boxedType, unboxMethod);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to jump to other instructions
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link Label}.
   *
   * @return a new {@link Label}.
   */
  public Label newLabel() {
    return new Label();
  }

  /**
   * Marks the current code position with the given label.
   *
   * @param label a label.
   */
  public void mark(final Label label) {
    mv.visitLabel(label);
  }

  /**
   * Marks the current code position with a new label.
   *
   * @return the label that was created to mark the current code position.
   */
  public Label mark() {
    Label label = new Label();
    mv.visitLabel(label);
    return label;
  }

  /**
   * Generates the instructions to jump to a label based on the comparison of the top two stack
   * values.
   *
   * @param type the type of the top two stack values.
   * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT, LE.
   * @param label where to jump if the comparison result is {@literal true}.
   */
  public void ifCmp(final Type type, final int mode, final Label label) {
    switch (type.getSort()) {
      case Type.LONG:
        mv.visitInsn(Opcodes.LCMP);
        break;
      case Type.DOUBLE:
        mv.visitInsn(mode == GE || mode == GT ? Opcodes.DCMPL : Opcodes.DCMPG);
        break;
      case Type.FLOAT:
        mv.visitInsn(mode == GE || mode == GT ? Opcodes.FCMPL : Opcodes.FCMPG);
        break;
      case Type.ARRAY:
      case Type.OBJECT:
        if (mode == EQ) {
          mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);
          return;
        } else if (mode == NE) {
          mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);
          return;
        } else {
          throw new IllegalArgumentException("Bad comparison for type " + type);
        }
      default:
        int intOp = -1;
        switch (mode) {
          case EQ:
            intOp = Opcodes.IF_ICMPEQ;
            break;
          case NE:
            intOp = Opcodes.IF_ICMPNE;
            break;
          case GE:
            intOp = Opcodes.IF_ICMPGE;
            break;
          case LT:
            intOp = Opcodes.IF_ICMPLT;
            break;
          case LE:
            intOp = Opcodes.IF_ICMPLE;
            break;
          case GT:
            intOp = Opcodes.IF_ICMPGT;
            break;
          default:
            throw new IllegalArgumentException("Bad comparison mode " + mode);
        }
        mv.visitJumpInsn(intOp, label);
        return;
    }
    mv.visitJumpInsn(mode, label);
  }

  /**
   * Generates the instructions to jump to a label based on the comparison of the top two integer
   * stack values.
   *
   * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT, LE.
   * @param label where to jump if the comparison result is {@literal true}.
   */
  public void ifICmp(final int mode, final Label label) {
    ifCmp(Type.INT_TYPE, mode, label);
  }

  /**
   * Generates the instructions to jump to a label based on the comparison of the top integer stack
   * value with zero.
   *
   * @param mode how these values must be compared. One of EQ, NE, LT, GE, GT, LE.
   * @param label where to jump if the comparison result is {@literal true}.
   */
  public void ifZCmp(final int mode, final Label label) {
    mv.visitJumpInsn(mode, label);
  }

  /**
   * Generates the instruction to jump to the given label if the top stack value is null.
   *
   * @param label where to jump if the condition is {@literal true}.
   */
  public void ifNull(final Label label) {
    mv.visitJumpInsn(Opcodes.IFNULL, label);
  }

  /**
   * Generates the instruction to jump to the given label if the top stack value is not null.
   *
   * @param label where to jump if the condition is {@literal true}.
   */
  public void ifNonNull(final Label label) {
    mv.visitJumpInsn(Opcodes.IFNONNULL, label);
  }

  /**
   * Generates the instruction to jump to the given label.
   *
   * @param label where to jump if the condition is {@literal true}.
   */
  public void goTo(final Label label) {
    mv.visitJumpInsn(Opcodes.GOTO, label);
  }

  /**
   * Generates a RET instruction.
   *
   * @param local a local variable identifier, as returned by {@link
   *     LocalVariablesSorter#newLocal(Type)}.
   */
  public void ret(final int local) {
    mv.visitVarInsn(Opcodes.RET, local);
  }

  /**
   * Generates the instructions for a switch statement.
   *
   * @param keys the switch case keys.
   * @param generator a generator to generate the code for the switch cases.
   */
  public void tableSwitch(final int[] keys, final TableSwitchGenerator generator) {
    float density;
    if (keys.length == 0) {
      density = 0;
    } else {
      density = (float) keys.length / (keys[keys.length - 1] - keys[0] + 1);
    }
    tableSwitch(keys, generator, density >= 0.5f);
  }

  /**
   * Generates the instructions for a switch statement.
   *
   * @param keys the switch case keys.
   * @param generator a generator to generate the code for the switch cases.
   * @param useTable {@literal true} to use a TABLESWITCH instruction, or {@literal false} to use a
   *     LOOKUPSWITCH instruction.
   */
  public void tableSwitch(
      final int[] keys, final TableSwitchGenerator generator, final boolean useTable) {
    for (int i = 1; i < keys.length; ++i) {
      if (keys[i] < keys[i - 1]) {
        throw new IllegalArgumentException("keys must be sorted in ascending order");
      }
    }
    Label defaultLabel = newLabel();
    Label endLabel = newLabel();
    if (keys.length > 0) {
      int numKeys = keys.length;
      if (useTable) {
        int min = keys[0];
        int max = keys[numKeys - 1];
        int range = max - min + 1;
        Label[] labels = new Label[range];
        Arrays.fill(labels, defaultLabel);
        for (int i = 0; i < numKeys; ++i) {
          labels[keys[i] - min] = newLabel();
        }
        mv.visitTableSwitchInsn(min, max, defaultLabel, labels);
        for (int i = 0; i < range; ++i) {
          Label label = labels[i];
          if (label != defaultLabel) {
            mark(label);
            generator.generateCase(i + min, endLabel);
          }
        }
      } else {
        Label[] labels = new Label[numKeys];
        for (int i = 0; i < numKeys; ++i) {
          labels[i] = newLabel();
        }
        mv.visitLookupSwitchInsn(defaultLabel, keys, labels);
        for (int i = 0; i < numKeys; ++i) {
          mark(labels[i]);
          generator.generateCase(keys[i], endLabel);
        }
      }
    }
    mark(defaultLabel);
    generator.generateDefault();
    mark(endLabel);
  }

  /** Generates the instruction to return the top stack value to the caller. */
  public void returnValue() {
    mv.visitInsn(returnType.getOpcode(Opcodes.IRETURN));
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to load and store fields
  // -----------------------------------------------------------------------------------------------

  /**
   * Generates a get field or set field instruction.
   *
   * @param opcode the instruction's opcode.
   * @param ownerType the class in which the field is defined.
   * @param name the name of the field.
   * @param fieldType the type of the field.
   */
  private void fieldInsn(
      final int opcode, final Type ownerType, final String name, final Type fieldType) {
    mv.visitFieldInsn(opcode, ownerType.getInternalName(), name, fieldType.getDescriptor());
  }

  /**
   * Generates the instruction to push the value of a static field on the stack.
   *
   * @param owner the class in which the field is defined.
   * @param name the name of the field.
   * @param type the type of the field.
   */
  public void getStatic(final Type owner, final String name, final Type type) {
    fieldInsn(Opcodes.GETSTATIC, owner, name, type);
  }

  /**
   * Generates the instruction to store the top stack value in a static field.
   *
   * @param owner the class in which the field is defined.
   * @param name the name of the field.
   * @param type the type of the field.
   */
  public void putStatic(final Type owner, final String name, final Type type) {
    fieldInsn(Opcodes.PUTSTATIC, owner, name, type);
  }

  /**
   * Generates the instruction to push the value of a non static field on the stack.
   *
   * @param owner the class in which the field is defined.
   * @param name the name of the field.
   * @param type the type of the field.
   */
  public void getField(final Type owner, final String name, final Type type) {
    fieldInsn(Opcodes.GETFIELD, owner, name, type);
  }

  /**
   * Generates the instruction to store the top stack value in a non static field.
   *
   * @param owner the class in which the field is defined.
   * @param name the name of the field.
   * @param type the type of the field.
   */
  public void putField(final Type owner, final String name, final Type type) {
    fieldInsn(Opcodes.PUTFIELD, owner, name, type);
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to invoke methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Generates an invoke method instruction.
   *
   * @param opcode the instruction's opcode.
   * @param type the class in which the method is defined.
   * @param method the method to be invoked.
   * @param isInterface whether the 'type' class is an interface or not.
   */
  private void invokeInsn(
      final int opcode, final Type type, final Method method, final boolean isInterface) {
    String owner = type.getSort() == Type.ARRAY ? type.getDescriptor() : type.getInternalName();
    mv.visitMethodInsn(opcode, owner, method.getName(), method.getDescriptor(), isInterface);
  }

  /**
   * Generates the instruction to invoke a normal method.
   *
   * @param owner the class in which the method is defined.
   * @param method the method to be invoked.
   */
  public void invokeVirtual(final Type owner, final Method method) {
    invokeInsn(Opcodes.INVOKEVIRTUAL, owner, method, false);
  }

  /**
   * Generates the instruction to invoke a constructor.
   *
   * @param type the class in which the constructor is defined.
   * @param method the constructor to be invoked.
   */
  public void invokeConstructor(final Type type, final Method method) {
    invokeInsn(Opcodes.INVOKESPECIAL, type, method, false);
  }

  /**
   * Generates the instruction to invoke a static method.
   *
   * @param owner the class in which the method is defined.
   * @param method the method to be invoked.
   */
  public void invokeStatic(final Type owner, final Method method) {
    invokeInsn(Opcodes.INVOKESTATIC, owner, method, false);
  }

  /**
   * Generates the instruction to invoke an interface method.
   *
   * @param owner the class in which the method is defined.
   * @param method the method to be invoked.
   */
  public void invokeInterface(final Type owner, final Method method) {
    invokeInsn(Opcodes.INVOKEINTERFACE, owner, method, true);
  }

  /**
   * Generates an invokedynamic instruction.
   *
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param bootstrapMethodHandle the bootstrap method.
   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be
   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link
   *     Type} or {@link Handle} value. This method is allowed to modify the content of the array so
   *     a caller should expect that this array may change.
   */
  public void invokeDynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
  }

  // -----------------------------------------------------------------------------------------------
  // Instructions to create objects and arrays
  // -----------------------------------------------------------------------------------------------

  /**
   * Generates a type dependent instruction.
   *
   * @param opcode the instruction's opcode.
   * @param type the instruction's operand.
   */
  private void typeInsn(final int opcode, final Type type) {
    mv.visitTypeInsn(opcode, type.getInternalName());
  }

  /**
   * Generates the instruction to create a new object.
   *
   * @param type the class of the object to be created.
   */
  public void newInstance(final Type type) {
    typeInsn(Opcodes.NEW, type);
  }

  /**
   * Generates the instruction to create a new array.
   *
   * @param type the type of the array elements.
   */
  public void newArray(final Type type) {
    InstructionAdapter.newarray(mv, type);
  }

  // -----------------------------------------------------------------------------------------------
  // Miscellaneous instructions
  // -----------------------------------------------------------------------------------------------

  /** Generates the instruction to compute the length of an array. */
  public void arrayLength() {
    mv.visitInsn(Opcodes.ARRAYLENGTH);
  }

  /** Generates the instruction to throw an exception. */
  public void throwException() {
    mv.visitInsn(Opcodes.ATHROW);
  }

  /**
   * Generates the instructions to create and throw an exception. The exception class must have a
   * constructor with a single String argument.
   *
   * @param type the class of the exception to be thrown.
   * @param message the detailed message of the exception.
   */
  public void throwException(final Type type, final String message) {
    newInstance(type);
    dup();
    push(message);
    invokeConstructor(type, Method.getMethod("void <init> (String)"));
    throwException();
  }

  /**
   * Generates the instruction to check that the top stack value is of the given type.
   *
   * @param type a class or interface type.
   */
  public void checkCast(final Type type) {
    if (!type.equals(OBJECT_TYPE)) {
      typeInsn(Opcodes.CHECKCAST, type);
    }
  }

  /**
   * Generates the instruction to test if the top stack value is of the given type.
   *
   * @param type a class or interface type.
   */
  public void instanceOf(final Type type) {
    typeInsn(Opcodes.INSTANCEOF, type);
  }

  /** Generates the instruction to get the monitor of the top stack value. */
  public void monitorEnter() {
    mv.visitInsn(Opcodes.MONITORENTER);
  }

  /** Generates the instruction to release the monitor of the top stack value. */
  public void monitorExit() {
    mv.visitInsn(Opcodes.MONITOREXIT);
  }

  // -----------------------------------------------------------------------------------------------
  // Non instructions
  // -----------------------------------------------------------------------------------------------

  /** Marks the end of the visited method. */
  public void endMethod() {
    if ((access & Opcodes.ACC_ABSTRACT) == 0) {
      mv.visitMaxs(0, 0);
    }
    mv.visitEnd();
  }

  /**
   * Marks the start of an exception handler.
   *
   * @param start beginning of the exception handler's scope (inclusive).
   * @param end end of the exception handler's scope (exclusive).
   * @param exception internal name of the type of exceptions handled by the handler (see {@link
   *     Type#getInternalName()}).
   */
  public void catchException(final Label start, final Label end, final Type exception) {
    Label catchLabel = new Label();
    if (exception == null) {
      mv.visitTryCatchBlock(start, end, catchLabel, null);
    } else {
      mv.visitTryCatchBlock(start, end, catchLabel, exception.getInternalName());
    }
    mark(catchLabel);
  }
}


package org.objectweb.asm.commons;

import org.objectweb.asm.Attribute;
import org.objectweb.asm.ByteVector;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;

/**
 * A ModuleResolution attribute. This attribute is specific to the OpenJDK and may change in the
 * future.
 *
 * @author Remi Forax
 */
public final class ModuleResolutionAttribute extends Attribute {
  /**
   * The resolution state of a module meaning that the module is not available from the class-path
   * by default.
   */
  public static final int RESOLUTION_DO_NOT_RESOLVE_BY_DEFAULT = 1;

  /** The resolution state of a module meaning the module is marked as deprecated. */
  public static final int RESOLUTION_WARN_DEPRECATED = 2;

  /**
   * The resolution state of a module meaning the module is marked as deprecated and will be removed
   * in a future release.
   */
  public static final int RESOLUTION_WARN_DEPRECATED_FOR_REMOVAL = 4;

  /**
   * The resolution state of a module meaning the module is not yet standardized, so in incubating
   * mode.
   */
  public static final int RESOLUTION_WARN_INCUBATING = 8;

  /**
   * The resolution state of the module. Must be one of {@link #RESOLUTION_WARN_DEPRECATED}, {@link
   * #RESOLUTION_WARN_DEPRECATED_FOR_REMOVAL}, and {@link #RESOLUTION_WARN_INCUBATING}.
   */
  public int resolution;

  /**
   * Constructs a new {@link ModuleResolutionAttribute}.
   *
   * @param resolution the resolution state of the module. Must be one of {@link
   *     #RESOLUTION_WARN_DEPRECATED}, {@link #RESOLUTION_WARN_DEPRECATED_FOR_REMOVAL}, and {@link
   *     #RESOLUTION_WARN_INCUBATING}.
   */
  public ModuleResolutionAttribute(final int resolution) {
    super("ModuleResolution");
    this.resolution = resolution;
  }

  /**
   * Constructs an empty {@link ModuleResolutionAttribute}. This object can be passed as a prototype
   * to the {@link ClassReader#accept(org.objectweb.asm.ClassVisitor, Attribute[], int)} method.
   */
  public ModuleResolutionAttribute() {
    this(0);
  }

  @Override
  protected Attribute read(
      final ClassReader classReader,
      final int offset,
      final int length,
      final char[] charBuffer,
      final int codeOffset,
      final Label[] labels) {
    return new ModuleResolutionAttribute(classReader.readUnsignedShort(offset));
  }

  @Override
  protected ByteVector write(
      final ClassWriter classWriter,
      final byte[] code,
      final int codeLength,
      final int maxStack,
      final int maxLocals) {
    ByteVector byteVector = new ByteVector();
    byteVector.putShort(resolution);
    return byteVector;
  }
}


package org.objectweb.asm.commons;

import java.util.Collections;
import java.util.Comparator;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TryCatchBlockNode;

/**
 * A {@link MethodVisitor} adapter to sort the exception handlers. The handlers are sorted in a
 * method innermost-to-outermost. This allows the programmer to add handlers without worrying about
 * ordering them correctly with respect to existing, in-code handlers.
 *
 * <p>Behavior is only defined for properly-nested handlers. If any "try" blocks overlap (something
 * that isn't possible in Java code) then this may not do what you want. In fact, this adapter just
 * sorts by the length of the "try" block, taking advantage of the fact that a given try block must
 * be larger than any block it contains).
 *
 * @author Adrian Sampson
 */
public class TryCatchBlockSorter extends MethodNode {

  /**
   * Constructs a new {@link TryCatchBlockSorter}.
   *
   * @param methodVisitor the method visitor to which this visitor must delegate method calls. May
   *     be {@literal null}.
   * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the method is synthetic and/or deprecated.
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link org.objectweb.asm.Type}).
   * @param signature the method's signature. May be {@literal null} if the method parameters,
   *     return type and exceptions do not use generic types.
   * @param exceptions the internal names of the method's exception classes (see {@link
   *     org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  public TryCatchBlockSorter(
      final MethodVisitor methodVisitor,
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String @Nullable [] exceptions) {
    this(
        /* latest api = */ Opcodes.ASM9,
        methodVisitor,
        access,
        name,
        descriptor,
        signature,
        exceptions);
    if (getClass() != TryCatchBlockSorter.class) {
      throw new IllegalStateException();
    }
  }

  protected TryCatchBlockSorter(
      final int api,
      final MethodVisitor methodVisitor,
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final String[] exceptions) {
    super(api, access, name, descriptor, signature, exceptions);
    this.mv = methodVisitor;
  }

  @Override
  public void visitEnd() {
    // Sort the TryCatchBlockNode elements by the length of their "try" block.
    Collections.sort(
        tryCatchBlocks,
        new Comparator<TryCatchBlockNode>() {

          @Override
          public int compare(
              final TryCatchBlockNode tryCatchBlockNode1,
              final TryCatchBlockNode tryCatchBlockNode2) {
            return blockLength(tryCatchBlockNode1) - blockLength(tryCatchBlockNode2);
          }

          private int blockLength(final TryCatchBlockNode tryCatchBlockNode) {
            int startIndex = instructions.indexOf(tryCatchBlockNode.start);
            int endIndex = instructions.indexOf(tryCatchBlockNode.end);
            return endIndex - startIndex;
          }
        });
    // Update the 'target' of each try catch block annotation.
    for (int i = 0; i < tryCatchBlocks.size(); ++i) {
      tryCatchBlocks.get(i).updateIndex(i);
    }
    if (mv != null) {
      accept(mv);
    }
  }
}

package org.objectweb.asm.commons;

import org.objectweb.asm.Label;

/**
 * A code generator for switch statements.
 *
 * @author Juozas Baliuka
 * @author Chris Nokleberg
 * @author Eric Bruneton
 */
public interface TableSwitchGenerator {

  /**
   * Generates the code for a switch case.
   *
   * @param key the switch case key.
   * @param end a label that corresponds to the end of the switch statement.
   */
  void generateCase(int key, Label end);

  /** Generates the code for the default switch case. */
  void generateDefault();
}


package org.objectweb.asm.commons;

import java.util.ArrayList;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.signature.SignatureVisitor;

/**
 * A {@link SignatureVisitor} that remaps types with a {@link Remapper}.
 *
 * @author Eugene Kuleshov
 */
public class SignatureRemapper extends SignatureVisitor {

  private final SignatureVisitor signatureVisitor;

  private final Remapper remapper;

  private ArrayList<String> classNames = new ArrayList<>();

  /**
   * Constructs a new {@link SignatureRemapper}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #SignatureRemapper(int,SignatureVisitor,Remapper)} version.
   *
   * @param signatureVisitor the signature visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited signature.
   */
  public SignatureRemapper(final SignatureVisitor signatureVisitor, final Remapper remapper) {
    this(/* latest api = */ Opcodes.ASM9, signatureVisitor, remapper);
  }

  /**
   * Constructs a new {@link SignatureRemapper}.
   *
   * @param api the ASM API version supported by this remapper. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param signatureVisitor the signature visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited signature.
   */
  protected SignatureRemapper(
      final int api, final SignatureVisitor signatureVisitor, final Remapper remapper) {
    super(api);
    this.signatureVisitor = signatureVisitor;
    this.remapper = remapper;
  }

  @Override
  public void visitClassType(final String name) {
    classNames.add(name);
    signatureVisitor.visitClassType(remapper.mapType(name));
  }

  @Override
  public void visitInnerClassType(final String name) {
    String outerClassName = classNames.remove(classNames.size() - 1);
    String className = outerClassName + '$' + name;
    classNames.add(className);
    String remappedOuter = remapper.mapType(outerClassName) + '$';
    String remappedName = remapper.mapType(className);
    int index =
        remappedName.startsWith(remappedOuter)
            ? remappedOuter.length()
            : remappedName.lastIndexOf('$') + 1;
    signatureVisitor.visitInnerClassType(remappedName.substring(index));
  }

  @Override
  public void visitFormalTypeParameter(final String name) {
    signatureVisitor.visitFormalTypeParameter(name);
  }

  @Override
  public void visitTypeVariable(final String name) {
    signatureVisitor.visitTypeVariable(name);
  }

  @Override
  public SignatureVisitor visitArrayType() {
    signatureVisitor.visitArrayType();
    return this;
  }

  @Override
  public void visitBaseType(final char descriptor) {
    signatureVisitor.visitBaseType(descriptor);
  }

  @Override
  public SignatureVisitor visitClassBound() {
    signatureVisitor.visitClassBound();
    return this;
  }

  @Override
  public SignatureVisitor visitExceptionType() {
    signatureVisitor.visitExceptionType();
    return this;
  }

  @Override
  public SignatureVisitor visitInterface() {
    signatureVisitor.visitInterface();
    return this;
  }

  @Override
  public SignatureVisitor visitInterfaceBound() {
    signatureVisitor.visitInterfaceBound();
    return this;
  }

  @Override
  public SignatureVisitor visitParameterType() {
    signatureVisitor.visitParameterType();
    return this;
  }

  @Override
  public SignatureVisitor visitReturnType() {
    signatureVisitor.visitReturnType();
    return this;
  }

  @Override
  public SignatureVisitor visitSuperclass() {
    signatureVisitor.visitSuperclass();
    return this;
  }

  @Override
  public void visitTypeArgument() {
    signatureVisitor.visitTypeArgument();
  }

  @Override
  public SignatureVisitor visitTypeArgument(final char wildcard) {
    signatureVisitor.visitTypeArgument(wildcard);
    return this;
  }

  @Override
  public void visitEnd() {
    signatureVisitor.visitEnd();
    classNames.remove(classNames.size() - 1);
  }
}


package org.objectweb.asm.commons;

import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A {@link ModuleVisitor} that remaps types with a {@link Remapper}.
 *
 * @author Remi Forax
 */
public class ModuleRemapper extends ModuleVisitor {

  /** The remapper used to remap the types in the visited module. */
  protected final Remapper remapper;

  /**
   * Constructs a new {@link ModuleRemapper}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #ModuleRemapper(int,ModuleVisitor,Remapper)} version.
   *
   * @param moduleVisitor the module visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited module.
   */
  public ModuleRemapper(final ModuleVisitor moduleVisitor, final Remapper remapper) {
    this(/* latest api = */ Opcodes.ASM9, moduleVisitor, remapper);
  }

  /**
   * Constructs a new {@link ModuleRemapper}.
   *
   * @param api the ASM API version supported by this remapper. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param moduleVisitor the module visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited module.
   */
  protected ModuleRemapper(
      final int api, final ModuleVisitor moduleVisitor, final Remapper remapper) {
    super(api, moduleVisitor);
    this.remapper = remapper;
  }

  @Override
  public void visitMainClass(final String mainClass) {
    super.visitMainClass(remapper.mapType(mainClass));
  }

  @Override
  public void visitPackage(final String packaze) {
    super.visitPackage(remapper.mapPackageName(packaze));
  }

  @Override
  public void visitRequire(final String module, final int access, final String version) {
    super.visitRequire(remapper.mapModuleName(module), access, version);
  }

  @Override
  public void visitExport(final String packaze, final int access, final String... modules) {
    String[] remappedModules = null;
    if (modules != null) {
      remappedModules = new String[modules.length];
      for (int i = 0; i < modules.length; ++i) {
        remappedModules[i] = remapper.mapModuleName(modules[i]);
      }
    }
    super.visitExport(remapper.mapPackageName(packaze), access, remappedModules);
  }

  @Override
  public void visitOpen(final String packaze, final int access, final String... modules) {
    String[] remappedModules = null;
    if (modules != null) {
      remappedModules = new String[modules.length];
      for (int i = 0; i < modules.length; ++i) {
        remappedModules[i] = remapper.mapModuleName(modules[i]);
      }
    }
    super.visitOpen(remapper.mapPackageName(packaze), access, remappedModules);
  }

  @Override
  public void visitUse(final String service) {
    super.visitUse(remapper.mapType(service));
  }

  @Override
  public void visitProvide(final String service, final String... providers) {
    String[] remappedProviders = new String[providers.length];
    for (int i = 0; i < providers.length; ++i) {
      remappedProviders[i] = remapper.mapType(providers[i]);
    }
    super.visitProvide(remapper.mapType(service), remappedProviders);
  }
}


package org.objectweb.asm.commons;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Opcodes;

/**
 * An {@link AnnotationVisitor} that remaps types with a {@link Remapper}.
 *
 * @author Eugene Kuleshov
 */
public class AnnotationRemapper extends AnnotationVisitor {

  /**
   * The descriptor of the visited annotation. May be {@literal null}, for instance for
   * AnnotationDefault.
   */
  protected final String descriptor;

  /** The remapper used to remap the types in the visited annotation. */
  protected final Remapper remapper;

  /**
   * Constructs a new {@link AnnotationRemapper}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #AnnotationRemapper(int,AnnotationVisitor,Remapper)} version.
   *
   * @param annotationVisitor the annotation visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited annotation.
   * @deprecated use {@link #AnnotationRemapper(String, AnnotationVisitor, Remapper)} instead.
   */
  @Deprecated
  public AnnotationRemapper(final AnnotationVisitor annotationVisitor, final Remapper remapper) {
    this(/* descriptor= */ null, annotationVisitor, remapper);
  }

  /**
   * Constructs a new {@link AnnotationRemapper}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #AnnotationRemapper(int,String,AnnotationVisitor,Remapper)}
   * version.
   *
   * @param descriptor the descriptor of the visited annotation. May be {@literal null}.
   * @param annotationVisitor the annotation visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited annotation.
   */
  public AnnotationRemapper(
      final String descriptor, final AnnotationVisitor annotationVisitor, final Remapper remapper) {
    this(/* latest api = */ Opcodes.ASM9, descriptor, annotationVisitor, remapper);
  }

  /**
   * Constructs a new {@link AnnotationRemapper}.
   *
   * @param api the ASM API version supported by this remapper. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param annotationVisitor the annotation visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited annotation.
   * @deprecated use {@link #AnnotationRemapper(int, String, AnnotationVisitor, Remapper)} instead.
   */
  @Deprecated
  protected AnnotationRemapper(
      final int api, final AnnotationVisitor annotationVisitor, final Remapper remapper) {
    this(api, /* descriptor= */ null, annotationVisitor, remapper);
  }

  /**
   * Constructs a new {@link AnnotationRemapper}.
   *
   * @param api the ASM API version supported by this remapper. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param descriptor the descriptor of the visited annotation. May be {@literal null}.
   * @param annotationVisitor the annotation visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited annotation.
   */
  protected AnnotationRemapper(
      final int api,
      final String descriptor,
      final AnnotationVisitor annotationVisitor,
      final Remapper remapper) {
    super(api, annotationVisitor);
    this.descriptor = descriptor;
    this.remapper = remapper;
  }

  @Override
  public void visit(final String name, final Object value) {
    super.visit(mapAnnotationAttributeName(name), remapper.mapValue(value));
  }

  @Override
  public void visitEnum(final String name, final String descriptor, final String value) {
    super.visitEnum(mapAnnotationAttributeName(name), remapper.mapDesc(descriptor), value);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
    AnnotationVisitor annotationVisitor =
        super.visitAnnotation(mapAnnotationAttributeName(name), remapper.mapDesc(descriptor));
    if (annotationVisitor == null) {
      return null;
    } else {
      return annotationVisitor == av
          ? this
          : createAnnotationRemapper(descriptor, annotationVisitor);
    }
  }

  @Override
  public AnnotationVisitor visitArray(final String name) {
    AnnotationVisitor annotationVisitor = super.visitArray(mapAnnotationAttributeName(name));
    if (annotationVisitor == null) {
      return null;
    } else {
      return annotationVisitor == av
          ? this
          : createAnnotationRemapper(/* descriptor= */ null, annotationVisitor);
    }
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   * @deprecated use {@link #createAnnotationRemapper(String, AnnotationVisitor)} instead.
   */
  @Deprecated
  protected AnnotationVisitor createAnnotationRemapper(final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, /* descriptor= */ null, annotationVisitor, remapper);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param descriptor the descriptor of the visited annotation.
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected AnnotationVisitor createAnnotationRemapper(
      final String descriptor, final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, descriptor, annotationVisitor, remapper)
        .orDeprecatedValue(createAnnotationRemapper(annotationVisitor));
  }

  /**
   * Returns either this object, or the given one. If the given object is equal to the object
   * returned by the default implementation of the deprecated createAnnotationRemapper method,
   * meaning that this method has not been overridden (or only in minor ways, for instance to add
   * logging), then we can return this object instead, supposed to have been created by the new
   * createAnnotationRemapper method. Otherwise we must return the given object.
   *
   * @param deprecatedAnnotationVisitor the result of a call to the deprecated
   *     createAnnotationRemapper method.
   * @return either this object, or the given one.
   */
  final AnnotationVisitor orDeprecatedValue(final AnnotationVisitor deprecatedAnnotationVisitor) {
    if (deprecatedAnnotationVisitor.getClass() == getClass()) {
      AnnotationRemapper deprecatedAnnotationRemapper =
          (AnnotationRemapper) deprecatedAnnotationVisitor;
      if (deprecatedAnnotationRemapper.api == api
          && deprecatedAnnotationRemapper.av == av
          && deprecatedAnnotationRemapper.remapper == remapper) {
        return this;
      }
    }
    return deprecatedAnnotationVisitor;
  }

  /**
   * Maps an annotation attribute name with the remapper. Returns the original name unchanged if the
   * descriptor of the annotation is {@literal null}.
   *
   * @param name the name of the annotation attribute.
   * @return the new name of the annotation attribute.
   */
  private String mapAnnotationAttributeName(final String name) {
    if (descriptor == null) {
      return name;
    }
    return remapper.mapAnnotationAttributeName(descriptor, name);
  }
}

package org.objectweb.asm.commons;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * A {@link MethodVisitor} that keeps track of stack map frame changes between {@link
 * #visitFrame(int, int, Object[], int, Object[])} calls. This adapter must be used with the {@link
 * org.objectweb.asm.ClassReader#EXPAND_FRAMES} option. Each visit<i>X</i> instruction delegates to
 * the next visitor in the chain, if any, and then simulates the effect of this instruction on the
 * stack map frame, represented by {@link #locals} and {@link #stack}. The next visitor in the chain
 * can get the state of the stack map frame <i>before</i> each instruction by reading the value of
 * these fields in its visit<i>X</i> methods (this requires a reference to the AnalyzerAdapter that
 * is before it in the chain). If this adapter is used with a class that does not contain stack map
 * table attributes (i.e., pre Java 6 classes) then this adapter may not be able to compute the
 * stack map frame for each instruction. In this case no exception is thrown but the {@link #locals}
 * and {@link #stack} fields will be null for these instructions.
 *
 * @author Eric Bruneton
 */
public class AnalyzerAdapter extends MethodVisitor {

  /**
   * The local variable slots for the current execution frame. Primitive types are represented by
   * {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
   * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or {@link Opcodes#UNINITIALIZED_THIS} (long and
   * double are represented by two elements, the second one being TOP). Reference types are
   * represented by String objects (representing internal names, see {@link
   * Type#getInternalName()}), and uninitialized types by Label objects (this label designates the
   * NEW instruction that created this uninitialized value). This field is {@literal null} for
   * unreachable instructions.
   */
  public List<Object> locals;

  /**
   * The operand stack slots for the current execution frame. Primitive types are represented by
   * {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
   * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or {@link Opcodes#UNINITIALIZED_THIS} (long and
   * double are represented by two elements, the second one being TOP). Reference types are
   * represented by String objects (representing internal names, see {@link
   * Type#getInternalName()}), and uninitialized types by Label objects (this label designates the
   * NEW instruction that created this uninitialized value). This field is {@literal null} for
   * unreachable instructions.
   */
  public List<Object> stack;

  /** The labels that designate the next instruction to be visited. May be {@literal null}. */
  private List<Label> labels;

  /**
   * The uninitialized types in the current execution frame. This map associates internal names to
   * Label objects (see {@link Type#getInternalName()}). Each label designates a NEW instruction
   * that created the currently uninitialized types, and the associated internal name represents the
   * NEW operand, i.e. the final, initialized type value.
   */
  public Map<Object, Object> uninitializedTypes;

  /** The maximum stack size of this method. */
  private int maxStack;

  /** The maximum number of local variables of this method. */
  private int maxLocals;

  /** The owner's class name. */
  private String owner;

  /**
   * Constructs a new {@link AnalyzerAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #AnalyzerAdapter(int, String, int, String, String,
   * MethodVisitor)} version.
   *
   * @param owner the owner's class name.
   * @param access the method's access flags (see {@link Opcodes}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param methodVisitor the method visitor to which this adapter delegates calls. May be {@literal
   *     null}.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public AnalyzerAdapter(
      final @InternalForm String owner,
      final int access,
      final @Identifier String name,
      final String descriptor,
      final MethodVisitor methodVisitor) {
    this(/* latest api = */ Opcodes.ASM9, owner, access, name, descriptor, methodVisitor);
    if (getClass() != AnalyzerAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link AnalyzerAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param owner the owner's class name.
   * @param access the method's access flags (see {@link Opcodes}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param methodVisitor the method visitor to which this adapter delegates calls. May be {@literal
   *     null}.
   */
  protected AnalyzerAdapter(
      final int api,
      final @Owner String owner,
      final int access,
      final @Identifier String name,
      final String descriptor,
      final MethodVisitor methodVisitor) {
    super(api, methodVisitor);
    this.owner = owner;
    locals = new ArrayList<>();
    stack = new ArrayList<>();
    uninitializedTypes = new HashMap<>();

    if ((access & Opcodes.ACC_STATIC) == 0) {
      if ("<init>".equals(name)) {
        locals.add(Opcodes.UNINITIALIZED_THIS);
      } else {
        locals.add(owner);
      }
    }
    for (Type argumentType : Type.getArgumentTypes(descriptor)) {
      switch (argumentType.getSort()) {
        case Type.BOOLEAN:
        case Type.CHAR:
        case Type.BYTE:
        case Type.SHORT:
        case Type.INT:
          locals.add(Opcodes.INTEGER);
          break;
        case Type.FLOAT:
          locals.add(Opcodes.FLOAT);
          break;
        case Type.LONG:
          locals.add(Opcodes.LONG);
          locals.add(Opcodes.TOP);
          break;
        case Type.DOUBLE:
          locals.add(Opcodes.DOUBLE);
          locals.add(Opcodes.TOP);
          break;
        case Type.ARRAY:
          locals.add(argumentType.getDescriptor());
          break;
        case Type.OBJECT:
          locals.add(argumentType.getInternalName());
          break;
        default:
          throw new AssertionError();
      }
    }
    maxLocals = locals.size();
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    if (type != Opcodes.F_NEW) { // Uncompressed frame.
      throw new IllegalArgumentException(
          "AnalyzerAdapter only accepts expanded frames (see ClassReader.EXPAND_FRAMES)");
    }

    super.visitFrame(type, numLocal, local, numStack, stack);

    if (this.locals != null) {
      this.locals.clear();
      this.stack.clear();
    } else {
      this.locals = new ArrayList<>();
      this.stack = new ArrayList<>();
    }
    visitFrameTypes(numLocal, local, this.locals);
    visitFrameTypes(numStack, stack, this.stack);
    maxLocals = Math.max(maxLocals, this.locals.size());
    maxStack = Math.max(maxStack, this.stack.size());
  }

  private static void visitFrameTypes(
      final int numTypes, final Object[] frameTypes, final List<Object> result) {
    for (int i = 0; i < numTypes; ++i) {
      Object frameType = frameTypes[i];
      result.add(frameType);
      if (frameType == Opcodes.LONG || frameType == Opcodes.DOUBLE) {
        result.add(Opcodes.TOP);
      }
    }
  }

  @Override
  public void visitInsn(final int opcode) {
    super.visitInsn(opcode);
    execute(opcode, 0, null);
    if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {
      this.locals = null;
      this.stack = null;
    }
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    super.visitIntInsn(opcode, operand);
    execute(opcode, operand, null);
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    super.visitVarInsn(opcode, varIndex);
    boolean isLongOrDouble =
        opcode == Opcodes.LLOAD
            || opcode == Opcodes.DLOAD
            || opcode == Opcodes.LSTORE
            || opcode == Opcodes.DSTORE;
    maxLocals = Math.max(maxLocals, varIndex + (isLongOrDouble ? 2 : 1));
    execute(opcode, varIndex, null);
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    if (opcode == Opcodes.NEW) {
      if (labels == null) {
        Label label = new Label();
        labels = new ArrayList<>(3);
        labels.add(label);
        if (mv != null) {
          mv.visitLabel(label);
        }
      }
      for (Label label : labels) {
        uninitializedTypes.put(label, type);
      }
    }
    super.visitTypeInsn(opcode, type);
    execute(opcode, 0, type);
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    super.visitFieldInsn(opcode, owner, name, descriptor);
    execute(opcode, 0, descriptor);
  }

  @Override
  public void visitMethodInsn(
      final int opcodeAndSource,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
      // Redirect the call to the deprecated version of this method.
      super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
      return;
    }
    super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
    int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;

    if (this.locals == null) {
      labels = null;
      return;
    }
    pop(descriptor);
    if (opcode != Opcodes.INVOKESTATIC) {
      Object value = pop();
      if (opcode == Opcodes.INVOKESPECIAL && name.equals("<init>")) {
        Object initializedValue;
        if (value == Opcodes.UNINITIALIZED_THIS) {
          initializedValue = this.owner;
        } else {
          initializedValue = owner;
        }
        for (int i = 0; i < locals.size(); ++i) {
          if (locals.get(i) == value) {
            locals.set(i, initializedValue);
          }
        }
        for (int i = 0; i < stack.size(); ++i) {
          if (stack.get(i) == value) {
            stack.set(i, initializedValue);
          }
        }
      }
    }
    pushDescriptor(descriptor);
    labels = null;
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
    if (this.locals == null) {
      labels = null;
      return;
    }
    pop(descriptor);
    pushDescriptor(descriptor);
    labels = null;
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    super.visitJumpInsn(opcode, label);
    execute(opcode, 0, null);
    if (opcode == Opcodes.GOTO) {
      this.locals = null;
      this.stack = null;
    }
  }

  @Override
  public void visitLabel(final Label label) {
    super.visitLabel(label);
    if (labels == null) {
      labels = new ArrayList<>(3);
    }
    labels.add(label);
  }

  @Override
  public void visitLdcInsn(final Object value) {
    super.visitLdcInsn(value);
    if (this.locals == null) {
      labels = null;
      return;
    }
    if (value instanceof Integer) {
      push(Opcodes.INTEGER);
    } else if (value instanceof Long) {
      push(Opcodes.LONG);
      push(Opcodes.TOP);
    } else if (value instanceof Float) {
      push(Opcodes.FLOAT);
    } else if (value instanceof Double) {
      push(Opcodes.DOUBLE);
      push(Opcodes.TOP);
    } else if (value instanceof String) {
      push("java/lang/String");
    } else if (value instanceof Type) {
      int sort = ((Type) value).getSort();
      if (sort == Type.OBJECT || sort == Type.ARRAY) {
        push("java/lang/Class");
      } else if (sort == Type.METHOD) {
        push("java/lang/invoke/MethodType");
      } else {
        throw new IllegalArgumentException();
      }
    } else if (value instanceof Handle) {
      push("java/lang/invoke/MethodHandle");
    } else if (value instanceof ConstantDynamic) {
      pushDescriptor(((ConstantDynamic) value).getDescriptor());
    } else {
      throw new IllegalArgumentException();
    }
    labels = null;
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    super.visitIincInsn(varIndex, increment);
    maxLocals = Math.max(maxLocals, varIndex + 1);
    execute(Opcodes.IINC, varIndex, null);
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    super.visitTableSwitchInsn(min, max, dflt, labels);
    execute(Opcodes.TABLESWITCH, 0, null);
    this.locals = null;
    this.stack = null;
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    super.visitLookupSwitchInsn(dflt, keys, labels);
    execute(Opcodes.LOOKUPSWITCH, 0, null);
    this.locals = null;
    this.stack = null;
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    super.visitMultiANewArrayInsn(descriptor, numDimensions);
    execute(Opcodes.MULTIANEWARRAY, numDimensions, descriptor);
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    char firstDescriptorChar = descriptor.charAt(0);
    maxLocals =
        Math.max(
            maxLocals, index + (firstDescriptorChar == 'J' || firstDescriptorChar == 'D' ? 2 : 1));
    super.visitLocalVariable(name, descriptor, signature, start, end, index);
  }

  @Override
  public void visitMaxs(final int maxStack, final int maxLocals) {
    if (mv != null) {
      this.maxStack = Math.max(this.maxStack, maxStack);
      this.maxLocals = Math.max(this.maxLocals, maxLocals);
      mv.visitMaxs(this.maxStack, this.maxLocals);
    }
  }

  // -----------------------------------------------------------------------------------------------

  private Object get(final int local) {
    maxLocals = Math.max(maxLocals, local + 1);
    return local < locals.size() ? locals.get(local) : Opcodes.TOP;
  }

  private void set(final int local, final Object type) {
    maxLocals = Math.max(maxLocals, local + 1);
    while (local >= locals.size()) {
      locals.add(Opcodes.TOP);
    }
    locals.set(local, type);
  }

  private void push(final Object type) {
    stack.add(type);
    maxStack = Math.max(maxStack, stack.size());
  }

  private void pushDescriptor(final String fieldOrMethodDescriptor) {
    String descriptor =
        fieldOrMethodDescriptor.charAt(0) == '('
            ? Type.getReturnType(fieldOrMethodDescriptor).getDescriptor()
            : fieldOrMethodDescriptor;
    switch (descriptor.charAt(0)) {
      case 'V':
        return;
      case 'Z':
      case 'C':
      case 'B':
      case 'S':
      case 'I':
        push(Opcodes.INTEGER);
        return;
      case 'F':
        push(Opcodes.FLOAT);
        return;
      case 'J':
        push(Opcodes.LONG);
        push(Opcodes.TOP);
        return;
      case 'D':
        push(Opcodes.DOUBLE);
        push(Opcodes.TOP);
        return;
      case '[':
        push(descriptor);
        break;
      case 'L':
        push(descriptor.substring(1, descriptor.length() - 1));
        break;
      default:
        throw new AssertionError();
    }
  }

  private Object pop() {
    return stack.remove(stack.size() - 1);
  }

  private void pop(final int numSlots) {
    int size = stack.size();
    int end = size - numSlots;
    for (int i = size - 1; i >= end; --i) {
      stack.remove(i);
    }
  }

  private void pop(final String descriptor) {
    char firstDescriptorChar = descriptor.charAt(0);
    if (firstDescriptorChar == '(') {
      int numSlots = 0;
      Type[] types = Type.getArgumentTypes(descriptor);
      for (Type type : types) {
        numSlots += type.getSize();
      }
      pop(numSlots);
    } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {
      pop(2);
    } else {
      pop(1);
    }
  }

  private void execute(final int opcode, final int intArg, final String stringArg) {
    if (opcode == Opcodes.JSR || opcode == Opcodes.RET) {
      throw new IllegalArgumentException("JSR/RET are not supported");
    }
    if (this.locals == null) {
      labels = null;
      return;
    }
    Object value1;
    Object value2;
    Object value3;
    Object t4;
    switch (opcode) {
      case Opcodes.NOP:
      case Opcodes.INEG:
      case Opcodes.LNEG:
      case Opcodes.FNEG:
      case Opcodes.DNEG:
      case Opcodes.I2B:
      case Opcodes.I2C:
      case Opcodes.I2S:
      case Opcodes.GOTO:
      case Opcodes.RETURN:
        break;
      case Opcodes.ACONST_NULL:
        push(Opcodes.NULL);
        break;
      case Opcodes.ICONST_M1:
      case Opcodes.ICONST_0:
      case Opcodes.ICONST_1:
      case Opcodes.ICONST_2:
      case Opcodes.ICONST_3:
      case Opcodes.ICONST_4:
      case Opcodes.ICONST_5:
      case Opcodes.BIPUSH:
      case Opcodes.SIPUSH:
        push(Opcodes.INTEGER);
        break;
      case Opcodes.LCONST_0:
      case Opcodes.LCONST_1:
        push(Opcodes.LONG);
        push(Opcodes.TOP);
        break;
      case Opcodes.FCONST_0:
      case Opcodes.FCONST_1:
      case Opcodes.FCONST_2:
        push(Opcodes.FLOAT);
        break;
      case Opcodes.DCONST_0:
      case Opcodes.DCONST_1:
        push(Opcodes.DOUBLE);
        push(Opcodes.TOP);
        break;
      case Opcodes.ILOAD:
      case Opcodes.FLOAD:
      case Opcodes.ALOAD:
        push(get(intArg));
        break;
      case Opcodes.LLOAD:
      case Opcodes.DLOAD:
        push(get(intArg));
        push(Opcodes.TOP);
        break;
      case Opcodes.LALOAD:
      case Opcodes.D2L:
        pop(2);
        push(Opcodes.LONG);
        push(Opcodes.TOP);
        break;
      case Opcodes.DALOAD:
      case Opcodes.L2D:
        pop(2);
        push(Opcodes.DOUBLE);
        push(Opcodes.TOP);
        break;
      case Opcodes.AALOAD:
        pop(1);
        value1 = pop();
        if (value1 instanceof String) {
          pushDescriptor(((String) value1).substring(1));
        } else if (value1 == Opcodes.NULL) {
          push(value1);
        } else {
          push("java/lang/Object");
        }
        break;
      case Opcodes.ISTORE:
      case Opcodes.FSTORE:
      case Opcodes.ASTORE:
        value1 = pop();
        set(intArg, value1);
        if (intArg > 0) {
          value2 = get(intArg - 1);
          if (value2 == Opcodes.LONG || value2 == Opcodes.DOUBLE) {
            set(intArg - 1, Opcodes.TOP);
          }
        }
        break;
      case Opcodes.LSTORE:
      case Opcodes.DSTORE:
        pop(1);
        value1 = pop();
        set(intArg, value1);
        set(intArg + 1, Opcodes.TOP);
        if (intArg > 0) {
          value2 = get(intArg - 1);
          if (value2 == Opcodes.LONG || value2 == Opcodes.DOUBLE) {
            set(intArg - 1, Opcodes.TOP);
          }
        }
        break;
      case Opcodes.IASTORE:
      case Opcodes.BASTORE:
      case Opcodes.CASTORE:
      case Opcodes.SASTORE:
      case Opcodes.FASTORE:
      case Opcodes.AASTORE:
        pop(3);
        break;
      case Opcodes.LASTORE:
      case Opcodes.DASTORE:
        pop(4);
        break;
      case Opcodes.POP:
      case Opcodes.IFEQ:
      case Opcodes.IFNE:
      case Opcodes.IFLT:
      case Opcodes.IFGE:
      case Opcodes.IFGT:
      case Opcodes.IFLE:
      case Opcodes.IRETURN:
      case Opcodes.FRETURN:
      case Opcodes.ARETURN:
      case Opcodes.TABLESWITCH:
      case Opcodes.LOOKUPSWITCH:
      case Opcodes.ATHROW:
      case Opcodes.MONITORENTER:
      case Opcodes.MONITOREXIT:
      case Opcodes.IFNULL:
      case Opcodes.IFNONNULL:
        pop(1);
        break;
      case Opcodes.POP2:
      case Opcodes.IF_ICMPEQ:
      case Opcodes.IF_ICMPNE:
      case Opcodes.IF_ICMPLT:
      case Opcodes.IF_ICMPGE:
      case Opcodes.IF_ICMPGT:
      case Opcodes.IF_ICMPLE:
      case Opcodes.IF_ACMPEQ:
      case Opcodes.IF_ACMPNE:
      case Opcodes.LRETURN:
      case Opcodes.DRETURN:
        pop(2);
        break;
      case Opcodes.DUP:
        value1 = pop();
        push(value1);
        push(value1);
        break;
      case Opcodes.DUP_X1:
        value1 = pop();
        value2 = pop();
        push(value1);
        push(value2);
        push(value1);
        break;
      case Opcodes.DUP_X2:
        value1 = pop();
        value2 = pop();
        value3 = pop();
        push(value1);
        push(value3);
        push(value2);
        push(value1);
        break;
      case Opcodes.DUP2:
        value1 = pop();
        value2 = pop();
        push(value2);
        push(value1);
        push(value2);
        push(value1);
        break;
      case Opcodes.DUP2_X1:
        value1 = pop();
        value2 = pop();
        value3 = pop();
        push(value2);
        push(value1);
        push(value3);
        push(value2);
        push(value1);
        break;
      case Opcodes.DUP2_X2:
        value1 = pop();
        value2 = pop();
        value3 = pop();
        t4 = pop();
        push(value2);
        push(value1);
        push(t4);
        push(value3);
        push(value2);
        push(value1);
        break;
      case Opcodes.SWAP:
        value1 = pop();
        value2 = pop();
        push(value1);
        push(value2);
        break;
      case Opcodes.IALOAD:
      case Opcodes.BALOAD:
      case Opcodes.CALOAD:
      case Opcodes.SALOAD:
      case Opcodes.IADD:
      case Opcodes.ISUB:
      case Opcodes.IMUL:
      case Opcodes.IDIV:
      case Opcodes.IREM:
      case Opcodes.IAND:
      case Opcodes.IOR:
      case Opcodes.IXOR:
      case Opcodes.ISHL:
      case Opcodes.ISHR:
      case Opcodes.IUSHR:
      case Opcodes.L2I:
      case Opcodes.D2I:
      case Opcodes.FCMPL:
      case Opcodes.FCMPG:
        pop(2);
        push(Opcodes.INTEGER);
        break;
      case Opcodes.LADD:
      case Opcodes.LSUB:
      case Opcodes.LMUL:
      case Opcodes.LDIV:
      case Opcodes.LREM:
      case Opcodes.LAND:
      case Opcodes.LOR:
      case Opcodes.LXOR:
        pop(4);
        push(Opcodes.LONG);
        push(Opcodes.TOP);
        break;
      case Opcodes.FALOAD:
      case Opcodes.FADD:
      case Opcodes.FSUB:
      case Opcodes.FMUL:
      case Opcodes.FDIV:
      case Opcodes.FREM:
      case Opcodes.L2F:
      case Opcodes.D2F:
        pop(2);
        push(Opcodes.FLOAT);
        break;
      case Opcodes.DADD:
      case Opcodes.DSUB:
      case Opcodes.DMUL:
      case Opcodes.DDIV:
      case Opcodes.DREM:
        pop(4);
        push(Opcodes.DOUBLE);
        push(Opcodes.TOP);
        break;
      case Opcodes.LSHL:
      case Opcodes.LSHR:
      case Opcodes.LUSHR:
        pop(3);
        push(Opcodes.LONG);
        push(Opcodes.TOP);
        break;
      case Opcodes.IINC:
        set(intArg, Opcodes.INTEGER);
        break;
      case Opcodes.I2L:
      case Opcodes.F2L:
        pop(1);
        push(Opcodes.LONG);
        push(Opcodes.TOP);
        break;
      case Opcodes.I2F:
        pop(1);
        push(Opcodes.FLOAT);
        break;
      case Opcodes.I2D:
      case Opcodes.F2D:
        pop(1);
        push(Opcodes.DOUBLE);
        push(Opcodes.TOP);
        break;
      case Opcodes.F2I:
      case Opcodes.ARRAYLENGTH:
      case Opcodes.INSTANCEOF:
        pop(1);
        push(Opcodes.INTEGER);
        break;
      case Opcodes.LCMP:
      case Opcodes.DCMPL:
      case Opcodes.DCMPG:
        pop(4);
        push(Opcodes.INTEGER);
        break;
      case Opcodes.GETSTATIC:
        pushDescriptor(stringArg);
        break;
      case Opcodes.PUTSTATIC:
        pop(stringArg);
        break;
      case Opcodes.GETFIELD:
        pop(1);
        pushDescriptor(stringArg);
        break;
      case Opcodes.PUTFIELD:
        pop(stringArg);
        pop();
        break;
      case Opcodes.NEW:
        push(labels.get(0));
        break;
      case Opcodes.NEWARRAY:
        pop();
        switch (intArg) {
          case Opcodes.T_BOOLEAN:
            pushDescriptor("[Z");
            break;
          case Opcodes.T_CHAR:
            pushDescriptor("[C");
            break;
          case Opcodes.T_BYTE:
            pushDescriptor("[B");
            break;
          case Opcodes.T_SHORT:
            pushDescriptor("[S");
            break;
          case Opcodes.T_INT:
            pushDescriptor("[I");
            break;
          case Opcodes.T_FLOAT:
            pushDescriptor("[F");
            break;
          case Opcodes.T_DOUBLE:
            pushDescriptor("[D");
            break;
          case Opcodes.T_LONG:
            pushDescriptor("[J");
            break;
          default:
            throw new IllegalArgumentException("Invalid array type " + intArg);
        }
        break;
      case Opcodes.ANEWARRAY:
        pop();
        pushDescriptor("[" + Type.getObjectType(stringArg));
        break;
      case Opcodes.CHECKCAST:
        pop();
        pushDescriptor(Type.getObjectType(stringArg).getDescriptor());
        break;
      case Opcodes.MULTIANEWARRAY:
        pop(intArg);
        pushDescriptor(stringArg);
        break;
      default:
        throw new IllegalArgumentException("Invalid opcode " + opcode);
    }
    labels = null;
  }
}


package org.objectweb.asm.commons;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;

/**
 * A {@link FieldVisitor} that remaps types with a {@link Remapper}.
 *
 * @author Eugene Kuleshov
 */
public class FieldRemapper extends FieldVisitor {

  /** The remapper used to remap the types in the visited field. */
  protected final Remapper remapper;

  /**
   * Constructs a new {@link FieldRemapper}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #FieldRemapper(int,FieldVisitor,Remapper)} version.
   *
   * @param fieldVisitor the field visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited field.
   */
  public FieldRemapper(final FieldVisitor fieldVisitor, final Remapper remapper) {
    this(/* latest api = */ Opcodes.ASM9, fieldVisitor, remapper);
  }

  /**
   * Constructs a new {@link FieldRemapper}.
   *
   * @param api the ASM API version supported by this remapper. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param fieldVisitor the field visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited field.
   */
  protected FieldRemapper(final int api, final FieldVisitor fieldVisitor, final Remapper remapper) {
    super(api, fieldVisitor);
    this.remapper = remapper;
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitAnnotation(remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? null
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitTypeAnnotation(typeRef, typePath, remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? null
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   * @deprecated use {@link #createAnnotationRemapper(String, AnnotationVisitor)} instead.
   */
  @Deprecated
  protected AnnotationVisitor createAnnotationRemapper(final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, /* descriptor= */ null, annotationVisitor, remapper);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param descriptor the descriptor of the visited annotation.
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected AnnotationVisitor createAnnotationRemapper(
      final String descriptor, final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, descriptor, annotationVisitor, remapper)
        .orDeprecatedValue(createAnnotationRemapper(annotationVisitor));
  }
}

package org.objectweb.asm.commons;

import java.util.HashMap;
import java.util.Map;
import org.objectweb.asm.Type;

/**
 * A named method descriptor.
 *
 * @author Juozas Baliuka
 * @author Chris Nokleberg
 * @author Eric Bruneton
 */
public class Method {

  /** The method name. */
  private final String name;

  /** The method descriptor. */
  private final String descriptor;

  /** The descriptors of the primitive Java types (plus void). */
  private static final Map<String, String> PRIMITIVE_TYPE_DESCRIPTORS;

  static {
    HashMap<String, String> descriptors = new HashMap<>();
    descriptors.put("void", "V");
    descriptors.put("byte", "B");
    descriptors.put("char", "C");
    descriptors.put("double", "D");
    descriptors.put("float", "F");
    descriptors.put("int", "I");
    descriptors.put("long", "J");
    descriptors.put("short", "S");
    descriptors.put("boolean", "Z");
    PRIMITIVE_TYPE_DESCRIPTORS = descriptors;
  }

  /**
   * Constructs a new {@link Method}.
   *
   * @param name the method's name.
   * @param descriptor the method's descriptor.
   */
  public Method(final String name, final String descriptor) {
    this.name = name;
    this.descriptor = descriptor;
  }

  /**
   * Constructs a new {@link Method}.
   *
   * @param name the method's name.
   * @param returnType the method's return type.
   * @param argumentTypes the method's argument types.
   */
  public Method(final String name, final Type returnType, final Type[] argumentTypes) {
    this(name, Type.getMethodDescriptor(returnType, argumentTypes));
  }

  /**
   * Creates a new {@link Method}.
   *
   * @param method a java.lang.reflect method descriptor
   * @return a {@link Method} corresponding to the given Java method declaration.
   */
  public static Method getMethod(final java.lang.reflect.Method method) {
    return new Method(method.getName(), Type.getMethodDescriptor(method));
  }

  /**
   * Creates a new {@link Method}.
   *
   * @param constructor a java.lang.reflect constructor descriptor
   * @return a {@link Method} corresponding to the given Java constructor declaration.
   */
  public static Method getMethod(final java.lang.reflect.Constructor<?> constructor) {
    return new Method("<init>", Type.getConstructorDescriptor(constructor));
  }

  /**
   * Returns a {@link Method} corresponding to the given Java method declaration.
   *
   * @param method a Java method declaration, without argument names, of the form "returnType name
   *     (argumentType1, ... argumentTypeN)", where the types are in plain Java (e.g. "int",
   *     "float", "java.util.List", ...). Classes of the java.lang package can be specified by their
   *     unqualified name; all other classes names must be fully qualified.
   * @return a {@link Method} corresponding to the given Java method declaration.
   * @throws IllegalArgumentException if <code>method</code> could not get parsed.
   */
  public static Method getMethod(final String method) {
    return getMethod(method, false);
  }

  /**
   * Returns a {@link Method} corresponding to the given Java method declaration.
   *
   * @param method a Java method declaration, without argument names, of the form "returnType name
   *     (argumentType1, ... argumentTypeN)", where the types are in plain Java (e.g. "int",
   *     "float", "java.util.List", ...). Classes of the java.lang package may be specified by their
   *     unqualified name, depending on the defaultPackage argument; all other classes names must be
   *     fully qualified.
   * @param defaultPackage true if unqualified class names belong to the default package, or false
   *     if they correspond to java.lang classes. For instance "Object" means "Object" if this
   *     option is true, or "java.lang.Object" otherwise.
   * @return a {@link Method} corresponding to the given Java method declaration.
   * @throws IllegalArgumentException if <code>method</code> could not get parsed.
   */
  public static Method getMethod(final String method, final boolean defaultPackage) {
    final int spaceIndex = method.indexOf(' ');
    int currentArgumentStartIndex = method.indexOf('(', spaceIndex) + 1;
    final int endIndex = method.indexOf(')', currentArgumentStartIndex);
    if (spaceIndex == -1 || currentArgumentStartIndex == 0 || endIndex == -1) {
      throw new IllegalArgumentException();
    }
    final String returnType = method.substring(0, spaceIndex);
    final String methodName =
        method.substring(spaceIndex + 1, currentArgumentStartIndex - 1).trim();
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append('(');
    int currentArgumentEndIndex;
    do {
      String argumentDescriptor;
      currentArgumentEndIndex = method.indexOf(',', currentArgumentStartIndex);
      if (currentArgumentEndIndex == -1) {
        argumentDescriptor =
            getDescriptorInternal(
                method.substring(currentArgumentStartIndex, endIndex).trim(), defaultPackage);
      } else {
        argumentDescriptor =
            getDescriptorInternal(
                method.substring(currentArgumentStartIndex, currentArgumentEndIndex).trim(),
                defaultPackage);
        currentArgumentStartIndex = currentArgumentEndIndex + 1;
      }
      stringBuilder.append(argumentDescriptor);
    } while (currentArgumentEndIndex != -1);
    stringBuilder.append(')').append(getDescriptorInternal(returnType, defaultPackage));
    return new Method(methodName, stringBuilder.toString());
  }

  /**
   * Returns the descriptor corresponding to the given type name.
   *
   * @param type a Java type name.
   * @param defaultPackage true if unqualified class names belong to the default package, or false
   *     if they correspond to java.lang classes. For instance "Object" means "Object" if this
   *     option is true, or "java.lang.Object" otherwise.
   * @return the descriptor corresponding to the given type name.
   */
  private static String getDescriptorInternal(final String type, final boolean defaultPackage) {
    if ("".equals(type)) {
      return type;
    }

    StringBuilder stringBuilder = new StringBuilder();
    int arrayBracketsIndex = 0;
    while ((arrayBracketsIndex = type.indexOf("[]", arrayBracketsIndex) + 1) > 0) {
      stringBuilder.append('[');
    }

    String elementType = type.substring(0, type.length() - stringBuilder.length() * 2);
    String descriptor = PRIMITIVE_TYPE_DESCRIPTORS.get(elementType);
    if (descriptor != null) {
      stringBuilder.append(descriptor);
    } else {
      stringBuilder.append('L');
      if (elementType.indexOf('.') < 0) {
        if (!defaultPackage) {
          stringBuilder.append("java/lang/");
        }
        stringBuilder.append(elementType);
      } else {
        stringBuilder.append(elementType.replace('.', '/'));
      }
      stringBuilder.append(';');
    }
    return stringBuilder.toString();
  }

  /**
   * Returns the name of the method described by this object.
   *
   * @return the name of the method described by this object.
   */
  public String getName() {
    return name;
  }

  /**
   * Returns the descriptor of the method described by this object.
   *
   * @return the descriptor of the method described by this object.
   */
  public String getDescriptor() {
    return descriptor;
  }

  /**
   * Returns the return type of the method described by this object.
   *
   * @return the return type of the method described by this object.
   */
  public Type getReturnType() {
    return Type.getReturnType(descriptor);
  }

  /**
   * Returns the argument types of the method described by this object.
   *
   * @return the argument types of the method described by this object.
   */
  public Type[] getArgumentTypes() {
    return Type.getArgumentTypes(descriptor);
  }

  @Override
  public String toString() {
    return name + descriptor;
  }

  @Override
  public boolean equals(final Object other) {
    if (!(other instanceof Method)) {
      return false;
    }
    Method otherMethod = (Method) other;
    return name.equals(otherMethod.name) && descriptor.equals(otherMethod.descriptor);
  }

  @Override
  public int hashCode() {
    return name.hashCode() ^ descriptor.hashCode();
  }
}

package org.objectweb.asm.commons;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A {@link ClassVisitor} that merges &lt;clinit&gt; methods into a single one. All the existing
 * &lt;clinit&gt; methods are renamed, and a new one is created, which calls all the renamed
 * methods.
 *
 * @author Eric Bruneton
 */
public class StaticInitMerger extends ClassVisitor {

  /** The internal name of the visited class. */
  private @InternalForm String owner;

  /** The prefix to use to rename the existing &lt;clinit&gt; methods. */
  private final String renamedClinitMethodPrefix;

  /** The number of &lt;clinit&gt; methods visited so far. */
  private int numClinitMethods;

  /** The MethodVisitor for the merged &lt;clinit&gt; method. */
  private MethodVisitor mergedClinitVisitor;

  /**
   * Constructs a new {@link StaticInitMerger}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #StaticInitMerger(int, String, ClassVisitor)} version.
   *
   * @param prefix the prefix to use to rename the existing &lt;clinit&gt; methods.
   * @param classVisitor the class visitor to which this visitor must delegate method calls. May be
   *     null.
   */
  public StaticInitMerger(final String prefix, final ClassVisitor classVisitor) {
    this(/* latest api = */ Opcodes.ASM9, prefix, classVisitor);
  }

  /**
   * Constructs a new {@link StaticInitMerger}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param prefix the prefix to use to rename the existing &lt;clinit&gt; methods.
   * @param classVisitor the class visitor to which this visitor must delegate method calls. May be
   *     null.
   */
  protected StaticInitMerger(final int api, final String prefix, final ClassVisitor classVisitor) {
    super(api, classVisitor);
    this.renamedClinitMethodPrefix = prefix;
  }

  @Override
  public void visit(
      final int version,
      final int access,
      final String name,
      final String signature,
      final String superName,
      final String[] interfaces) {
    super.visit(version, access, name, signature, superName, interfaces);
    this.owner = name;
  }

  @Override
  public MethodVisitor visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final String[] exceptions) {
    MethodVisitor methodVisitor;
    if ("<clinit>".equals(name)) {
      int newAccess = Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC;
      String newName = renamedClinitMethodPrefix + numClinitMethods++;
      methodVisitor = super.visitMethod(newAccess, newName, descriptor, signature, exceptions);

      if (mergedClinitVisitor == null) {
        mergedClinitVisitor = super.visitMethod(newAccess, name, descriptor, null, null);
      }
      mergedClinitVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, owner, newName, descriptor, false);
    } else {
      methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions);
    }
    return methodVisitor;
  }

  @Override
  public void visitEnd() {
    if (mergedClinitVisitor != null) {
      mergedClinitVisitor.visitInsn(Opcodes.RETURN);
      mergedClinitVisitor.visitMaxs(0, 0);
    }
    super.visitEnd();
  }
}

package org.objectweb.asm.commons;

import java.io.ByteArrayOutputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A {@link ClassVisitor} that adds a serial version unique identifier to a class if missing. A
 * typical usage of this class is:
 *
 * <pre>
 *   ClassWriter classWriter = new ClassWriter(...);
 *   ClassVisitor svuidAdder = new SerialVersionUIDAdder(classWriter);
 *   ClassVisitor classVisitor = new MyClassAdapter(svuidAdder);
 *   new ClassReader(orginalClass).accept(classVisitor, 0);
 * </pre>
 *
 * <p>The SVUID algorithm can be found at <a href=
 * "https://docs.oracle.com/javase/10/docs/specs/serialization/class.html#stream-unique-identifiers"
 * >https://docs.oracle.com/javase/10/docs/specs/serialization/class.html#stream-unique-identifiers</a>:
 *
 * <p>The serialVersionUID is computed using the signature of a stream of bytes that reflect the
 * class definition. The National Institute of Standards and Technology (NIST) Secure Hash Algorithm
 * (SHA-1) is used to compute a signature for the stream. The first two 32-bit quantities are used
 * to form a 64-bit hash. A java.lang.DataOutputStream is used to convert primitive data types to a
 * sequence of bytes. The values input to the stream are defined by the Java Virtual Machine (VM)
 * specification for classes.
 *
 * <p>The sequence of items in the stream is as follows:
 *
 * <ol>
 *   <li>The class name written using UTF encoding.
 *   <li>The class modifiers written as a 32-bit integer.
 *   <li>The name of each interface sorted by name written using UTF encoding.
 *   <li>For each field of the class sorted by field name (except private static and private
 *       transient fields):
 *       <ol>
 *         <li>The name of the field in UTF encoding.
 *         <li>The modifiers of the field written as a 32-bit integer.
 *         <li>The descriptor of the field in UTF encoding
 *       </ol>
 *   <li>If a class initializer exists, write out the following:
 *       <ol>
 *         <li>The name of the method, &lt;clinit&gt;, in UTF encoding.
 *         <li>The modifier of the method, STATIC, written as a 32-bit integer.
 *         <li>The descriptor of the method, ()V, in UTF encoding.
 *       </ol>
 *   <li>For each non-private constructor sorted by method name and signature:
 *       <ol>
 *         <li>The name of the method, &lt;init&gt;, in UTF encoding.
 *         <li>The modifiers of the method written as a 32-bit integer.
 *         <li>The descriptor of the method in UTF encoding.
 *       </ol>
 *   <li>For each non-private method sorted by method name and signature:
 *       <ol>
 *         <li>The name of the method in UTF encoding.
 *         <li>The modifiers of the method written as a 32-bit integer.
 *         <li>The descriptor of the method in UTF encoding.
 *       </ol>
 *   <li>The SHA-1 algorithm is executed on the stream of bytes produced by DataOutputStream and
 *       produces five 32-bit values sha[0..4].
 *   <li>The hash value is assembled from the first and second 32-bit values of the SHA-1 message
 *       digest. If the result of the message digest, the five 32-bit words H0 H1 H2 H3 H4, is in an
 *       array of five int values named sha, the hash value would be computed as follows: long hash
 *       = ((sha[0] &gt;&gt;&gt; 24) &amp; 0xFF) | ((sha[0] &gt;&gt;&gt; 16) &amp; 0xFF) &lt;&lt; 8
 *       | ((sha[0] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 16 | ((sha[0] &gt;&gt;&gt; 0) &amp; 0xFF)
 *       &lt;&lt; 24 | ((sha[1] &gt;&gt;&gt; 24) &amp; 0xFF) &lt;&lt; 32 | ((sha[1] &gt;&gt;&gt; 16)
 *       &amp; 0xFF) &lt;&lt; 40 | ((sha[1] &gt;&gt;&gt; 8) &amp; 0xFF) &lt;&lt; 48 | ((sha[1]
 *       &gt;&gt;&gt; 0) &amp; 0xFF) &lt;&lt; 56;
 * </ol>
 *
 * @author Rajendra Inamdar, Vishal Vishnoi
 */
// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
public class SerialVersionUIDAdder extends ClassVisitor {

  /** The JVM name of static initializer methods. */
  private static final String CLINIT = "<clinit>";

  /** A flag that indicates if we need to compute SVUID. */
  private boolean computeSvuid;

  /** Whether the class already has a SVUID. */
  private boolean hasSvuid;

  /** The class access flags. */
  private int access;

  /** The internal name of the class. */
  private @InternalForm String name;

  /** The interfaces implemented by the class. */
  private String[] interfaces;

  /** The fields of the class that are needed to compute the SVUID. */
  private Collection<Item> svuidFields;

  /** Whether the class has a static initializer. */
  private boolean hasStaticInitializer;

  /** The constructors of the class that are needed to compute the SVUID. */
  private Collection<Item> svuidConstructors;

  /** The methods of the class that are needed to compute the SVUID. */
  private Collection<Item> svuidMethods;

  /**
   * Constructs a new {@link SerialVersionUIDAdder}. <i>Subclasses must not use this
   * constructor</i>. Instead, they must use the {@link #SerialVersionUIDAdder(int, ClassVisitor)}
   * version.
   *
   * @param classVisitor a {@link ClassVisitor} to which this visitor will delegate calls.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public SerialVersionUIDAdder(final ClassVisitor classVisitor) {
    this(/* latest api = */ Opcodes.ASM9, classVisitor);
    if (getClass() != SerialVersionUIDAdder.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link SerialVersionUIDAdder}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param classVisitor a {@link ClassVisitor} to which this visitor will delegate calls.
   */
  protected SerialVersionUIDAdder(final int api, final ClassVisitor classVisitor) {
    super(api, classVisitor);
  }

  // -----------------------------------------------------------------------------------------------
  // Overridden methods
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visit(
      final int version,
      final int access,
      final String name,
      final String signature,
      final String superName,
      final String[] interfaces) {
    // Get the class name, access flags, and interfaces information (step 1, 2 and 3) for SVUID
    // computation.
    computeSvuid = (access & Opcodes.ACC_ENUM) == 0;

    if (computeSvuid) {
      this.name = name;
      this.access = access;
      this.interfaces = interfaces.clone();
      this.svuidFields = new ArrayList<>();
      this.svuidConstructors = new ArrayList<>();
      this.svuidMethods = new ArrayList<>();
    }

    super.visit(version, access, name, signature, superName, interfaces);
  }

  @Override
  public MethodVisitor visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final String[] exceptions) {
    // Get constructor and method information (step 5 and 7). Also determine if there is a class
    // initializer (step 6).
    if (computeSvuid) {
      if (CLINIT.equals(name)) {
        hasStaticInitializer = true;
      }
      // Collect the non private constructors and methods. Only the ACC_PUBLIC, ACC_PRIVATE,
      // ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT and
      // ACC_STRICT flags are used.
      int mods =
          access
              & (Opcodes.ACC_PUBLIC
                  | Opcodes.ACC_PRIVATE
                  | Opcodes.ACC_PROTECTED
                  | Opcodes.ACC_STATIC
                  | Opcodes.ACC_FINAL
                  | Opcodes.ACC_SYNCHRONIZED
                  | Opcodes.ACC_NATIVE
                  | Opcodes.ACC_ABSTRACT
                  | Opcodes.ACC_STRICT);

      if ((access & Opcodes.ACC_PRIVATE) == 0) {
        if ("<init>".equals(name)) {
          svuidConstructors.add(new Item(name, mods, descriptor));
        } else if (!CLINIT.equals(name)) {
          svuidMethods.add(new Item(name, mods, descriptor));
        }
      }
    }

    return super.visitMethod(access, name, descriptor, signature, exceptions);
  }

  @Override
  public FieldVisitor visitField(
      final int access,
      final String name,
      final String desc,
      final String signature,
      final Object value) {
    // Get the class field information for step 4 of the algorithm. Also determine if the class
    // already has a SVUID.
    if (computeSvuid) {
      if ("serialVersionUID".equals(name)) {
        // Since the class already has SVUID, we won't be computing it.
        computeSvuid = false;
        hasSvuid = true;
      }
      // Collect the non private fields. Only the ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED,
      // ACC_STATIC, ACC_FINAL, ACC_VOLATILE, and ACC_TRANSIENT flags are used when computing
      // serialVersionUID values.
      if ((access & Opcodes.ACC_PRIVATE) == 0
          || (access & (Opcodes.ACC_STATIC | Opcodes.ACC_TRANSIENT)) == 0) {
        int mods =
            access
                & (Opcodes.ACC_PUBLIC
                    | Opcodes.ACC_PRIVATE
                    | Opcodes.ACC_PROTECTED
                    | Opcodes.ACC_STATIC
                    | Opcodes.ACC_FINAL
                    | Opcodes.ACC_VOLATILE
                    | Opcodes.ACC_TRANSIENT);
        svuidFields.add(new Item(name, mods, desc));
      }
    }

    return super.visitField(access, name, desc, signature, value);
  }

  @Override
  public void visitInnerClass(
      final @InternalForm String innerClassName,
      final @InternalForm String outerName,
      final @Identifier String innerName,
      final int innerClassAccess) {
    // Handles a bizarre special case. Nested classes (static classes declared inside another class)
    // that are protected have their access bit set to public in their class files to deal with some
    // odd reflection situation. Our SVUID computation must do as the JVM does and ignore access
    // bits in the class file in favor of the access bits of the InnerClass attribute.
    if ((name != null) && name.equals(innerClassName)) {
      this.access = innerClassAccess;
    }
    super.visitInnerClass(innerClassName, outerName, innerName, innerClassAccess);
  }

  @Override
  public void visitEnd() {
    // Add the SVUID field to the class if it doesn't have one.
    if (computeSvuid && !hasSvuid) {
      try {
        addSVUID(computeSVUID());
      } catch (IOException e) {
        throw new IllegalStateException("Error while computing SVUID for " + name, e);
      }
    }

    super.visitEnd();
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns true if the class already has a SVUID field. The result of this method is only valid
   * when visitEnd has been called.
   *
   * @return true if the class already has a SVUID field.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  public boolean hasSVUID() {
    return hasSvuid;
  }

  /**
   * Adds a final static serialVersionUID field to the class, with the given value.
   *
   * @param svuid the serialVersionUID field value.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  protected void addSVUID(final long svuid) {
    FieldVisitor fieldVisitor =
        super.visitField(
            Opcodes.ACC_FINAL + Opcodes.ACC_STATIC, "serialVersionUID", "J", null, svuid);
    if (fieldVisitor != null) {
      fieldVisitor.visitEnd();
    }
  }

  /**
   * Computes and returns the value of SVUID.
   *
   * @return the serial version UID.
   * @throws IOException if an I/O error occurs.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  protected long computeSVUID() throws IOException {
    long svuid = 0;

    try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream)) {

      // 1. The class name written using UTF encoding.
      dataOutputStream.writeUTF(name.replace('/', '.'));

      // 2. The class modifiers written as a 32-bit integer.
      int mods = access;
      if ((mods & Opcodes.ACC_INTERFACE) != 0) {
        mods =
            svuidMethods.isEmpty() ? (mods & ~Opcodes.ACC_ABSTRACT) : (mods | Opcodes.ACC_ABSTRACT);
      }
      dataOutputStream.writeInt(
          mods
              & (Opcodes.ACC_PUBLIC
                  | Opcodes.ACC_FINAL
                  | Opcodes.ACC_INTERFACE
                  | Opcodes.ACC_ABSTRACT));

      // 3. The name of each interface sorted by name written using UTF encoding.
      Arrays.sort(interfaces);
      for (String interfaceName : interfaces) {
        dataOutputStream.writeUTF(interfaceName.replace('/', '.'));
      }

      // 4. For each field of the class sorted by field name (except private static and private
      // transient fields):
      //   1. The name of the field in UTF encoding.
      //   2. The modifiers of the field written as a 32-bit integer.
      //   3. The descriptor of the field in UTF encoding.
      // Note that field signatures are not dot separated. Method and constructor signatures are dot
      // separated. Go figure...
      writeItems(svuidFields, dataOutputStream, false);

      // 5. If a class initializer exists, write out the following:
      //   1. The name of the method, <clinit>, in UTF encoding.
      //   2. The modifier of the method, ACC_STATIC, written as a 32-bit integer.
      //   3. The descriptor of the method, ()V, in UTF encoding.
      if (hasStaticInitializer) {
        dataOutputStream.writeUTF(CLINIT);
        dataOutputStream.writeInt(Opcodes.ACC_STATIC);
        dataOutputStream.writeUTF("()V");
      }

      // 6. For each non-private constructor sorted by method name and signature:
      //   1. The name of the method, <init>, in UTF encoding.
      //   2. The modifiers of the method written as a 32-bit integer.
      //   3. The descriptor of the method in UTF encoding.
      writeItems(svuidConstructors, dataOutputStream, true);

      // 7. For each non-private method sorted by method name and signature:
      //   1. The name of the method in UTF encoding.
      //   2. The modifiers of the method written as a 32-bit integer.
      //   3. The descriptor of the method in UTF encoding.
      writeItems(svuidMethods, dataOutputStream, true);

      dataOutputStream.flush();

      // 8. The SHA-1 algorithm is executed on the stream of bytes produced by DataOutputStream and
      // produces five 32-bit values sha[0..4].
      byte[] hashBytes = computeSHAdigest(byteArrayOutputStream.toByteArray());

      // 9. The hash value is assembled from the first and second 32-bit values of the SHA-1 message
      // digest. If the result of the message digest, the five 32-bit words H0 H1 H2 H3 H4, is in an
      // array of five int values named sha, the hash value would be computed as follows:
      for (int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--) {
        svuid = (svuid << 8) | (hashBytes[i] & 0xFF);
      }
    }

    return svuid;
  }

  /**
   * Returns the SHA-1 message digest of the given value.
   *
   * @param value the value whose SHA message digest must be computed.
   * @return the SHA-1 message digest of the given value.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  protected byte[] computeSHAdigest(final byte[] value) {
    try {
      return MessageDigest.getInstance("SHA").digest(value);
    } catch (NoSuchAlgorithmException e) {
      throw new UnsupportedOperationException(e);
    }
  }

  /**
   * Sorts the items in the collection and writes it to the given output stream.
   *
   * @param itemCollection a collection of items.
   * @param dataOutputStream where the items must be written.
   * @param dotted whether package names must use dots, instead of slashes.
   * @exception IOException if an error occurs.
   */
  private static void writeItems(
      final Collection<Item> itemCollection,
      final DataOutput dataOutputStream,
      final boolean dotted)
      throws IOException {
    Item[] items = itemCollection.toArray(new Item[0]);
    Arrays.sort(items);
    for (Item item : items) {
      dataOutputStream.writeUTF(item.name);
      dataOutputStream.writeInt(item.access);
      dataOutputStream.writeUTF(dotted ? item.descriptor.replace('/', '.') : item.descriptor);
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Inner classes
  // -----------------------------------------------------------------------------------------------

  private static final class Item implements Comparable<Item> {

    final String name;
    final int access;
    final String descriptor;

    Item(final String name, final int access, final String descriptor) {
      this.name = name;
      this.access = access;
      this.descriptor = descriptor;
    }

    @Override
    public int compareTo(final Item item) {
      int result = name.compareTo(item.name);
      if (result == 0) {
        result = descriptor.compareTo(item.descriptor);
      }
      return result;
    }

    @Override
    public boolean equals(final Object other) {
      if (other instanceof Item) {
        return compareTo((Item) other) == 0;
      }
      return false;
    }

    @Override
    public int hashCode() {
      return name.hashCode() ^ descriptor.hashCode();
    }
  }
}


package org.objectweb.asm.commons;

import java.util.List;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.TypePath;

/**
 * A {@link ClassVisitor} that remaps types with a {@link Remapper}.
 *
 * <p><i>This visitor has several limitations</i>. A non-exhaustive list is the following:
 *
 * <ul>
 *   <li>it cannot remap type names in dynamically computed strings (remapping of type names in
 *       static values is supported).
 *   <li>it cannot remap values derived from type names at compile time, such as
 *       <ul>
 *         <li>type name hashcodes used by some Java compilers to implement the string switch
 *             statement.
 *         <li>some compound strings used by some Java compilers to implement lambda
 *             deserialization.
 *       </ul>
 * </ul>
 *
 * @author Eugene Kuleshov
 */
public class ClassRemapper extends ClassVisitor {

  /** The remapper used to remap the types in the visited class. */
  protected final Remapper remapper;

  /** The internal name of the visited class. */
  protected @InternalForm String className;

  /**
   * Constructs a new {@link ClassRemapper}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #ClassRemapper(int,ClassVisitor,Remapper)} version.
   *
   * @param classVisitor the class visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited class.
   */
  public ClassRemapper(final ClassVisitor classVisitor, final Remapper remapper) {
    this(/* latest api = */ Opcodes.ASM9, classVisitor, remapper);
  }

  /**
   * Constructs a new {@link ClassRemapper}.
   *
   * @param api the ASM API version supported by this remapper. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param classVisitor the class visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited class.
   */
  protected ClassRemapper(final int api, final ClassVisitor classVisitor, final Remapper remapper) {
    super(api, classVisitor);
    this.remapper = remapper;
  }

  @Override
  public void visit(
      final int version,
      final int access,
      final String name,
      final String signature,
      final String superName,
      final String[] interfaces) {
    this.className = name;
    super.visit(
        version,
        access,
        remapper.mapType(name),
        remapper.mapSignature(signature, false),
        remapper.mapType(superName),
        interfaces == null ? null : remapper.mapTypes(interfaces));
  }

  @Override
  public ModuleVisitor visitModule(final String name, final int flags, final String version) {
    ModuleVisitor moduleVisitor = super.visitModule(remapper.mapModuleName(name), flags, version);
    return moduleVisitor == null ? null : createModuleRemapper(moduleVisitor);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitAnnotation(remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? null
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitTypeAnnotation(typeRef, typePath, remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? null
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    if (attribute instanceof ModuleHashesAttribute) {
      ModuleHashesAttribute moduleHashesAttribute = (ModuleHashesAttribute) attribute;
      List<String> modules = moduleHashesAttribute.modules;
      for (int i = 0; i < modules.size(); ++i) {
        modules.set(i, remapper.mapModuleName(modules.get(i)));
      }
    }
    super.visitAttribute(attribute);
  }

  @Override
  public RecordComponentVisitor visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    RecordComponentVisitor recordComponentVisitor =
        super.visitRecordComponent(
            remapper.mapRecordComponentName(className, name, descriptor),
            remapper.mapDesc(descriptor),
            remapper.mapSignature(signature, true));
    return recordComponentVisitor == null
        ? null
        : createRecordComponentRemapper(recordComponentVisitor);
  }

  @Override
  public FieldVisitor visitField(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    FieldVisitor fieldVisitor =
        super.visitField(
            access,
            remapper.mapFieldName(className, name, descriptor),
            remapper.mapDesc(descriptor),
            remapper.mapSignature(signature, true),
            (value == null) ? null : remapper.mapValue(value));
    return fieldVisitor == null ? null : createFieldRemapper(fieldVisitor);
  }

  @Override
  public MethodVisitor visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final String[] exceptions) {
    String remappedDescriptor = remapper.mapMethodDesc(descriptor);
    MethodVisitor methodVisitor =
        super.visitMethod(
            access,
            remapper.mapMethodName(className, name, descriptor),
            remappedDescriptor,
            remapper.mapSignature(signature, false),
            exceptions == null ? null : remapper.mapTypes(exceptions));
    return methodVisitor == null ? null : createMethodRemapper(methodVisitor);
  }

  @Override
  public void visitInnerClass(
      final @InternalForm String name, final @InternalForm String outerName, final @Identifier String innerName, final int access) {
    super.visitInnerClass(
        remapper.mapType(name),
        outerName == null ? null : remapper.mapType(outerName),
        innerName == null ? null : remapper.mapInnerClassName(name, outerName, innerName),
        access);
  }

  @Override
  public void visitOuterClass(final @InternalForm String owner, final String name, final String descriptor) {
    super.visitOuterClass(
        remapper.mapType(owner),
        name == null ? null : remapper.mapMethodName(owner, name, descriptor),
        descriptor == null ? null : remapper.mapMethodDesc(descriptor));
  }

  @Override
  public void visitNestHost(final String nestHost) {
    super.visitNestHost(remapper.mapType(nestHost));
  }

  @Override
  public void visitNestMember(final String nestMember) {
    super.visitNestMember(remapper.mapType(nestMember));
  }

  @Override
  public void visitPermittedSubclass(final String permittedSubclass) {
    super.visitPermittedSubclass(remapper.mapType(permittedSubclass));
  }

  /**
   * Constructs a new remapper for fields. The default implementation of this method returns a new
   * {@link FieldRemapper}.
   *
   * @param fieldVisitor the FieldVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected FieldVisitor createFieldRemapper(final FieldVisitor fieldVisitor) {
    return new FieldRemapper(api, fieldVisitor, remapper);
  }

  /**
   * Constructs a new remapper for methods. The default implementation of this method returns a new
   * {@link MethodRemapper}.
   *
   * @param methodVisitor the MethodVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected MethodVisitor createMethodRemapper(final MethodVisitor methodVisitor) {
    return new MethodRemapper(api, methodVisitor, remapper);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   * @deprecated use {@link #createAnnotationRemapper(String, AnnotationVisitor)} instead.
   */
  @Deprecated
  protected AnnotationVisitor createAnnotationRemapper(final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, /* descriptor= */ null, annotationVisitor, remapper);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param descriptor the descriptor of the visited annotation.
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected AnnotationVisitor createAnnotationRemapper(
      final String descriptor, final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, descriptor, annotationVisitor, remapper)
        .orDeprecatedValue(createAnnotationRemapper(annotationVisitor));
  }

  /**
   * Constructs a new remapper for modules. The default implementation of this method returns a new
   * {@link ModuleRemapper}.
   *
   * @param moduleVisitor the ModuleVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected ModuleVisitor createModuleRemapper(final ModuleVisitor moduleVisitor) {
    return new ModuleRemapper(api, moduleVisitor, remapper);
  }

  /**
   * Constructs a new remapper for record components. The default implementation of this method
   * returns a new {@link RecordComponentRemapper}.
   *
   * @param recordComponentVisitor the RecordComponentVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected RecordComponentVisitor createRecordComponentRemapper(
      final RecordComponentVisitor recordComponentVisitor) {
    return new RecordComponentRemapper(api, recordComponentVisitor, remapper);
  }
}


package org.objectweb.asm.commons;

import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * A {@link MethodVisitor} providing a more detailed API to generate and transform instructions.
 *
 * @author Eric Bruneton
 */
public class InstructionAdapter extends MethodVisitor {

  /** The type of the java.lang.Object class. */
  public static final Type OBJECT_TYPE = Type.getType("Ljava/lang/Object;");

  /**
   * Constructs a new {@link InstructionAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #InstructionAdapter(int, MethodVisitor)} version.
   *
   * @param methodVisitor the method visitor to which this adapter delegates calls.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public InstructionAdapter(final MethodVisitor methodVisitor) {
    this(/* latest api = */ Opcodes.ASM9, methodVisitor);
    if (getClass() != InstructionAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link InstructionAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param methodVisitor the method visitor to which this adapter delegates calls.
   */
  protected InstructionAdapter(final int api, final MethodVisitor methodVisitor) {
    super(api, methodVisitor);
  }

  @Override
  public void visitInsn(final int opcode) {
    switch (opcode) {
      case Opcodes.NOP:
        nop();
        break;
      case Opcodes.ACONST_NULL:
        aconst(null);
        break;
      case Opcodes.ICONST_M1:
      case Opcodes.ICONST_0:
      case Opcodes.ICONST_1:
      case Opcodes.ICONST_2:
      case Opcodes.ICONST_3:
      case Opcodes.ICONST_4:
      case Opcodes.ICONST_5:
        iconst(opcode - Opcodes.ICONST_0);
        break;
      case Opcodes.LCONST_0:
      case Opcodes.LCONST_1:
        lconst((long) (opcode - Opcodes.LCONST_0));
        break;
      case Opcodes.FCONST_0:
      case Opcodes.FCONST_1:
      case Opcodes.FCONST_2:
        fconst((float) (opcode - Opcodes.FCONST_0));
        break;
      case Opcodes.DCONST_0:
      case Opcodes.DCONST_1:
        dconst((double) (opcode - Opcodes.DCONST_0));
        break;
      case Opcodes.IALOAD:
        aload(Type.INT_TYPE);
        break;
      case Opcodes.LALOAD:
        aload(Type.LONG_TYPE);
        break;
      case Opcodes.FALOAD:
        aload(Type.FLOAT_TYPE);
        break;
      case Opcodes.DALOAD:
        aload(Type.DOUBLE_TYPE);
        break;
      case Opcodes.AALOAD:
        aload(OBJECT_TYPE);
        break;
      case Opcodes.BALOAD:
        aload(Type.BYTE_TYPE);
        break;
      case Opcodes.CALOAD:
        aload(Type.CHAR_TYPE);
        break;
      case Opcodes.SALOAD:
        aload(Type.SHORT_TYPE);
        break;
      case Opcodes.IASTORE:
        astore(Type.INT_TYPE);
        break;
      case Opcodes.LASTORE:
        astore(Type.LONG_TYPE);
        break;
      case Opcodes.FASTORE:
        astore(Type.FLOAT_TYPE);
        break;
      case Opcodes.DASTORE:
        astore(Type.DOUBLE_TYPE);
        break;
      case Opcodes.AASTORE:
        astore(OBJECT_TYPE);
        break;
      case Opcodes.BASTORE:
        astore(Type.BYTE_TYPE);
        break;
      case Opcodes.CASTORE:
        astore(Type.CHAR_TYPE);
        break;
      case Opcodes.SASTORE:
        astore(Type.SHORT_TYPE);
        break;
      case Opcodes.POP:
        pop();
        break;
      case Opcodes.POP2:
        pop2();
        break;
      case Opcodes.DUP:
        dup();
        break;
      case Opcodes.DUP_X1:
        dupX1();
        break;
      case Opcodes.DUP_X2:
        dupX2();
        break;
      case Opcodes.DUP2:
        dup2();
        break;
      case Opcodes.DUP2_X1:
        dup2X1();
        break;
      case Opcodes.DUP2_X2:
        dup2X2();
        break;
      case Opcodes.SWAP:
        swap();
        break;
      case Opcodes.IADD:
        add(Type.INT_TYPE);
        break;
      case Opcodes.LADD:
        add(Type.LONG_TYPE);
        break;
      case Opcodes.FADD:
        add(Type.FLOAT_TYPE);
        break;
      case Opcodes.DADD:
        add(Type.DOUBLE_TYPE);
        break;
      case Opcodes.ISUB:
        sub(Type.INT_TYPE);
        break;
      case Opcodes.LSUB:
        sub(Type.LONG_TYPE);
        break;
      case Opcodes.FSUB:
        sub(Type.FLOAT_TYPE);
        break;
      case Opcodes.DSUB:
        sub(Type.DOUBLE_TYPE);
        break;
      case Opcodes.IMUL:
        mul(Type.INT_TYPE);
        break;
      case Opcodes.LMUL:
        mul(Type.LONG_TYPE);
        break;
      case Opcodes.FMUL:
        mul(Type.FLOAT_TYPE);
        break;
      case Opcodes.DMUL:
        mul(Type.DOUBLE_TYPE);
        break;
      case Opcodes.IDIV:
        div(Type.INT_TYPE);
        break;
      case Opcodes.LDIV:
        div(Type.LONG_TYPE);
        break;
      case Opcodes.FDIV:
        div(Type.FLOAT_TYPE);
        break;
      case Opcodes.DDIV:
        div(Type.DOUBLE_TYPE);
        break;
      case Opcodes.IREM:
        rem(Type.INT_TYPE);
        break;
      case Opcodes.LREM:
        rem(Type.LONG_TYPE);
        break;
      case Opcodes.FREM:
        rem(Type.FLOAT_TYPE);
        break;
      case Opcodes.DREM:
        rem(Type.DOUBLE_TYPE);
        break;
      case Opcodes.INEG:
        neg(Type.INT_TYPE);
        break;
      case Opcodes.LNEG:
        neg(Type.LONG_TYPE);
        break;
      case Opcodes.FNEG:
        neg(Type.FLOAT_TYPE);
        break;
      case Opcodes.DNEG:
        neg(Type.DOUBLE_TYPE);
        break;
      case Opcodes.ISHL:
        shl(Type.INT_TYPE);
        break;
      case Opcodes.LSHL:
        shl(Type.LONG_TYPE);
        break;
      case Opcodes.ISHR:
        shr(Type.INT_TYPE);
        break;
      case Opcodes.LSHR:
        shr(Type.LONG_TYPE);
        break;
      case Opcodes.IUSHR:
        ushr(Type.INT_TYPE);
        break;
      case Opcodes.LUSHR:
        ushr(Type.LONG_TYPE);
        break;
      case Opcodes.IAND:
        and(Type.INT_TYPE);
        break;
      case Opcodes.LAND:
        and(Type.LONG_TYPE);
        break;
      case Opcodes.IOR:
        or(Type.INT_TYPE);
        break;
      case Opcodes.LOR:
        or(Type.LONG_TYPE);
        break;
      case Opcodes.IXOR:
        xor(Type.INT_TYPE);
        break;
      case Opcodes.LXOR:
        xor(Type.LONG_TYPE);
        break;
      case Opcodes.I2L:
        cast(Type.INT_TYPE, Type.LONG_TYPE);
        break;
      case Opcodes.I2F:
        cast(Type.INT_TYPE, Type.FLOAT_TYPE);
        break;
      case Opcodes.I2D:
        cast(Type.INT_TYPE, Type.DOUBLE_TYPE);
        break;
      case Opcodes.L2I:
        cast(Type.LONG_TYPE, Type.INT_TYPE);
        break;
      case Opcodes.L2F:
        cast(Type.LONG_TYPE, Type.FLOAT_TYPE);
        break;
      case Opcodes.L2D:
        cast(Type.LONG_TYPE, Type.DOUBLE_TYPE);
        break;
      case Opcodes.F2I:
        cast(Type.FLOAT_TYPE, Type.INT_TYPE);
        break;
      case Opcodes.F2L:
        cast(Type.FLOAT_TYPE, Type.LONG_TYPE);
        break;
      case Opcodes.F2D:
        cast(Type.FLOAT_TYPE, Type.DOUBLE_TYPE);
        break;
      case Opcodes.D2I:
        cast(Type.DOUBLE_TYPE, Type.INT_TYPE);
        break;
      case Opcodes.D2L:
        cast(Type.DOUBLE_TYPE, Type.LONG_TYPE);
        break;
      case Opcodes.D2F:
        cast(Type.DOUBLE_TYPE, Type.FLOAT_TYPE);
        break;
      case Opcodes.I2B:
        cast(Type.INT_TYPE, Type.BYTE_TYPE);
        break;
      case Opcodes.I2C:
        cast(Type.INT_TYPE, Type.CHAR_TYPE);
        break;
      case Opcodes.I2S:
        cast(Type.INT_TYPE, Type.SHORT_TYPE);
        break;
      case Opcodes.LCMP:
        lcmp();
        break;
      case Opcodes.FCMPL:
        cmpl(Type.FLOAT_TYPE);
        break;
      case Opcodes.FCMPG:
        cmpg(Type.FLOAT_TYPE);
        break;
      case Opcodes.DCMPL:
        cmpl(Type.DOUBLE_TYPE);
        break;
      case Opcodes.DCMPG:
        cmpg(Type.DOUBLE_TYPE);
        break;
      case Opcodes.IRETURN:
        areturn(Type.INT_TYPE);
        break;
      case Opcodes.LRETURN:
        areturn(Type.LONG_TYPE);
        break;
      case Opcodes.FRETURN:
        areturn(Type.FLOAT_TYPE);
        break;
      case Opcodes.DRETURN:
        areturn(Type.DOUBLE_TYPE);
        break;
      case Opcodes.ARETURN:
        areturn(OBJECT_TYPE);
        break;
      case Opcodes.RETURN:
        areturn(Type.VOID_TYPE);
        break;
      case Opcodes.ARRAYLENGTH:
        arraylength();
        break;
      case Opcodes.ATHROW:
        athrow();
        break;
      case Opcodes.MONITORENTER:
        monitorenter();
        break;
      case Opcodes.MONITOREXIT:
        monitorexit();
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    switch (opcode) {
      case Opcodes.BIPUSH:
        iconst(operand);
        break;
      case Opcodes.SIPUSH:
        iconst(operand);
        break;
      case Opcodes.NEWARRAY:
        switch (operand) {
          case Opcodes.T_BOOLEAN:
            newarray(Type.BOOLEAN_TYPE);
            break;
          case Opcodes.T_CHAR:
            newarray(Type.CHAR_TYPE);
            break;
          case Opcodes.T_BYTE:
            newarray(Type.BYTE_TYPE);
            break;
          case Opcodes.T_SHORT:
            newarray(Type.SHORT_TYPE);
            break;
          case Opcodes.T_INT:
            newarray(Type.INT_TYPE);
            break;
          case Opcodes.T_FLOAT:
            newarray(Type.FLOAT_TYPE);
            break;
          case Opcodes.T_LONG:
            newarray(Type.LONG_TYPE);
            break;
          case Opcodes.T_DOUBLE:
            newarray(Type.DOUBLE_TYPE);
            break;
          default:
            throw new IllegalArgumentException();
        }
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    switch (opcode) {
      case Opcodes.ILOAD:
        load(varIndex, Type.INT_TYPE);
        break;
      case Opcodes.LLOAD:
        load(varIndex, Type.LONG_TYPE);
        break;
      case Opcodes.FLOAD:
        load(varIndex, Type.FLOAT_TYPE);
        break;
      case Opcodes.DLOAD:
        load(varIndex, Type.DOUBLE_TYPE);
        break;
      case Opcodes.ALOAD:
        load(varIndex, OBJECT_TYPE);
        break;
      case Opcodes.ISTORE:
        store(varIndex, Type.INT_TYPE);
        break;
      case Opcodes.LSTORE:
        store(varIndex, Type.LONG_TYPE);
        break;
      case Opcodes.FSTORE:
        store(varIndex, Type.FLOAT_TYPE);
        break;
      case Opcodes.DSTORE:
        store(varIndex, Type.DOUBLE_TYPE);
        break;
      case Opcodes.ASTORE:
        store(varIndex, OBJECT_TYPE);
        break;
      case Opcodes.RET:
        ret(varIndex);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    Type objectType = Type.getObjectType(type);
    switch (opcode) {
      case Opcodes.NEW:
        anew(objectType);
        break;
      case Opcodes.ANEWARRAY:
        newarray(objectType);
        break;
      case Opcodes.CHECKCAST:
        checkcast(objectType);
        break;
      case Opcodes.INSTANCEOF:
        instanceOf(objectType);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    switch (opcode) {
      case Opcodes.GETSTATIC:
        getstatic(owner, name, descriptor);
        break;
      case Opcodes.PUTSTATIC:
        putstatic(owner, name, descriptor);
        break;
      case Opcodes.GETFIELD:
        getfield(owner, name, descriptor);
        break;
      case Opcodes.PUTFIELD:
        putfield(owner, name, descriptor);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public void visitMethodInsn(
      final int opcodeAndSource,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
      // Redirect the call to the deprecated version of this method.
      super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
      return;
    }
    int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;

    switch (opcode) {
      case Opcodes.INVOKESPECIAL:
        invokespecial(owner, name, descriptor, isInterface);
        break;
      case Opcodes.INVOKEVIRTUAL:
        invokevirtual(owner, name, descriptor, isInterface);
        break;
      case Opcodes.INVOKESTATIC:
        invokestatic(owner, name, descriptor, isInterface);
        break;
      case Opcodes.INVOKEINTERFACE:
        invokeinterface(owner, name, descriptor);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    invokedynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    switch (opcode) {
      case Opcodes.IFEQ:
        ifeq(label);
        break;
      case Opcodes.IFNE:
        ifne(label);
        break;
      case Opcodes.IFLT:
        iflt(label);
        break;
      case Opcodes.IFGE:
        ifge(label);
        break;
      case Opcodes.IFGT:
        ifgt(label);
        break;
      case Opcodes.IFLE:
        ifle(label);
        break;
      case Opcodes.IF_ICMPEQ:
        ificmpeq(label);
        break;
      case Opcodes.IF_ICMPNE:
        ificmpne(label);
        break;
      case Opcodes.IF_ICMPLT:
        ificmplt(label);
        break;
      case Opcodes.IF_ICMPGE:
        ificmpge(label);
        break;
      case Opcodes.IF_ICMPGT:
        ificmpgt(label);
        break;
      case Opcodes.IF_ICMPLE:
        ificmple(label);
        break;
      case Opcodes.IF_ACMPEQ:
        ifacmpeq(label);
        break;
      case Opcodes.IF_ACMPNE:
        ifacmpne(label);
        break;
      case Opcodes.GOTO:
        goTo(label);
        break;
      case Opcodes.JSR:
        jsr(label);
        break;
      case Opcodes.IFNULL:
        ifnull(label);
        break;
      case Opcodes.IFNONNULL:
        ifnonnull(label);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public void visitLabel(final Label label) {
    mark(label);
  }

  @Override
  public void visitLdcInsn(final Object value) {
    if (api < Opcodes.ASM5
        && (value instanceof Handle
            || (value instanceof Type && ((Type) value).getSort() == Type.METHOD))) {
      throw new UnsupportedOperationException("This feature requires ASM5");
    }
    if (api < Opcodes.ASM7 && value instanceof ConstantDynamic) {
      throw new UnsupportedOperationException("This feature requires ASM7");
    }
    if (value instanceof Integer) {
      iconst((Integer) value);
    } else if (value instanceof Byte) {
      iconst(((Byte) value).intValue());
    } else if (value instanceof Character) {
      iconst(((Character) value).charValue());
    } else if (value instanceof Short) {
      iconst(((Short) value).intValue());
    } else if (value instanceof Boolean) {
      iconst(((Boolean) value).booleanValue() ? 1 : 0);
    } else if (value instanceof Float) {
      fconst((Float) value);
    } else if (value instanceof Long) {
      lconst((Long) value);
    } else if (value instanceof Double) {
      dconst((Double) value);
    } else if (value instanceof String) {
      aconst(value);
    } else if (value instanceof Type) {
      tconst((Type) value);
    } else if (value instanceof Handle) {
      hconst((Handle) value);
    } else if (value instanceof ConstantDynamic) {
      cconst((ConstantDynamic) value);
    } else {
      throw new IllegalArgumentException();
    }
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    iinc(varIndex, increment);
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    tableswitch(min, max, dflt, labels);
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    lookupswitch(dflt, keys, labels);
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    multianewarray(descriptor, numDimensions);
  }

  // -----------------------------------------------------------------------------------------------

  /** Generates a nop instruction. */
  public void nop() {
    mv.visitInsn(Opcodes.NOP);
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param value the constant to be pushed on the stack. This parameter must be an {@link Integer},
   *     a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link Type} of
   *     OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is 49, a
   *     {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle constants,
   *     for classes whose version is 51 or a {@link ConstantDynamic} for a constant dynamic for
   *     classes whose version is 55.
   */
  public void aconst(final Object value) {
    if (value == null) {
      mv.visitInsn(Opcodes.ACONST_NULL);
    } else {
      mv.visitLdcInsn(value);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param intValue the constant to be pushed on the stack.
   */
  public void iconst(final int intValue) {
    if (intValue >= -1 && intValue <= 5) {
      mv.visitInsn(Opcodes.ICONST_0 + intValue);
    } else if (intValue >= Byte.MIN_VALUE && intValue <= Byte.MAX_VALUE) {
      mv.visitIntInsn(Opcodes.BIPUSH, intValue);
    } else if (intValue >= Short.MIN_VALUE && intValue <= Short.MAX_VALUE) {
      mv.visitIntInsn(Opcodes.SIPUSH, intValue);
    } else {
      mv.visitLdcInsn(intValue);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param longValue the constant to be pushed on the stack.
   */
  public void lconst(final long longValue) {
    if (longValue == 0L || longValue == 1L) {
      mv.visitInsn(Opcodes.LCONST_0 + (int) longValue);
    } else {
      mv.visitLdcInsn(longValue);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param floatValue the constant to be pushed on the stack.
   */
  public void fconst(final float floatValue) {
    int bits = Float.floatToIntBits(floatValue);
    if (bits == 0L || bits == 0x3F800000 || bits == 0x40000000) { // 0..2
      mv.visitInsn(Opcodes.FCONST_0 + (int) floatValue);
    } else {
      mv.visitLdcInsn(floatValue);
    }
  }

  /**
   * Generates the instruction to push the given value on the stack.
   *
   * @param doubleValue the constant to be pushed on the stack.
   */
  public void dconst(final double doubleValue) {
    long bits = Double.doubleToLongBits(doubleValue);
    if (bits == 0L || bits == 0x3FF0000000000000L) { // +0.0d and 1.0d
      mv.visitInsn(Opcodes.DCONST_0 + (int) doubleValue);
    } else {
      mv.visitLdcInsn(doubleValue);
    }
  }

  /**
   * Generates the instruction to push the given type on the stack.
   *
   * @param type the type to be pushed on the stack.
   */
  public void tconst(final Type type) {
    mv.visitLdcInsn(type);
  }

  /**
   * Generates the instruction to push the given handle on the stack.
   *
   * @param handle the handle to be pushed on the stack.
   */
  public void hconst(final Handle handle) {
    mv.visitLdcInsn(handle);
  }

  /**
   * Generates the instruction to push the given constant dynamic on the stack.
   *
   * @param constantDynamic the constant dynamic to be pushed on the stack.
   */
  public void cconst(final ConstantDynamic constantDynamic) {
    mv.visitLdcInsn(constantDynamic);
  }

  public void load(final int varIndex, final Type type) {
    mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), varIndex);
  }

  public void aload(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IALOAD));
  }

  public void store(final int varIndex, final Type type) {
    mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), varIndex);
  }

  public void astore(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IASTORE));
  }

  public void pop() {
    mv.visitInsn(Opcodes.POP);
  }

  public void pop2() {
    mv.visitInsn(Opcodes.POP2);
  }

  public void dup() {
    mv.visitInsn(Opcodes.DUP);
  }

  public void dup2() {
    mv.visitInsn(Opcodes.DUP2);
  }

  public void dupX1() {
    mv.visitInsn(Opcodes.DUP_X1);
  }

  public void dupX2() {
    mv.visitInsn(Opcodes.DUP_X2);
  }

  public void dup2X1() {
    mv.visitInsn(Opcodes.DUP2_X1);
  }

  public void dup2X2() {
    mv.visitInsn(Opcodes.DUP2_X2);
  }

  public void swap() {
    mv.visitInsn(Opcodes.SWAP);
  }

  public void add(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IADD));
  }

  public void sub(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.ISUB));
  }

  public void mul(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IMUL));
  }

  public void div(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IDIV));
  }

  public void rem(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IREM));
  }

  public void neg(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.INEG));
  }

  public void shl(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.ISHL));
  }

  public void shr(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.ISHR));
  }

  public void ushr(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IUSHR));
  }

  public void and(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IAND));
  }

  public void or(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IOR));
  }

  public void xor(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IXOR));
  }

  public void iinc(final int varIndex, final int increment) {
    mv.visitIincInsn(varIndex, increment);
  }

  /**
   * Generates the instruction to cast from the first given type to the other.
   *
   * @param from a Type.
   * @param to a Type.
   */
  public void cast(final Type from, final Type to) {
    cast(mv, from, to);
  }

  /**
   * Generates the instruction to cast from the first given type to the other.
   *
   * @param methodVisitor the method visitor to use to generate the instruction.
   * @param from a Type.
   * @param to a Type.
   */
  static void cast(final MethodVisitor methodVisitor, final Type from, final Type to) {
    if (from != to) {
      if (from == Type.DOUBLE_TYPE) {
        if (to == Type.FLOAT_TYPE) {
          methodVisitor.visitInsn(Opcodes.D2F);
        } else if (to == Type.LONG_TYPE) {
          methodVisitor.visitInsn(Opcodes.D2L);
        } else {
          methodVisitor.visitInsn(Opcodes.D2I);
          cast(methodVisitor, Type.INT_TYPE, to);
        }
      } else if (from == Type.FLOAT_TYPE) {
        if (to == Type.DOUBLE_TYPE) {
          methodVisitor.visitInsn(Opcodes.F2D);
        } else if (to == Type.LONG_TYPE) {
          methodVisitor.visitInsn(Opcodes.F2L);
        } else {
          methodVisitor.visitInsn(Opcodes.F2I);
          cast(methodVisitor, Type.INT_TYPE, to);
        }
      } else if (from == Type.LONG_TYPE) {
        if (to == Type.DOUBLE_TYPE) {
          methodVisitor.visitInsn(Opcodes.L2D);
        } else if (to == Type.FLOAT_TYPE) {
          methodVisitor.visitInsn(Opcodes.L2F);
        } else {
          methodVisitor.visitInsn(Opcodes.L2I);
          cast(methodVisitor, Type.INT_TYPE, to);
        }
      } else {
        if (to == Type.BYTE_TYPE) {
          methodVisitor.visitInsn(Opcodes.I2B);
        } else if (to == Type.CHAR_TYPE) {
          methodVisitor.visitInsn(Opcodes.I2C);
        } else if (to == Type.DOUBLE_TYPE) {
          methodVisitor.visitInsn(Opcodes.I2D);
        } else if (to == Type.FLOAT_TYPE) {
          methodVisitor.visitInsn(Opcodes.I2F);
        } else if (to == Type.LONG_TYPE) {
          methodVisitor.visitInsn(Opcodes.I2L);
        } else if (to == Type.SHORT_TYPE) {
          methodVisitor.visitInsn(Opcodes.I2S);
        }
      }
    }
  }

  public void lcmp() {
    mv.visitInsn(Opcodes.LCMP);
  }

  public void cmpl(final Type type) {
    mv.visitInsn(type == Type.FLOAT_TYPE ? Opcodes.FCMPL : Opcodes.DCMPL);
  }

  public void cmpg(final Type type) {
    mv.visitInsn(type == Type.FLOAT_TYPE ? Opcodes.FCMPG : Opcodes.DCMPG);
  }

  public void ifeq(final Label label) {
    mv.visitJumpInsn(Opcodes.IFEQ, label);
  }

  public void ifne(final Label label) {
    mv.visitJumpInsn(Opcodes.IFNE, label);
  }

  public void iflt(final Label label) {
    mv.visitJumpInsn(Opcodes.IFLT, label);
  }

  public void ifge(final Label label) {
    mv.visitJumpInsn(Opcodes.IFGE, label);
  }

  public void ifgt(final Label label) {
    mv.visitJumpInsn(Opcodes.IFGT, label);
  }

  public void ifle(final Label label) {
    mv.visitJumpInsn(Opcodes.IFLE, label);
  }

  public void ificmpeq(final Label label) {
    mv.visitJumpInsn(Opcodes.IF_ICMPEQ, label);
  }

  public void ificmpne(final Label label) {
    mv.visitJumpInsn(Opcodes.IF_ICMPNE, label);
  }

  public void ificmplt(final Label label) {
    mv.visitJumpInsn(Opcodes.IF_ICMPLT, label);
  }

  public void ificmpge(final Label label) {
    mv.visitJumpInsn(Opcodes.IF_ICMPGE, label);
  }

  public void ificmpgt(final Label label) {
    mv.visitJumpInsn(Opcodes.IF_ICMPGT, label);
  }

  public void ificmple(final Label label) {
    mv.visitJumpInsn(Opcodes.IF_ICMPLE, label);
  }

  public void ifacmpeq(final Label label) {
    mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);
  }

  public void ifacmpne(final Label label) {
    mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);
  }

  public void goTo(final Label label) {
    mv.visitJumpInsn(Opcodes.GOTO, label);
  }

  public void jsr(final Label label) {
    mv.visitJumpInsn(Opcodes.JSR, label);
  }

  public void ret(final int varIndex) {
    mv.visitVarInsn(Opcodes.RET, varIndex);
  }

  public void tableswitch(final int min, final int max, final Label dflt, final Label... labels) {
    mv.visitTableSwitchInsn(min, max, dflt, labels);
  }

  public void lookupswitch(final Label dflt, final int[] keys, final Label[] labels) {
    mv.visitLookupSwitchInsn(dflt, keys, labels);
  }

  public void areturn(final Type type) {
    mv.visitInsn(type.getOpcode(Opcodes.IRETURN));
  }

  public void getstatic(final @InternalForm String owner, final String name, final String descriptor) {
    mv.visitFieldInsn(Opcodes.GETSTATIC, owner, name, descriptor);
  }

  public void putstatic(final @InternalForm String owner, final String name, final String descriptor) {
    mv.visitFieldInsn(Opcodes.PUTSTATIC, owner, name, descriptor);
  }

  public void getfield(final @InternalForm String owner, final String name, final String descriptor) {
    mv.visitFieldInsn(Opcodes.GETFIELD, owner, name, descriptor);
  }

  public void putfield(final @InternalForm String owner, final String name, final String descriptor) {
    mv.visitFieldInsn(Opcodes.PUTFIELD, owner, name, descriptor);
  }

  /**
   * Deprecated.
   *
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @deprecated use {@link #invokevirtual(String, String, String, boolean)} instead.
   */
  @Deprecated
  public void invokevirtual(final @InternalForm String owner, final String name, final String descriptor) {
    if (api >= Opcodes.ASM5) {
      invokevirtual(owner, name, descriptor, false);
      return;
    }
    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, descriptor);
  }

  /**
   * Generates the instruction to call the given virtual method.
   *
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param isInterface if the method's owner class is an interface.
   */
  public void invokevirtual(
      final @InternalForm String owner, final String name, final String descriptor, final boolean isInterface) {
    if (api < Opcodes.ASM5) {
      if (isInterface) {
        throw new UnsupportedOperationException("INVOKEVIRTUAL on interfaces require ASM 5");
      }
      invokevirtual(owner, name, descriptor);
      return;
    }
    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, descriptor, isInterface);
  }

  /**
   * Deprecated.
   *
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @deprecated use {@link #invokespecial(String, String, String, boolean)} instead.
   */
  @Deprecated
  public void invokespecial(final @InternalForm String owner, final String name, final String descriptor) {
    if (api >= Opcodes.ASM5) {
      invokespecial(owner, name, descriptor, false);
      return;
    }
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL, owner, name, descriptor, false);
  }

  /**
   * Generates the instruction to call the given special method.
   *
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param isInterface if the method's owner class is an interface.
   */
  public void invokespecial(
      final @InternalForm String owner, final String name, final String descriptor, final boolean isInterface) {
    if (api < Opcodes.ASM5) {
      if (isInterface) {
        throw new UnsupportedOperationException("INVOKESPECIAL on interfaces require ASM 5");
      }
      invokespecial(owner, name, descriptor);
      return;
    }
    mv.visitMethodInsn(Opcodes.INVOKESPECIAL, owner, name, descriptor, isInterface);
  }

  /**
   * Deprecated.
   *
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @deprecated use {@link #invokestatic(String, String, String, boolean)} instead.
   */
  @Deprecated
  public void invokestatic(final @InternalForm String owner, final String name, final String descriptor) {
    if (api >= Opcodes.ASM5) {
      invokestatic(owner, name, descriptor, false);
      return;
    }
    mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, descriptor, false);
  }

  /**
   * Generates the instruction to call the given static method.
   *
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param isInterface if the method's owner class is an interface.
   */
  public void invokestatic(
      final @InternalForm String owner, final String name, final String descriptor, final boolean isInterface) {
    if (api < Opcodes.ASM5) {
      if (isInterface) {
        throw new UnsupportedOperationException("INVOKESTATIC on interfaces require ASM 5");
      }
      invokestatic(owner, name, descriptor);
      return;
    }
    mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, descriptor, isInterface);
  }

  /**
   * Generates the instruction to call the given interface method.
   *
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   */
  public void invokeinterface(final @InternalForm String owner, final String name, final String descriptor) {
    mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, owner, name, descriptor, true);
  }

  /**
   * Generates the instruction to call the given dynamic method.
   *
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param bootstrapMethodHandle the bootstrap method.
   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be
   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link
   *     Type}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify
   *     the content of the array so a caller should expect that this array may change.
   */
  public void invokedynamic(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object[] bootstrapMethodArguments) {
    mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
  }

  public void anew(final Type type) {
    mv.visitTypeInsn(Opcodes.NEW, type.getInternalName());
  }

  /**
   * Generates the instruction to create and push on the stack an array of the given type.
   *
   * @param type an array Type.
   */
  public void newarray(final Type type) {
    newarray(mv, type);
  }

  /**
   * Generates the instruction to create and push on the stack an array of the given type.
   *
   * @param methodVisitor the method visitor to use to generate the instruction.
   * @param type an array Type.
   */
  static void newarray(final MethodVisitor methodVisitor, final Type type) {
    int arrayType;
    switch (type.getSort()) {
      case Type.BOOLEAN:
        arrayType = Opcodes.T_BOOLEAN;
        break;
      case Type.CHAR:
        arrayType = Opcodes.T_CHAR;
        break;
      case Type.BYTE:
        arrayType = Opcodes.T_BYTE;
        break;
      case Type.SHORT:
        arrayType = Opcodes.T_SHORT;
        break;
      case Type.INT:
        arrayType = Opcodes.T_INT;
        break;
      case Type.FLOAT:
        arrayType = Opcodes.T_FLOAT;
        break;
      case Type.LONG:
        arrayType = Opcodes.T_LONG;
        break;
      case Type.DOUBLE:
        arrayType = Opcodes.T_DOUBLE;
        break;
      default:
        methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, type.getInternalName());
        return;
    }
    methodVisitor.visitIntInsn(Opcodes.NEWARRAY, arrayType);
  }

  public void arraylength() {
    mv.visitInsn(Opcodes.ARRAYLENGTH);
  }

  public void athrow() {
    mv.visitInsn(Opcodes.ATHROW);
  }

  public void checkcast(final Type type) {
    mv.visitTypeInsn(Opcodes.CHECKCAST, type.getInternalName());
  }

  public void instanceOf(final Type type) {
    mv.visitTypeInsn(Opcodes.INSTANCEOF, type.getInternalName());
  }

  public void monitorenter() {
    mv.visitInsn(Opcodes.MONITORENTER);
  }

  public void monitorexit() {
    mv.visitInsn(Opcodes.MONITOREXIT);
  }

  public void multianewarray(final String descriptor, final int numDimensions) {
    mv.visitMultiANewArrayInsn(descriptor, numDimensions);
  }

  public void ifnull(final Label label) {
    mv.visitJumpInsn(Opcodes.IFNULL, label);
  }

  public void ifnonnull(final Label label) {
    mv.visitJumpInsn(Opcodes.IFNONNULL, label);
  }

  public void mark(final Label label) {
    mv.visitLabel(label);
  }
}


package org.objectweb.asm.commons;

import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.signature.SignatureReader;
import org.objectweb.asm.signature.SignatureVisitor;
import org.objectweb.asm.signature.SignatureWriter;

/**
 * A class responsible for remapping types and names.
 *
 * @author Eugene Kuleshov
 */
public abstract class Remapper {

  /**
   * Returns the given descriptor, remapped with {@link #map(String)}.
   *
   * @param descriptor a type descriptor.
   * @return the given descriptor, with its [array element type] internal name remapped with {@link
   *     #map(String)} (if the descriptor corresponds to an array or object type, otherwise the
   *     descriptor is returned as is). See {@link Type#getInternalName()}.
   */
  public String mapDesc(final String descriptor) {
    return mapType(Type.getType(descriptor)).getDescriptor();
  }

  /**
   * Returns the given {@link Type}, remapped with {@link #map(String)} or {@link
   * #mapMethodDesc(String)}.
   *
   * @param type a type, which can be a method type.
   * @return the given type, with its [array element type] internal name remapped with {@link
   *     #map(String)} (if the type is an array or object type, otherwise the type is returned as
   *     is) or, of the type is a method type, with its descriptor remapped with {@link
   *     #mapMethodDesc(String)}. See {@link Type#getInternalName()}.
   */
  private Type mapType(final Type type) {
    switch (type.getSort()) {
      case Type.ARRAY:
        StringBuilder remappedDescriptor = new StringBuilder();
        for (int i = 0; i < type.getDimensions(); ++i) {
          remappedDescriptor.append('[');
        }
        remappedDescriptor.append(mapType(type.getElementType()).getDescriptor());
        return Type.getType(remappedDescriptor.toString());
      case Type.OBJECT:
        String remappedInternalName = map(type.getInternalName());
        return remappedInternalName != null ? Type.getObjectType(remappedInternalName) : type;
      case Type.METHOD:
        return Type.getMethodType(mapMethodDesc(type.getDescriptor()));
      default:
        return type;
    }
  }

  /**
   * Returns the given internal name, remapped with {@link #map(String)}.
   *
   * @param internalName the internal name (or array type descriptor) of some (array) class (see
   *     {@link Type#getInternalName()}).
   * @return the given internal name, remapped with {@link #map(String)} (see {@link
   *     Type#getInternalName()}).
   */
  public @InternalForm String mapType(final @InternalForm String internalName) {
    if (internalName == null) {
      return null;
    }
    return mapType(Type.getObjectType(internalName)).getInternalName();
  }

  /**
   * Returns the given internal names, remapped with {@link #map(String)}.
   *
   * @param internalNames the internal names (or array type descriptors) of some (array) classes
   *     (see {@link Type#getInternalName()}).
   * @return the given internal name, remapped with {@link #map(String)} (see {@link
   *     Type#getInternalName()}).
   */
  public @InternalForm String[] mapTypes(final @InternalForm String[] internalNames) {
    String[] remappedInternalNames = null;
    for (int i = 0; i < internalNames.length; ++i) {
      String internalName = internalNames[i];
      String remappedInternalName = mapType(internalName);
      if (remappedInternalName != null) {
        if (remappedInternalNames == null) {
          remappedInternalNames = internalNames.clone();
        }
        remappedInternalNames[i] = remappedInternalName;
      }
    }
    return remappedInternalNames != null ? remappedInternalNames : internalNames;
  }

  /**
   * Returns the given method descriptor, with its argument and return type descriptors remapped
   * with {@link #mapDesc(String)}.
   *
   * @param methodDescriptor a method descriptor.
   * @return the given method descriptor, with its argument and return type descriptors remapped
   *     with {@link #mapDesc(String)}.
   */
  public String mapMethodDesc(final String methodDescriptor) {
    if ("()V".equals(methodDescriptor)) {
      return methodDescriptor;
    }

    StringBuilder stringBuilder = new StringBuilder("(");
    for (Type argumentType : Type.getArgumentTypes(methodDescriptor)) {
      stringBuilder.append(mapType(argumentType).getDescriptor());
    }
    Type returnType = Type.getReturnType(methodDescriptor);
    if (returnType == Type.VOID_TYPE) {
      stringBuilder.append(")V");
    } else {
      stringBuilder.append(')').append(mapType(returnType).getDescriptor());
    }
    return stringBuilder.toString();
  }

  /**
   * Returns the given value, remapped with this remapper. Possible values are {@link Boolean},
   * {@link Byte}, {@link Short}, {@link Character}, {@link Integer}, {@link Long}, {@link Double},
   * {@link Float}, {@link String}, {@link Type}, {@link Handle}, {@link ConstantDynamic} or arrays
   * of primitive types .
   *
   * @param value an object. Only {@link Type}, {@link Handle} and {@link ConstantDynamic} values
   *     are remapped.
   * @return the given value, remapped with this remapper.
   */
  public Object mapValue(final Object value) {
    if (value instanceof Type) {
      return mapType((Type) value);
    }
    if (value instanceof Handle) {
      Handle handle = (Handle) value;
      boolean isFieldHandle = handle.getTag() <= Opcodes.H_PUTSTATIC;

      return new Handle(
          handle.getTag(),
          mapType(handle.getOwner()),
          isFieldHandle
              ? mapFieldName(handle.getOwner(), handle.getName(), handle.getDesc())
              : mapMethodName(handle.getOwner(), handle.getName(), handle.getDesc()),
          isFieldHandle ? mapDesc(handle.getDesc()) : mapMethodDesc(handle.getDesc()),
          handle.isInterface());
    }
    if (value instanceof ConstantDynamic) {
      ConstantDynamic constantDynamic = (ConstantDynamic) value;
      int bootstrapMethodArgumentCount = constantDynamic.getBootstrapMethodArgumentCount();
      Object[] remappedBootstrapMethodArguments = new Object[bootstrapMethodArgumentCount];
      for (int i = 0; i < bootstrapMethodArgumentCount; ++i) {
        remappedBootstrapMethodArguments[i] =
            mapValue(constantDynamic.getBootstrapMethodArgument(i));
      }
      String descriptor = constantDynamic.getDescriptor();
      return new ConstantDynamic(
          mapInvokeDynamicMethodName(constantDynamic.getName(), descriptor),
          mapDesc(descriptor),
          (Handle) mapValue(constantDynamic.getBootstrapMethod()),
          remappedBootstrapMethodArguments);
    }
    return value;
  }

  /**
   * Returns the given signature, remapped with the {@link SignatureVisitor} returned by {@link
   * #createSignatureRemapper(SignatureVisitor)}.
   *
   * @param signature a <i>JavaTypeSignature</i>, <i>ClassSignature</i> or <i>MethodSignature</i>.
   * @param typeSignature whether the given signature is a <i>JavaTypeSignature</i>.
   * @return signature the given signature, remapped with the {@link SignatureVisitor} returned by
   *     {@link #createSignatureRemapper(SignatureVisitor)}.
   */
  public String mapSignature(final String signature, final boolean typeSignature) {
    if (signature == null) {
      return null;
    }
    SignatureReader signatureReader = new SignatureReader(signature);
    SignatureWriter signatureWriter = new SignatureWriter();
    SignatureVisitor signatureRemapper = createSignatureRemapper(signatureWriter);
    if (typeSignature) {
      signatureReader.acceptType(signatureRemapper);
    } else {
      signatureReader.accept(signatureRemapper);
    }
    return signatureWriter.toString();
  }

  /**
   * Constructs a new remapper for signatures. The default implementation of this method returns a
   * new {@link SignatureRemapper}.
   *
   * @param signatureVisitor the SignatureVisitor the remapper must delegate to.
   * @return the newly created remapper.
   * @deprecated use {@link #createSignatureRemapper} instead.
   */
  @Deprecated
  protected SignatureVisitor createRemappingSignatureAdapter(
      final SignatureVisitor signatureVisitor) {
    return createSignatureRemapper(signatureVisitor);
  }

  /**
   * Constructs a new remapper for signatures. The default implementation of this method returns a
   * new {@link SignatureRemapper}.
   *
   * @param signatureVisitor the SignatureVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected SignatureVisitor createSignatureRemapper(final SignatureVisitor signatureVisitor) {
    return new SignatureRemapper(signatureVisitor, this);
  }

  /**
   * Maps an annotation attribute name. The default implementation of this method returns the given
   * name, unchanged. Subclasses can override.
   *
   * @param descriptor the descriptor of the annotation class.
   * @param name the name of the annotation attribute.
   * @return the new name of the annotation attribute.
   */
  public String mapAnnotationAttributeName(final String descriptor, final String name) {
    return name;
  }

  /**
   * Maps an inner class name to its new name. The default implementation of this method provides a
   * strategy that will work for inner classes produced by Java, but not necessarily other
   * languages. Subclasses can override.
   *
   * @param name the internal name of the inner class (see {@link
   *     Type#getInternalName()}).
   * @param ownerName the internal name of the owner class of the inner class (see {@link
   *     Type#getInternalName()}).
   * @param innerName the internal name of the inner class (see {@link Type#getInternalName()}).
   * @return the new inner name of the inner class.
   */
  public String mapInnerClassName(
      final @InternalForm String name, final @InternalForm String ownerName, final @InternalForm String innerName) {
    final String remappedInnerName = this.mapType(name);

    if (remappedInnerName.equals(name)) {
      return innerName;
    } else {
      int originSplit = name.lastIndexOf('/');
      int remappedSplit = remappedInnerName.lastIndexOf('/');
      if (originSplit != -1 && remappedSplit != -1) {
        if (name.substring(originSplit).equals(remappedInnerName.substring(remappedSplit))) {
          // class name not changed
          return innerName;
        }
      }
    }

    if (remappedInnerName.contains("$")) {
      int index = remappedInnerName.lastIndexOf('$') + 1;
      while (index < remappedInnerName.length()
          && Character.isDigit(remappedInnerName.charAt(index))) {
        index++;
      }
      return remappedInnerName.substring(index);
    } else {
      return innerName;
    }
  }

  /**
   * Maps a method name to its new name. The default implementation of this method returns the given
   * name, unchanged. Subclasses can override.
   *
   * @param owner the internal name of the owner class of the method (see {@link
   *     Type#getInternalName()}).
   * @param name the name of the method.
   * @param descriptor the descriptor of the method.
   * @return the new name of the method.
   */
  public String mapMethodName(final @InternalForm String owner, final String name, final String descriptor) {
    return name;
  }

  /**
   * Maps an invokedynamic or a constant dynamic method name to its new name. The default
   * implementation of this method returns the given name, unchanged. Subclasses can override.
   *
   * @param name the name of the method.
   * @param descriptor the descriptor of the method.
   * @return the new name of the method.
   */
  public String mapInvokeDynamicMethodName(final String name, final String descriptor) {
    return name;
  }

  /**
   * Maps a record component name to its new name. The default implementation of this method returns
   * the given name, unchanged. Subclasses can override.
   *
   * @param owner the internal name of the owner class of the field (see {@link
   *     Type#getInternalName()}).
   * @param name the name of the field.
   * @param descriptor the descriptor of the field.
   * @return the new name of the field.
   */
  public String mapRecordComponentName(
      final @InternalForm String owner, final String name, final String descriptor) {
    return name;
  }

  /**
   * Maps a field name to its new name. The default implementation of this method returns the given
   * name, unchanged. Subclasses can override.
   *
   * @param owner the internal name of the owner class of the field (see {@link
   *     Type#getInternalName()}).
   * @param name the name of the field.
   * @param descriptor the descriptor of the field.
   * @return the new name of the field.
   */
  public String mapFieldName(final @InternalForm String owner, final String name, final String descriptor) {
    return name;
  }

  /**
   * Maps a package name to its new name. The default implementation of this method returns the
   * given name, unchanged. Subclasses can override.
   *
   * @param name the fully qualified name of the package (using dots).
   * @return the new name of the package.
   */
  public String mapPackageName(final String name) {
    return name;
  }

  /**
   * Maps a module name to its new name. The default implementation of this method returns the given
   * name, unchanged. Subclasses can override.
   *
   * @param name the fully qualified name (using dots) of a module.
   * @return the new name of the module.
   */
  public String mapModuleName(final String name) {
    return name;
  }

  /**
   * Maps the internal name of a class to its new name. The default implementation of this method
   * returns the given name, unchanged. Subclasses can override.
   *
   * @param internalName the internal name of a class (see {@link Type#getInternalName()}).
   * @return the new internal name (see {@link Type#getInternalName()}).
   */
  public @InternalForm String map(final @InternalForm String internalName) {
    return internalName;
  }
}

package org.objectweb.asm.commons;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.TypePath;

/**
 * A {@link MethodVisitor} that renumbers local variables in their order of appearance. This adapter
 * allows one to easily add new local variables to a method. It may be used by inheriting from this
 * class, but the preferred way of using it is via delegation: the next visitor in the chain can
 * indeed add new locals when needed by calling {@link #newLocal} on this adapter (this requires a
 * reference back to this {@link LocalVariablesSorter}).
 *
 * @author Chris Nokleberg
 * @author Eugene Kuleshov
 * @author Eric Bruneton
 */
public class LocalVariablesSorter extends MethodVisitor {

  /** The type of the java.lang.Object class. */
  private static final Type OBJECT_TYPE = Type.getObjectType("java/lang/Object");

  /**
   * The mapping from old to new local variable indices. A local variable at index i of size 1 is
   * remapped to 'mapping[2*i]', while a local variable at index i of size 2 is remapped to
   * 'mapping[2*i+1]'.
   */
  private int[] remappedVariableIndices = new int[40];

  /**
   * The local variable types after remapping. The format of this array is the same as in {@link
   * MethodVisitor#visitFrame}, except that long and double types use two slots.
   */
  private Object[] remappedLocalTypes = new Object[20];

  /** The index of the first local variable, after formal parameters. */
  protected final int firstLocal;

  /** The index of the next local variable to be created by {@link #newLocal}. */
  protected int nextLocal;

  /**
   * Constructs a new {@link LocalVariablesSorter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #LocalVariablesSorter(int, int, String, MethodVisitor)}
   * version.
   *
   * @param access access flags of the adapted method.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param methodVisitor the method visitor to which this adapter delegates calls.
   * @throws IllegalStateException if a subclass calls this constructor.
   */
  public LocalVariablesSorter(
      final int access, final String descriptor, final MethodVisitor methodVisitor) {
    this(/* latest api = */ Opcodes.ASM9, access, descriptor, methodVisitor);
    if (getClass() != LocalVariablesSorter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link LocalVariablesSorter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param access access flags of the adapted method.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param methodVisitor the method visitor to which this adapter delegates calls.
   */
  protected LocalVariablesSorter(
      final int api, final int access, final String descriptor, final MethodVisitor methodVisitor) {
    super(api, methodVisitor);
    nextLocal = (Opcodes.ACC_STATIC & access) == 0 ? 1 : 0;
    for (Type argumentType : Type.getArgumentTypes(descriptor)) {
      nextLocal += argumentType.getSize();
    }
    firstLocal = nextLocal;
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    Type varType;
    switch (opcode) {
      case Opcodes.LLOAD:
      case Opcodes.LSTORE:
        varType = Type.LONG_TYPE;
        break;
      case Opcodes.DLOAD:
      case Opcodes.DSTORE:
        varType = Type.DOUBLE_TYPE;
        break;
      case Opcodes.FLOAD:
      case Opcodes.FSTORE:
        varType = Type.FLOAT_TYPE;
        break;
      case Opcodes.ILOAD:
      case Opcodes.ISTORE:
        varType = Type.INT_TYPE;
        break;
      case Opcodes.ALOAD:
      case Opcodes.ASTORE:
      case Opcodes.RET:
        varType = OBJECT_TYPE;
        break;
      default:
        throw new IllegalArgumentException("Invalid opcode " + opcode);
    }
    super.visitVarInsn(opcode, remap(varIndex, varType));
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    super.visitIincInsn(remap(varIndex, Type.INT_TYPE), increment);
  }

  @Override
  public void visitMaxs(final int maxStack, final int maxLocals) {
    super.visitMaxs(maxStack, nextLocal);
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    int remappedIndex = remap(index, Type.getType(descriptor));
    super.visitLocalVariable(name, descriptor, signature, start, end, remappedIndex);
  }

  @Override
  public AnnotationVisitor visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    Type type = Type.getType(descriptor);
    int[] remappedIndex = new int[index.length];
    for (int i = 0; i < remappedIndex.length; ++i) {
      remappedIndex[i] = remap(index[i], type);
    }
    return super.visitLocalVariableAnnotation(
        typeRef, typePath, start, end, remappedIndex, descriptor, visible);
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    if (type != Opcodes.F_NEW) { // Uncompressed frame.
      throw new IllegalArgumentException(
          "LocalVariablesSorter only accepts expanded frames (see ClassReader.EXPAND_FRAMES)");
    }

    // Create a copy of remappedLocals.
    Object[] oldRemappedLocals = new Object[remappedLocalTypes.length];
    System.arraycopy(remappedLocalTypes, 0, oldRemappedLocals, 0, oldRemappedLocals.length);

    updateNewLocals(remappedLocalTypes);

    // Copy the types from 'local' to 'remappedLocals'. 'remappedLocals' already contains the
    // variables added with 'newLocal'.
    int oldVar = 0; // Old local variable index.
    for (int i = 0; i < numLocal; ++i) {
      Object localType = local[i];
      if (localType != Opcodes.TOP) {
        Type varType = OBJECT_TYPE;
        if (localType == Opcodes.INTEGER) {
          varType = Type.INT_TYPE;
        } else if (localType == Opcodes.FLOAT) {
          varType = Type.FLOAT_TYPE;
        } else if (localType == Opcodes.LONG) {
          varType = Type.LONG_TYPE;
        } else if (localType == Opcodes.DOUBLE) {
          varType = Type.DOUBLE_TYPE;
        } else if (localType instanceof String) {
          varType = Type.getObjectType((String) localType);
        }
        setFrameLocal(remap(oldVar, varType), localType);
      }
      oldVar += localType == Opcodes.LONG || localType == Opcodes.DOUBLE ? 2 : 1;
    }

    // Remove TOP after long and double types as well as trailing TOPs.
    oldVar = 0;
    int newVar = 0;
    int remappedNumLocal = 0;
    while (oldVar < remappedLocalTypes.length) {
      Object localType = remappedLocalTypes[oldVar];
      oldVar += localType == Opcodes.LONG || localType == Opcodes.DOUBLE ? 2 : 1;
      if (localType != null && localType != Opcodes.TOP) {
        remappedLocalTypes[newVar++] = localType;
        remappedNumLocal = newVar;
      } else {
        remappedLocalTypes[newVar++] = Opcodes.TOP;
      }
    }

    // Visit the remapped frame.
    super.visitFrame(type, remappedNumLocal, remappedLocalTypes, numStack, stack);

    // Restore the original value of 'remappedLocals'.
    remappedLocalTypes = oldRemappedLocals;
  }

  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new local variable of the given type.
   *
   * @param type the type of the local variable to be created.
   * @return the identifier of the newly created local variable.
   */
  public int newLocal(final Type type) {
    Object localType;
    switch (type.getSort()) {
      case Type.BOOLEAN:
      case Type.CHAR:
      case Type.BYTE:
      case Type.SHORT:
      case Type.INT:
        localType = Opcodes.INTEGER;
        break;
      case Type.FLOAT:
        localType = Opcodes.FLOAT;
        break;
      case Type.LONG:
        localType = Opcodes.LONG;
        break;
      case Type.DOUBLE:
        localType = Opcodes.DOUBLE;
        break;
      case Type.ARRAY:
        localType = type.getDescriptor();
        break;
      case Type.OBJECT:
        localType = type.getInternalName();
        break;
      default:
        throw new AssertionError();
    }
    int local = newLocalMapping(type);
    setLocalType(local, type);
    setFrameLocal(local, localType);
    return local;
  }

  /**
   * Notifies subclasses that a new stack map frame is being visited. The array argument contains
   * the stack map frame types corresponding to the local variables added with {@link #newLocal}.
   * This method can update these types in place for the stack map frame being visited. The default
   * implementation of this method does nothing, i.e. a local variable added with {@link #newLocal}
   * will have the same type in all stack map frames. But this behavior is not always the desired
   * one, for instance if a local variable is added in the middle of a try/catch block: the frame
   * for the exception handler should have a TOP type for this new local.
   *
   * @param newLocals the stack map frame types corresponding to the local variables added with
   *     {@link #newLocal} (and null for the others). The format of this array is the same as in
   *     {@link MethodVisitor#visitFrame}, except that long and double types use two slots. The
   *     types for the current stack map frame must be updated in place in this array.
   */
  protected void updateNewLocals(final Object[] newLocals) {
    // The default implementation does nothing.
  }

  /**
   * Notifies subclasses that a local variable has been added or remapped. The default
   * implementation of this method does nothing.
   *
   * @param local a local variable identifier, as returned by {@link #newLocal}.
   * @param type the type of the value being stored in the local variable.
   */
  protected void setLocalType(final int local, final Type type) {
    // The default implementation does nothing.
  }

  private void setFrameLocal(final int local, final Object type) {
    int numLocals = remappedLocalTypes.length;
    if (local >= numLocals) {
      Object[] newRemappedLocalTypes = new Object[Math.max(2 * numLocals, local + 1)];
      System.arraycopy(remappedLocalTypes, 0, newRemappedLocalTypes, 0, numLocals);
      remappedLocalTypes = newRemappedLocalTypes;
    }
    remappedLocalTypes[local] = type;
  }

  private int remap(final int varIndex, final Type type) {
    if (varIndex + type.getSize() <= firstLocal) {
      return varIndex;
    }
    int key = 2 * varIndex + type.getSize() - 1;
    int size = remappedVariableIndices.length;
    if (key >= size) {
      int[] newRemappedVariableIndices = new int[Math.max(2 * size, key + 1)];
      System.arraycopy(remappedVariableIndices, 0, newRemappedVariableIndices, 0, size);
      remappedVariableIndices = newRemappedVariableIndices;
    }
    int value = remappedVariableIndices[key];
    if (value == 0) {
      value = newLocalMapping(type);
      setLocalType(value, type);
      remappedVariableIndices[key] = value + 1;
    } else {
      value--;
    }
    return value;
  }

  protected int newLocalMapping(final Type type) {
    int local = nextLocal;
    nextLocal += type.getSize();
    return local;
  }
}

package org.objectweb.asm.commons;

import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A {@link MethodVisitor} that approximates the size of the methods it visits.
 *
 * @author Eugene Kuleshov
 */
public class CodeSizeEvaluator extends MethodVisitor implements Opcodes {

  /** The minimum size in bytes of the visited method. */
  private int minSize;

  /** The maximum size in bytes of the visited method. */
  private int maxSize;

  public CodeSizeEvaluator(final MethodVisitor methodVisitor) {
    this(/* latest api = */ Opcodes.ASM9, methodVisitor);
  }

  protected CodeSizeEvaluator(final int api, final MethodVisitor methodVisitor) {
    super(api, methodVisitor);
  }

  public int getMinSize() {
    return this.minSize;
  }

  public int getMaxSize() {
    return this.maxSize;
  }

  @Override
  public void visitInsn(final int opcode) {
    minSize += 1;
    maxSize += 1;
    super.visitInsn(opcode);
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    if (opcode == SIPUSH) {
      minSize += 3;
      maxSize += 3;
    } else {
      minSize += 2;
      maxSize += 2;
    }
    super.visitIntInsn(opcode, operand);
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    if (varIndex < 4 && opcode != RET) {
      minSize += 1;
      maxSize += 1;
    } else if (varIndex >= 256) {
      minSize += 4;
      maxSize += 4;
    } else {
      minSize += 2;
      maxSize += 2;
    }
    super.visitVarInsn(opcode, varIndex);
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    minSize += 3;
    maxSize += 3;
    super.visitTypeInsn(opcode, type);
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    minSize += 3;
    maxSize += 3;
    super.visitFieldInsn(opcode, owner, name, descriptor);
  }

  @Override
  public void visitMethodInsn(
      final int opcodeAndSource,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
      // Redirect the call to the deprecated version of this method.
      super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
      return;
    }
    int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;

    if (opcode == INVOKEINTERFACE) {
      minSize += 5;
      maxSize += 5;
    } else {
      minSize += 3;
      maxSize += 3;
    }
    super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    minSize += 5;
    maxSize += 5;
    super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    minSize += 3;
    if (opcode == GOTO || opcode == JSR) {
      maxSize += 5;
    } else {
      maxSize += 8;
    }
    super.visitJumpInsn(opcode, label);
  }

  @Override
  public void visitLdcInsn(final Object value) {
    if (value instanceof Long
        || value instanceof Double
        || (value instanceof ConstantDynamic && ((ConstantDynamic) value).getSize() == 2)) {
      minSize += 3;
      maxSize += 3;
    } else {
      minSize += 2;
      maxSize += 3;
    }
    super.visitLdcInsn(value);
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    if (varIndex > 255 || increment > 127 || increment < -128) {
      minSize += 6;
      maxSize += 6;
    } else {
      minSize += 3;
      maxSize += 3;
    }
    super.visitIincInsn(varIndex, increment);
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    minSize += 13 + labels.length * 4;
    maxSize += 16 + labels.length * 4;
    super.visitTableSwitchInsn(min, max, dflt, labels);
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    minSize += 9 + keys.length * 8;
    maxSize += 12 + keys.length * 8;
    super.visitLookupSwitchInsn(dflt, keys, labels);
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    minSize += 4;
    maxSize += 4;
    super.visitMultiANewArrayInsn(descriptor, numDimensions);
  }
}

package org.objectweb.asm.commons;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LocalVariableNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.TryCatchBlockNode;

/**
 * A {@link org.objectweb.asm.MethodVisitor} that removes JSR instructions and inlines the
 * referenced subroutines.
 *
 * @author Niko Matsakis
 */
// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
public class JSRInlinerAdapter extends MethodNode implements Opcodes {

  /**
   * The instructions that belong to the main "subroutine". Bit i is set iff instruction at index i
   * belongs to this main "subroutine".
   */
  private final BitSet mainSubroutineInsns = new BitSet();

  /**
   * The instructions that belong to each subroutine. For each label which is the target of a JSR
   * instruction, bit i of the corresponding BitSet in this map is set iff instruction at index i
   * belongs to this subroutine.
   */
  private final Map<LabelNode, BitSet> subroutinesInsns = new HashMap<>();

  /**
   * The instructions that belong to more that one subroutine. Bit i is set iff instruction at index
   * i belongs to more than one subroutine.
   */
  final BitSet sharedSubroutineInsns = new BitSet();

  /**
   * Constructs a new {@link JSRInlinerAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #JSRInlinerAdapter(int, MethodVisitor, int, String, String,
   * String, String[])} version.
   *
   * @param methodVisitor the method visitor to send the resulting inlined method code to, or <code>
   *     null</code>.
   * @param access the method's access flags.
   * @param name the method's name.
   * @param descriptor the method's descriptor.
   * @param signature the method's signature. May be {@literal null}.
   * @param exceptions the internal names of the method's exception classes (see {@link
   *     org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   * @throws IllegalStateException if a subclass calls this constructor.
   */
  public JSRInlinerAdapter(
      final MethodVisitor methodVisitor,
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String @Nullable [] exceptions) {
    this(
        /* latest api = */ Opcodes.ASM9,
        methodVisitor,
        access,
        name,
        descriptor,
        signature,
        exceptions);
    if (getClass() != JSRInlinerAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link JSRInlinerAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param methodVisitor the method visitor to send the resulting inlined method code to, or <code>
   *     null</code>.
   * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the method is synthetic and/or deprecated.
   * @param name the method's name.
   * @param descriptor the method's descriptor.
   * @param signature the method's signature. May be {@literal null}.
   * @param exceptions the internal names of the method's exception classes (see {@link
   *     org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  protected JSRInlinerAdapter(
      final int api,
      final MethodVisitor methodVisitor,
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String @Nullable [] exceptions) {
    super(api, access, name, descriptor, signature, exceptions);
    this.mv = methodVisitor;
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    super.visitJumpInsn(opcode, label);
    LabelNode labelNode = ((JumpInsnNode) instructions.getLast()).label;
    if (opcode == JSR && !subroutinesInsns.containsKey(labelNode)) {
      subroutinesInsns.put(labelNode, new BitSet());
    }
  }

  @Override
  public void visitEnd() {
    if (!subroutinesInsns.isEmpty()) {
      // If the code contains at least one JSR instruction, inline the subroutines.
      findSubroutinesInsns();
      emitCode();
    }
    if (mv != null) {
      accept(mv);
    }
  }

  /** Determines, for each instruction, to which subroutine(s) it belongs. */
  private void findSubroutinesInsns() {
    // Find the instructions that belong to main subroutine.
    BitSet visitedInsns = new BitSet();
    findSubroutineInsns(0, mainSubroutineInsns, visitedInsns);
    // For each subroutine, find the instructions that belong to this subroutine.
    for (Map.Entry<LabelNode, BitSet> entry : subroutinesInsns.entrySet()) {
      LabelNode jsrLabelNode = entry.getKey();
      BitSet subroutineInsns = entry.getValue();
      findSubroutineInsns(instructions.indexOf(jsrLabelNode), subroutineInsns, visitedInsns);
    }
  }

  /**
   * Finds the instructions that belong to the subroutine starting at the given instruction index.
   * For this the control flow graph is visited with a depth first search (this includes the normal
   * control flow and the exception handlers).
   *
   * @param startInsnIndex the index of the first instruction of the subroutine.
   * @param subroutineInsns where the indices of the instructions of the subroutine must be stored.
   * @param visitedInsns the indices of the instructions that have been visited so far (including in
   *     previous calls to this method). This bitset is updated by this method each time a new
   *     instruction is visited. It is used to make sure each instruction is visited at most once.
   */
  private void findSubroutineInsns(
      final int startInsnIndex, final BitSet subroutineInsns, final BitSet visitedInsns) {
    // First find the instructions reachable via normal execution.
    findReachableInsns(startInsnIndex, subroutineInsns, visitedInsns);

    // Then find the instructions reachable via the applicable exception handlers.
    while (true) {
      boolean applicableHandlerFound = false;
      for (TryCatchBlockNode tryCatchBlockNode : tryCatchBlocks) {
        // If the handler has already been processed, skip it.
        int handlerIndex = instructions.indexOf(tryCatchBlockNode.handler);
        if (subroutineInsns.get(handlerIndex)) {
          continue;
        }

        // If an instruction in the exception handler range belongs to the subroutine, the handler
        // can be reached from the routine, and its instructions must be added to the subroutine.
        int startIndex = instructions.indexOf(tryCatchBlockNode.start);
        int endIndex = instructions.indexOf(tryCatchBlockNode.end);
        int firstSubroutineInsnAfterTryCatchStart = subroutineInsns.nextSetBit(startIndex);
        if (firstSubroutineInsnAfterTryCatchStart >= startIndex
            && firstSubroutineInsnAfterTryCatchStart < endIndex) {
          findReachableInsns(handlerIndex, subroutineInsns, visitedInsns);
          applicableHandlerFound = true;
        }
      }
      // If an applicable exception handler has been found, other handlers may become applicable, so
      // we must examine them again.
      if (!applicableHandlerFound) {
        return;
      }
    }
  }

  /**
   * Finds the instructions that are reachable from the given instruction, without following any JSR
   * instruction nor any exception handler. For this the control flow graph is visited with a depth
   * first search.
   *
   * @param insnIndex the index of an instruction of the subroutine.
   * @param subroutineInsns where the indices of the instructions of the subroutine must be stored.
   * @param visitedInsns the indices of the instructions that have been visited so far (including in
   *     previous calls to this method). This bitset is updated by this method each time a new
   *     instruction is visited. It is used to make sure each instruction is visited at most once.
   */
  private void findReachableInsns(
      final int insnIndex, final BitSet subroutineInsns, final BitSet visitedInsns) {
    int currentInsnIndex = insnIndex;
    // We implicitly assume below that execution can always fall through to the next instruction
    // after a JSR. But a subroutine may never return, in which case the code after the JSR is
    // unreachable and can be anything. In particular, it can seem to fall off the end of the
    // method, so we must handle this case here (we could instead detect whether execution can
    // return or not from a JSR, but this is more complicated).
    while (currentInsnIndex < instructions.size()) {
      // Visit each instruction at most once.
      if (subroutineInsns.get(currentInsnIndex)) {
        return;
      }
      subroutineInsns.set(currentInsnIndex);

      // Check if this instruction has already been visited by another subroutine.
      if (visitedInsns.get(currentInsnIndex)) {
        sharedSubroutineInsns.set(currentInsnIndex);
      }
      visitedInsns.set(currentInsnIndex);

      AbstractInsnNode currentInsnNode = instructions.get(currentInsnIndex);
      if (currentInsnNode.getType() == AbstractInsnNode.JUMP_INSN
          && currentInsnNode.getOpcode() != JSR) {
        // Don't follow JSR instructions in the control flow graph.
        JumpInsnNode jumpInsnNode = (JumpInsnNode) currentInsnNode;
        findReachableInsns(instructions.indexOf(jumpInsnNode.label), subroutineInsns, visitedInsns);
      } else if (currentInsnNode.getType() == AbstractInsnNode.TABLESWITCH_INSN) {
        TableSwitchInsnNode tableSwitchInsnNode = (TableSwitchInsnNode) currentInsnNode;
        findReachableInsns(
            instructions.indexOf(tableSwitchInsnNode.dflt), subroutineInsns, visitedInsns);
        for (LabelNode labelNode : tableSwitchInsnNode.labels) {
          findReachableInsns(instructions.indexOf(labelNode), subroutineInsns, visitedInsns);
        }
      } else if (currentInsnNode.getType() == AbstractInsnNode.LOOKUPSWITCH_INSN) {
        LookupSwitchInsnNode lookupSwitchInsnNode = (LookupSwitchInsnNode) currentInsnNode;
        findReachableInsns(
            instructions.indexOf(lookupSwitchInsnNode.dflt), subroutineInsns, visitedInsns);
        for (LabelNode labelNode : lookupSwitchInsnNode.labels) {
          findReachableInsns(instructions.indexOf(labelNode), subroutineInsns, visitedInsns);
        }
      }

      // Check if this instruction falls through to the next instruction; if not, return.
      switch (instructions.get(currentInsnIndex).getOpcode()) {
        case GOTO:
        case RET:
        case TABLESWITCH:
        case LOOKUPSWITCH:
        case IRETURN:
        case LRETURN:
        case FRETURN:
        case DRETURN:
        case ARETURN:
        case RETURN:
        case ATHROW:
          // Note: this either returns from this subroutine, or from a parent subroutine.
          return;
        default:
          // Go to the next instruction.
          currentInsnIndex++;
          break;
      }
    }
  }

  /**
   * Creates the new instructions, inlining each instantiation of each subroutine until the code is
   * fully elaborated.
   */
  private void emitCode() {
    LinkedList<Instantiation> worklist = new LinkedList<>();
    // Create an instantiation of the main "subroutine", which is just the main routine.
    worklist.add(new Instantiation(null, mainSubroutineInsns));

    // Emit instantiations of each subroutine we encounter, including the main subroutine.
    InsnList newInstructions = new InsnList();
    List<TryCatchBlockNode> newTryCatchBlocks = new ArrayList<>();
    List<LocalVariableNode> newLocalVariables = new ArrayList<>();
    while (!worklist.isEmpty()) {
      Instantiation instantiation = worklist.removeFirst();
      emitInstantiation(
          instantiation, worklist, newInstructions, newTryCatchBlocks, newLocalVariables);
    }
    instructions = newInstructions;
    tryCatchBlocks = newTryCatchBlocks;
    localVariables = newLocalVariables;
  }

  /**
   * Emits an instantiation of a subroutine, specified by <code>instantiation</code>. May add new
   * instantiations that are invoked by this one to the <code>worklist</code>, and new try/catch
   * blocks to <code>newTryCatchBlocks</code>.
   *
   * @param instantiation the instantiation that must be performed.
   * @param worklist list of the instantiations that remain to be done.
   * @param newInstructions the instruction list to which the instantiated code must be appended.
   * @param newTryCatchBlocks the exception handler list to which the instantiated handlers must be
   *     appended.
   * @param newLocalVariables the local variables list to which the instantiated local variables
   *     must be appended.
   */
  private void emitInstantiation(
      final Instantiation instantiation,
      final List<Instantiation> worklist,
      final InsnList newInstructions,
      final List<TryCatchBlockNode> newTryCatchBlocks,
      final List<LocalVariableNode> newLocalVariables) {
    LabelNode previousLabelNode = null;
    for (int i = 0; i < instructions.size(); ++i) {
      AbstractInsnNode insnNode = instructions.get(i);
      if (insnNode.getType() == AbstractInsnNode.LABEL) {
        // Always clone all labels, while avoiding to add the same label more than once.
        LabelNode labelNode = (LabelNode) insnNode;
        LabelNode clonedLabelNode = instantiation.getClonedLabel(labelNode);
        if (clonedLabelNode != previousLabelNode) {
          newInstructions.add(clonedLabelNode);
          previousLabelNode = clonedLabelNode;
        }
      } else if (instantiation.findOwner(i) == instantiation) {
        // Don't emit instructions that were already emitted by an ancestor subroutine. Note that it
        // is still possible for a given instruction to be emitted twice because it may belong to
        // two subroutines that do not invoke each other.

        if (insnNode.getOpcode() == RET) {
          // Translate RET instruction(s) to a jump to the return label for the appropriate
          // instantiation. The problem is that the subroutine may "fall through" to the ret of a
          // parent subroutine; therefore, to find the appropriate ret label we find the oldest
          // instantiation that claims to own this instruction.
          LabelNode retLabel = null;
          for (Instantiation retLabelOwner = instantiation;
              retLabelOwner != null;
              retLabelOwner = retLabelOwner.parent) {
            if (retLabelOwner.subroutineInsns.get(i)) {
              retLabel = retLabelOwner.returnLabel;
            }
          }
          if (retLabel == null) {
            // This is only possible if the mainSubroutine owns a RET instruction, which should
            // never happen for verifiable code.
            throw new IllegalArgumentException(
                "Instruction #" + i + " is a RET not owned by any subroutine");
          }
          newInstructions.add(new JumpInsnNode(GOTO, retLabel));
        } else if (insnNode.getOpcode() == JSR) {
          LabelNode jsrLabelNode = ((JumpInsnNode) insnNode).label;
          BitSet subroutineInsns = subroutinesInsns.get(jsrLabelNode);
          Instantiation newInstantiation = new Instantiation(instantiation, subroutineInsns);
          LabelNode clonedJsrLabelNode = newInstantiation.getClonedLabelForJumpInsn(jsrLabelNode);
          // Replace the JSR instruction with a GOTO to the instantiated subroutine, and push NULL
          // for what was once the return address value. This hack allows us to avoid doing any sort
          // of data flow analysis to figure out which instructions manipulate the old return
          // address value pointer which is now known to be unneeded.
          newInstructions.add(new InsnNode(ACONST_NULL));
          newInstructions.add(new JumpInsnNode(GOTO, clonedJsrLabelNode));
          newInstructions.add(newInstantiation.returnLabel);
          // Insert this new instantiation into the queue to be emitted later.
          worklist.add(newInstantiation);
        } else {
          newInstructions.add(insnNode.clone(instantiation));
        }
      }
    }

    // Emit the try/catch blocks that are relevant for this instantiation.
    for (TryCatchBlockNode tryCatchBlockNode : tryCatchBlocks) {
      final LabelNode start = instantiation.getClonedLabel(tryCatchBlockNode.start);
      final LabelNode end = instantiation.getClonedLabel(tryCatchBlockNode.end);
      if (start != end) {
        final LabelNode handler =
            instantiation.getClonedLabelForJumpInsn(tryCatchBlockNode.handler);
        if (start == null || end == null || handler == null) {
          throw new AssertionError("Internal error!");
        }
        newTryCatchBlocks.add(new TryCatchBlockNode(start, end, handler, tryCatchBlockNode.type));
      }
    }

    // Emit the local variable nodes that are relevant for this instantiation.
    for (LocalVariableNode localVariableNode : localVariables) {
      final LabelNode start = instantiation.getClonedLabel(localVariableNode.start);
      final LabelNode end = instantiation.getClonedLabel(localVariableNode.end);
      if (start != end) {
        newLocalVariables.add(
            new LocalVariableNode(
                localVariableNode.name,
                localVariableNode.desc,
                localVariableNode.signature,
                start,
                end,
                localVariableNode.index));
      }
    }
  }

  /** An instantiation of a subroutine. */
  private final class Instantiation extends AbstractMap<LabelNode, LabelNode> {

    /**
     * The instantiation from which this one was created (or {@literal null} for the instantiation
     * of the main "subroutine").
     */
    final Instantiation parent;

    /**
     * The original instructions that belong to the subroutine which is instantiated. Bit i is set
     * iff instruction at index i belongs to this subroutine.
     */
    final BitSet subroutineInsns;

    /**
     * A map from labels from the original code to labels pointing at code specific to this
     * instantiation, for use in remapping try/catch blocks, as well as jumps.
     *
     * <p>Note that in the presence of instructions belonging to several subroutines, we map the
     * target label of a GOTO to the label used by the oldest instantiation (parent instantiations
     * are older than their children). This avoids code duplication during inlining in most cases.
     */
    final Map<LabelNode, LabelNode> clonedLabels;

    /** The return label for this instantiation, to which all original returns will be mapped. */
    final LabelNode returnLabel;

    Instantiation(final Instantiation parent, final BitSet subroutineInsns) {
      for (Instantiation instantiation = parent;
          instantiation != null;
          instantiation = instantiation.parent) {
        if (instantiation.subroutineInsns == subroutineInsns) {
          throw new IllegalArgumentException("Recursive invocation of " + subroutineInsns);
        }
      }

      this.parent = parent;
      this.subroutineInsns = subroutineInsns;
      this.returnLabel = parent == null ? null : new LabelNode();
      this.clonedLabels = new HashMap<>();

      // Create a clone of each label in the original code of the subroutine. Note that we collapse
      // labels which point at the same instruction into one.
      LabelNode clonedLabelNode = null;
      for (int insnIndex = 0; insnIndex < instructions.size(); insnIndex++) {
        AbstractInsnNode insnNode = instructions.get(insnIndex);
        if (insnNode.getType() == AbstractInsnNode.LABEL) {
          LabelNode labelNode = (LabelNode) insnNode;
          // If we already have a label pointing at this spot, don't recreate it.
          if (clonedLabelNode == null) {
            clonedLabelNode = new LabelNode();
          }
          clonedLabels.put(labelNode, clonedLabelNode);
        } else if (findOwner(insnIndex) == this) {
          // We will emit this instruction, so clear the duplicateLabelNode flag since the next
          // Label will refer to a distinct instruction.
          clonedLabelNode = null;
        }
      }
    }

    /**
     * Returns the "owner" of a particular instruction relative to this instantiation: the owner
     * refers to the Instantiation which will emit the version of this instruction that we will
     * execute.
     *
     * <p>Typically, the return value is either <code>this</code> or <code>null</code>. <code>this
     * </code> indicates that this instantiation will generate the version of this instruction that
     * we will execute, and <code>null</code> indicates that this instantiation never executes the
     * given instruction.
     *
     * <p>Sometimes, however, an instruction can belong to multiple subroutines; this is called a
     * shared instruction, and occurs when multiple subroutines branch to common points of control.
     * In this case, the owner is the oldest instantiation which owns the instruction in question
     * (parent instantiations are older than their children).
     *
     * @param insnIndex the index of an instruction in the original code.
     * @return the "owner" of a particular instruction relative to this instantiation.
     */
    Instantiation findOwner(final int insnIndex) {
      if (!subroutineInsns.get(insnIndex)) {
        return null;
      }
      if (!sharedSubroutineInsns.get(insnIndex)) {
        return this;
      }
      Instantiation owner = this;
      for (Instantiation instantiation = parent;
          instantiation != null;
          instantiation = instantiation.parent) {
        if (instantiation.subroutineInsns.get(insnIndex)) {
          owner = instantiation;
        }
      }
      return owner;
    }

    /**
     * Returns the clone of the given original label that is appropriate for use in a jump
     * instruction.
     *
     * @param labelNode a label of the original code.
     * @return a clone of the given label for use in a jump instruction in the inlined code.
     */
    LabelNode getClonedLabelForJumpInsn(final LabelNode labelNode) {
      // findOwner should never return null, because owner is null only if an instruction cannot be
      // reached from this subroutine.
      return findOwner(instructions.indexOf(labelNode)).clonedLabels.get(labelNode);
    }

    /**
     * Returns the clone of the given original label that is appropriate for use by a try/catch
     * block or a variable annotation.
     *
     * @param labelNode a label of the original code.
     * @return a clone of the given label for use by a try/catch block or a variable annotation in
     *     the inlined code.
     */
    LabelNode getClonedLabel(final LabelNode labelNode) {
      return clonedLabels.get(labelNode);
    }

    // AbstractMap implementation

    @Override
    public Set<Map.Entry<LabelNode, LabelNode>> entrySet() {
      throw new UnsupportedOperationException();
    }

    @Override
    public LabelNode get(final Object key) {
      return getClonedLabelForJumpInsn((LabelNode) key);
    }

    @Override
    public boolean equals(final Object other) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int hashCode() {
      throw new UnsupportedOperationException();
    }
  }
}


package org.objectweb.asm.commons;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.TypePath;

/**
 * A {@link RecordComponentVisitor} that remaps types with a {@link Remapper}.
 *
 * @author Remi Forax
 */
public class RecordComponentRemapper extends RecordComponentVisitor {

  /** The remapper used to remap the types in the visited field. */
  protected final Remapper remapper;

  /**
   * Constructs a new {@link RecordComponentRemapper}. <i>Subclasses must not use this
   * constructor</i>. Instead, they must use the {@link
   * #RecordComponentRemapper(int,RecordComponentVisitor,Remapper)} version.
   *
   * @param recordComponentVisitor the record component visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited record component.
   */
  public RecordComponentRemapper(
      final RecordComponentVisitor recordComponentVisitor, final Remapper remapper) {
    this(/* latest api = */ Opcodes.ASM9, recordComponentVisitor, remapper);
  }

  /**
   * Constructs a new {@link RecordComponentRemapper}.
   *
   * @param api the ASM API version supported by this remapper. Must be one of {@link
   *     org.objectweb.asm.Opcodes#ASM8} or {@link org.objectweb.asm.Opcodes#ASM9}.
   * @param recordComponentVisitor the record component visitor this remapper must delegate to.
   * @param remapper the remapper to use to remap the types in the visited record component.
   */
  protected RecordComponentRemapper(
      final int api, final RecordComponentVisitor recordComponentVisitor, final Remapper remapper) {
    super(api, recordComponentVisitor);
    this.remapper = remapper;
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitAnnotation(remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? null
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    AnnotationVisitor annotationVisitor =
        super.visitTypeAnnotation(typeRef, typePath, remapper.mapDesc(descriptor), visible);
    return annotationVisitor == null
        ? null
        : createAnnotationRemapper(descriptor, annotationVisitor);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   * @deprecated use {@link #createAnnotationRemapper(String, AnnotationVisitor)} instead.
   */
  @Deprecated
  protected AnnotationVisitor createAnnotationRemapper(final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, /* descriptor= */ null, annotationVisitor, remapper);
  }

  /**
   * Constructs a new remapper for annotations. The default implementation of this method returns a
   * new {@link AnnotationRemapper}.
   *
   * @param descriptor the descriptor sof the visited annotation.
   * @param annotationVisitor the AnnotationVisitor the remapper must delegate to.
   * @return the newly created remapper.
   */
  protected AnnotationVisitor createAnnotationRemapper(
      final String descriptor, final AnnotationVisitor annotationVisitor) {
    return new AnnotationRemapper(api, descriptor, annotationVisitor, remapper)
        .orDeprecatedValue(createAnnotationRemapper(annotationVisitor));
  }
}

package org.objectweb.asm.tree;

import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a local variable declaration.
 *
 * @author Eric Bruneton
 */
public class LocalVariableNode {

  /** The name of a local variable. */
  public String name;

  /** The type descriptor of this local variable. */
  public String desc;

  /** The signature of this local variable. May be {@literal null}. */
  public String signature;

  /** The first instruction corresponding to the scope of this local variable (inclusive). */
  public LabelNode start;

  /** The last instruction corresponding to the scope of this local variable (exclusive). */
  public LabelNode end;

  /** The local variable's index. */
  public int index;

  /**
   * Constructs a new {@link LocalVariableNode}.
   *
   * @param name the name of a local variable.
   * @param descriptor the type descriptor of this local variable.
   * @param signature the signature of this local variable. May be {@literal null}.
   * @param start the first instruction corresponding to the scope of this local variable
   *     (inclusive).
   * @param end the last instruction corresponding to the scope of this local variable (exclusive).
   * @param index the local variable's index.
   */
  public LocalVariableNode(
      final String name,
      final String descriptor,
      final String signature,
      final LabelNode start,
      final LabelNode end,
      final int index) {
    this.name = name;
    this.desc = descriptor;
    this.signature = signature;
    this.start = start;
    this.end = end;
    this.index = index;
  }

  /**
   * Makes the given visitor visit this local variable declaration.
   *
   * @param methodVisitor a method visitor.
   */
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitLocalVariable(
        name, desc, signature, start.getLabel(), end.getLabel(), index);
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a zero operand instruction.
 *
 * @author Eric Bruneton
 */
public class InsnNode extends AbstractInsnNode {

  /**
   * Constructs a new {@link InsnNode}.
   *
   * @param opcode the opcode of the instruction to be constructed. This opcode must be NOP,
   *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,
   *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,
   *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,
   *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,
   *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,
   *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,
   *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,
   *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,
   *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.
   */
  public InsnNode(final int opcode) {
    super(opcode);
  }

  @Override
  public int getType() {
    return INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitInsn(opcode);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new InsnNode(opcode).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a field instruction. A field instruction is an instruction that loads or
 * stores the value of a field of an object.
 *
 * @author Eric Bruneton
 */
public class FieldInsnNode extends AbstractInsnNode {

  /**
   * The internal name of the field's owner class (see {@link
   * org.objectweb.asm.Type#getInternalName()}).
   */
  public @InternalForm String owner;

  /** The field's name. */
  public String name;

  /** The field's descriptor (see {@link org.objectweb.asm.Type}). */
  public String desc;

  /**
   * Constructs a new {@link FieldInsnNode}.
   *
   * @param opcode the opcode of the type instruction to be constructed. This opcode must be
   *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
   * @param owner the internal name of the field's owner class (see {@link
   *     org.objectweb.asm.Type#getInternalName()}).
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link org.objectweb.asm.Type}).
   */
  public FieldInsnNode(
      final int opcode, final @InternalForm String owner, final String name, final String descriptor) {
    super(opcode);
    this.owner = owner;
    this.name = name;
    this.desc = descriptor;
  }

  /**
   * Sets the opcode of this instruction.
   *
   * @param opcode the new instruction opcode. This opcode must be GETSTATIC, PUTSTATIC, GETFIELD or
   *     PUTFIELD.
   */
  public void setOpcode(final int opcode) {
    this.opcode = opcode;
  }

  @Override
  public int getType() {
    return FIELD_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitFieldInsn(opcode, owner, name, desc);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new FieldInsnNode(opcode, owner, name, desc).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import org.objectweb.asm.ModuleVisitor;

/**
 * A node that represents a required module with its name and access of a module descriptor.
 *
 * @author Remi Forax
 */
public class ModuleRequireNode {

  /** The fully qualified name (using dots) of the dependence. */
  public String module;

  /**
   * The access flag of the dependence among {@code ACC_TRANSITIVE}, {@code ACC_STATIC_PHASE},
   * {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   */
  public int access;

  /** The module version at compile time, or {@literal null}. */
  public String version;

  /**
   * Constructs a new {@link ModuleRequireNode}.
   *
   * @param module the fully qualified name (using dots) of the dependence.
   * @param access the access flag of the dependence among {@code ACC_TRANSITIVE}, {@code
   *     ACC_STATIC_PHASE}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   * @param version the module version at compile time, or {@literal null}.
   */
  public ModuleRequireNode(final String module, final int access, final String version) {
    this.module = module;
    this.access = access;
    this.version = version;
  }

  /**
   * Makes the given module visitor visit this require directive.
   *
   * @param moduleVisitor a module visitor.
   */
  public void accept(final ModuleVisitor moduleVisitor) {
    moduleVisitor.visitRequire(module, access, version);
  }
}

package org.objectweb.asm.tree;

import java.util.List;
import org.objectweb.asm.ModuleVisitor;

/**
 * A node that represents a service and its implementation provided by the current module.
 *
 * @author Remi Forax
 */
public class ModuleProvideNode {

  /** The internal name of the service (see {@link org.objectweb.asm.Type#getInternalName()}). */
  public @InternalForm String service;

  /**
   * The internal names of the implementations of the service (there is at least one provider). See
   * {@link org.objectweb.asm.Type#getInternalName()}.
   */
  public List<@InternalForm String> providers;

  /**
   * Constructs a new {@link ModuleProvideNode}.
   *
   * @param service the internal name of the service.
   * @param providers the internal names of the implementations of the service (there is at least
   *     one provider). See {@link org.objectweb.asm.Type#getInternalName()}.
   */
  public ModuleProvideNode(final @InternalForm String service, final List<@InternalForm String> providers) {
    this.service = service;
    this.providers = providers;
  }

  /**
   * Makes the given module visitor visit this require declaration.
   *
   * @param moduleVisitor a module visitor.
   */
  public void accept(final ModuleVisitor moduleVisitor) {
    moduleVisitor.visitProvide(service, providers.toArray(new String[0]));
  }
}

package org.objectweb.asm.tree;

/**
 * Exception thrown in {@link AnnotationNode#check}, {@link ClassNode#check}, {@link
 * FieldNode#check} and {@link MethodNode#check} when these nodes (or their children, recursively)
 * contain elements that were introduced in more recent versions of the ASM API than version passed
 * to these methods.
 *
 * @author Eric Bruneton
 */
public class UnsupportedClassVersionException extends RuntimeException {

  private static final long serialVersionUID = -3502347765891805831L;
}

package org.objectweb.asm.tree;

import java.util.List;
import org.objectweb.asm.ModuleVisitor;

/**
 * A node that represents an exported package with its name and the module that can access to it.
 *
 * @author Remi Forax
 */
public class ModuleExportNode {

  /**
   * The internal name of the exported package (see {@link
   * org.objectweb.asm.Type#getInternalName()}).
   */
  public String packaze;

  /**
   * The access flags (see {@link org.objectweb.asm.Opcodes}). Valid values are {@code
   * ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   */
  public int access;

  /**
   * The list of modules that can access this exported package, specified with fully qualified names
   * (using dots). May be {@literal null}.
   */
  public List<String> modules;

  /**
   * Constructs a new {@link ModuleExportNode}.
   *
   * @param packaze the internal name of the exported package (see {@link
   *     org.objectweb.asm.Type#getInternalName()}).
   * @param access the package access flags, one or more of {@code ACC_SYNTHETIC} and {@code
   *     ACC_MANDATED}.
   * @param modules a list of modules that can access this exported package, specified with fully
   *     qualified names (using dots).
   */
  public ModuleExportNode(final String packaze, final int access, final List<String> modules) {
    this.packaze = packaze;
    this.access = access;
    this.modules = modules;
  }

  /**
   * Makes the given module visitor visit this export declaration.
   *
   * @param moduleVisitor a module visitor.
   */
  public void accept(final ModuleVisitor moduleVisitor) {
    moduleVisitor.visitExport(
        packaze, access, modules == null ? null : modules.toArray(new String[0]));
  }
}

package org.objectweb.asm.tree;

import java.util.List;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.TypePath;

/**
 * A node that represents a record component.
 *
 * @author Remi Forax
 */
public class RecordComponentNode extends RecordComponentVisitor {

  /** The record component name. */
  public String name;

  /** The record component descriptor (see {@link org.objectweb.asm.Type}). */
  public String descriptor;

  /** The record component signature. May be {@literal null}. */
  public String signature;

  /** The runtime visible annotations of this record component. May be {@literal null}. */
  public List<AnnotationNode> visibleAnnotations;

  /** The runtime invisible annotations of this record component. May be {@literal null}. */
  public List<AnnotationNode> invisibleAnnotations;

  /** The runtime visible type annotations of this record component. May be {@literal null}. */
  public List<TypeAnnotationNode> visibleTypeAnnotations;

  /** The runtime invisible type annotations of this record component. May be {@literal null}. */
  public List<TypeAnnotationNode> invisibleTypeAnnotations;

  /** The non standard attributes of this record component. * May be {@literal null}. */
  public List<Attribute> attrs;

  /**
   * Constructs a new {@link RecordComponentNode}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #RecordComponentNode(int, String, String, String)} version.
   *
   * @param name the record component name.
   * @param descriptor the record component descriptor (see {@link org.objectweb.asm.Type}).
   * @param signature the record component signature.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public RecordComponentNode(final String name, final String descriptor, final String signature) {
    this(/* latest api = */ Opcodes.ASM9, name, descriptor, signature);
    if (getClass() != RecordComponentNode.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link RecordComponentNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM8}
   *     or {@link Opcodes#ASM9}.
   * @param name the record component name.
   * @param descriptor the record component descriptor (see {@link org.objectweb.asm.Type}).
   * @param signature the record component signature.
   */
  public RecordComponentNode(
      final int api, final String name, final String descriptor, final String signature) {
    super(api);
    this.name = name;
    this.descriptor = descriptor;
    this.signature = signature;
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the FieldVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    AnnotationNode annotation = new AnnotationNode(descriptor);
    if (visible) {
      visibleAnnotations = Util.add(visibleAnnotations, annotation);
    } else {
      invisibleAnnotations = Util.add(invisibleAnnotations, annotation);
    }
    return annotation;
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    TypeAnnotationNode typeAnnotation = new TypeAnnotationNode(typeRef, typePath, descriptor);
    if (visible) {
      visibleTypeAnnotations = Util.add(visibleTypeAnnotations, typeAnnotation);
    } else {
      invisibleTypeAnnotations = Util.add(invisibleTypeAnnotations, typeAnnotation);
    }
    return typeAnnotation;
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    attrs = Util.add(attrs, attribute);
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Accept methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Checks that this record component node is compatible with the given ASM API version. This
   * method checks that this node, and all its children recursively, do not contain elements that
   * were introduced in more recent versions of the ASM API than the given version.
   *
   * @param api an ASM API version. Must be one of {@link Opcodes#ASM8} or {@link Opcodes#ASM9}.
   */
  public void check(final int api) {
    if (api < Opcodes.ASM8) {
      throw new UnsupportedClassVersionException();
    }
  }

  /**
   * Makes the given class visitor visit this record component.
   *
   * @param classVisitor a class visitor.
   */
  public void accept(final ClassVisitor classVisitor) {
    RecordComponentVisitor recordComponentVisitor =
        classVisitor.visitRecordComponent(name, descriptor, signature);
    if (recordComponentVisitor == null) {
      return;
    }
    // Visit the annotations.
    if (visibleAnnotations != null) {
      for (int i = 0, n = visibleAnnotations.size(); i < n; ++i) {
        AnnotationNode annotation = visibleAnnotations.get(i);
        annotation.accept(recordComponentVisitor.visitAnnotation(annotation.desc, true));
      }
    }
    if (invisibleAnnotations != null) {
      for (int i = 0, n = invisibleAnnotations.size(); i < n; ++i) {
        AnnotationNode annotation = invisibleAnnotations.get(i);
        annotation.accept(recordComponentVisitor.visitAnnotation(annotation.desc, false));
      }
    }
    if (visibleTypeAnnotations != null) {
      for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = visibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            recordComponentVisitor.visitTypeAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, true));
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            recordComponentVisitor.visitTypeAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
      }
    }
    // Visit the non standard attributes.
    if (attrs != null) {
      for (int i = 0, n = attrs.size(); i < n; ++i) {
        recordComponentVisitor.visitAttribute(attrs.get(i));
      }
    }
    recordComponentVisitor.visitEnd();
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a local variable instruction. A local variable instruction is an
 * instruction that loads or stores the value of a local variable.
 *
 * @author Eric Bruneton
 */
public class VarInsnNode extends AbstractInsnNode {

  /** The operand of this instruction. This operand is the index of a local variable. */
  public int var;

  /**
   * Constructs a new {@link VarInsnNode}.
   *
   * @param opcode the opcode of the local variable instruction to be constructed. This opcode must
   *     be ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
   * @param varIndex the operand of the instruction to be constructed. This operand is the index of
   *     a local variable.
   */
  public VarInsnNode(final int opcode, final int varIndex) {
    super(opcode);
    this.var = varIndex;
  }

  /**
   * Sets the opcode of this instruction.
   *
   * @param opcode the new instruction opcode. This opcode must be ILOAD, LLOAD, FLOAD, DLOAD,
   *     ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
   */
  public void setOpcode(final int opcode) {
    this.opcode = opcode;
  }

  @Override
  public int getType() {
    return VAR_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitVarInsn(opcode, var);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new VarInsnNode(opcode, var).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents an instruction with a single int operand.
 *
 * @author Eric Bruneton
 */
public class IntInsnNode extends AbstractInsnNode {

  /** The operand of this instruction. */
  public int operand;

  /**
   * Constructs a new {@link IntInsnNode}.
   *
   * @param opcode the opcode of the instruction to be constructed. This opcode must be BIPUSH,
   *     SIPUSH or NEWARRAY.
   * @param operand the operand of the instruction to be constructed.
   */
  public IntInsnNode(final int opcode, final int operand) {
    super(opcode);
    this.operand = operand;
  }

  /**
   * Sets the opcode of this instruction.
   *
   * @param opcode the new instruction opcode. This opcode must be BIPUSH, SIPUSH or NEWARRAY.
   */
  public void setOpcode(final int opcode) {
    this.opcode = opcode;
  }

  @Override
  public int getType() {
    return INT_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitIntInsn(opcode, operand);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new IntInsnNode(opcode, operand).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;

/** An {@link AbstractInsnNode} that encapsulates a {@link Label}. */
public class LabelNode extends AbstractInsnNode {

  private Label value;

  public LabelNode() {
    super(-1);
  }

  public LabelNode(final Label label) {
    super(-1);
    this.value = label;
  }

  @Override
  public int getType() {
    return LABEL;
  }

  /**
   * Returns the label encapsulated by this node. A new label is created and associated with this
   * node if it was created without an encapsulated label.
   *
   * @return the label encapsulated by this node.
   */
  public Label getLabel() {
    if (value == null) {
      value = new Label();
    }
    return value;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitLabel(getLabel());
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return clonedLabels.get(this);
  }

  public void resetLabel() {
    value = null;
  }
}

package org.objectweb.asm.tree;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents an annotation.
 *
 * @author Eric Bruneton
 */
public class AnnotationNode extends AnnotationVisitor {

  /** The class descriptor of the annotation class. */
  public String desc;

  /**
   * The name value pairs of this annotation. Each name value pair is stored as two consecutive
   * elements in the list. The name is a {@link String}, and the value may be a {@link Byte}, {@link
   * Boolean}, {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Float},
   * {@link Double}, {@link String} or {@link org.objectweb.asm.Type}, or a two elements String
   * array (for enumeration values), an {@link AnnotationNode}, or a {@link List} of values of one
   * of the preceding types. The list may be {@literal null} if there is no name value pair.
   */
  public List<Object> values;

  /**
   * Constructs a new {@link AnnotationNode}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #AnnotationNode(int, String)} version.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public AnnotationNode(final String descriptor) {
    this(/* latest api = */ Opcodes.ASM9, descriptor);
    if (getClass() != AnnotationNode.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link AnnotationNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param descriptor the class descriptor of the annotation class.
   */
  public AnnotationNode(final int api, final String descriptor) {
    super(api);
    this.desc = descriptor;
  }

  /**
   * Constructs a new {@link AnnotationNode} to visit an array value.
   *
   * @param values where the visited values must be stored.
   */
  AnnotationNode(final List<Object> values) {
    super(/* latest api = */ Opcodes.ASM9);
    this.values = values;
  }

  // ------------------------------------------------------------------------
  // Implementation of the AnnotationVisitor abstract class
  // ------------------------------------------------------------------------

  @Override
  public void visit(final String name, final Object value) {
    if (values == null) {
      values = new ArrayList<>(this.desc != null ? 2 : 1);
    }
    if (this.desc != null) {
      values.add(name);
    }
    if (value instanceof byte[]) {
      values.add(Util.asArrayList((byte[]) value));
    } else if (value instanceof boolean[]) {
      values.add(Util.asArrayList((boolean[]) value));
    } else if (value instanceof short[]) {
      values.add(Util.asArrayList((short[]) value));
    } else if (value instanceof char[]) {
      values.add(Util.asArrayList((char[]) value));
    } else if (value instanceof int[]) {
      values.add(Util.asArrayList((int[]) value));
    } else if (value instanceof long[]) {
      values.add(Util.asArrayList((long[]) value));
    } else if (value instanceof float[]) {
      values.add(Util.asArrayList((float[]) value));
    } else if (value instanceof double[]) {
      values.add(Util.asArrayList((double[]) value));
    } else {
      values.add(value);
    }
  }

  @Override
  public void visitEnum(final String name, final String descriptor, final String value) {
    if (values == null) {
      values = new ArrayList<>(this.desc != null ? 2 : 1);
    }
    if (this.desc != null) {
      values.add(name);
    }
    values.add(new String[] {descriptor, value});
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
    if (values == null) {
      values = new ArrayList<>(this.desc != null ? 2 : 1);
    }
    if (this.desc != null) {
      values.add(name);
    }
    AnnotationNode annotation = new AnnotationNode(descriptor);
    values.add(annotation);
    return annotation;
  }

  @Override
  public AnnotationVisitor visitArray(final String name) {
    if (values == null) {
      values = new ArrayList<>(this.desc != null ? 2 : 1);
    }
    if (this.desc != null) {
      values.add(name);
    }
    List<Object> array = new ArrayList<>();
    values.add(array);
    return new AnnotationNode(array);
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  // ------------------------------------------------------------------------
  // Accept methods
  // ------------------------------------------------------------------------

  /**
   * Checks that this annotation node is compatible with the given ASM API version. This method
   * checks that this node, and all its children recursively, do not contain elements that were
   * introduced in more recent versions of the ASM API than the given version.
   *
   * @param api an ASM API version. Must be one of the {@code ASM}<i>x</i> values in {@link
   *     Opcodes}.
   */
  public void check(final int api) {
    // nothing to do
  }

  /**
   * Makes the given visitor visit this annotation.
   *
   * @param annotationVisitor an annotation visitor. Maybe {@literal null}.
   */
  public void accept(final AnnotationVisitor annotationVisitor) {
    if (annotationVisitor != null) {
      if (values != null) {
        for (int i = 0, n = values.size(); i < n; i += 2) {
          String name = (String) values.get(i);
          Object value = values.get(i + 1);
          accept(annotationVisitor, name, value);
        }
      }
      annotationVisitor.visitEnd();
    }
  }

  /**
   * Makes the given visitor visit a given annotation value.
   *
   * @param annotationVisitor an annotation visitor. Maybe {@literal null}.
   * @param name the value name.
   * @param value the actual value.
   */
  static void accept(
      final AnnotationVisitor annotationVisitor, final String name, final Object value) {
    if (annotationVisitor != null) {
      if (value instanceof String[]) {
        String[] typeValue = (String[]) value;
        annotationVisitor.visitEnum(name, typeValue[0], typeValue[1]);
      } else if (value instanceof AnnotationNode) {
        AnnotationNode annotationValue = (AnnotationNode) value;
        annotationValue.accept(annotationVisitor.visitAnnotation(name, annotationValue.desc));
      } else if (value instanceof List) {
        AnnotationVisitor arrayAnnotationVisitor = annotationVisitor.visitArray(name);
        if (arrayAnnotationVisitor != null) {
          List<?> arrayValue = (List<?>) value;
          for (int i = 0, n = arrayValue.size(); i < n; ++i) {
            accept(arrayAnnotationVisitor, null, arrayValue.get(i));
          }
          arrayAnnotationVisitor.visitEnd();
        }
      } else {
        annotationVisitor.visit(name, value);
      }
    }
  }
}

package org.objectweb.asm.tree;

import org.objectweb.asm.ClassVisitor;

/**
 * A node that represents an inner class. This inner class is not necessarily a member of the {@link
 * ClassNode} containing this object. More precisely, every class or interface C which is referenced
 * by a {@link ClassNode} and which is not a package member must be represented with an {@link
 * InnerClassNode}. The {@link ClassNode} must reference its nested class or interface members, and
 * its enclosing class, if any. See the JVMS 4.7.6 section for more details.
 *
 * @author Eric Bruneton
 */
public class InnerClassNode {

  /** The internal name of an inner class (see {@link org.objectweb.asm.Type#getInternalName()}). */
  public @InternalForm String name;

  /**
   * The internal name of the class to which the inner class belongs (see {@link
   * org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  public @InternalForm String outerName;

  /**
   * The (simple) name of the inner class inside its enclosing class. Must be {@literal null} if the
   * inner class is not the member of a class or interface (e.g. for local or anonymous classes).
   */
  public @Identifier String innerName;

  /**
   * The access flags of the inner class as originally declared in the source code from which the
   * class was compiled.
   */
  public int access;

  /**
   * Constructs a new {@link InnerClassNode} for an inner class C.
   *
   * @param name the internal name of C (see {@link org.objectweb.asm.Type#getInternalName()}).
   * @param outerName the internal name of the class or interface C is a member of (see {@link
   *     org.objectweb.asm.Type#getInternalName()}). Must be {@literal null} if C is not the member
   *     of a class or interface (e.g. for local or anonymous classes).
   * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.
   * @param access the access flags of C originally declared in the source code from which this
   *     class was compiled.
   */
  public InnerClassNode(
      final @InternalForm String name, final @InternalForm String outerName, final @Identifier String innerName, final int access) {
    this.name = name;
    this.outerName = outerName;
    this.innerName = innerName;
    this.access = access;
  }

  /**
   * Makes the given class visitor visit this inner class.
   *
   * @param classVisitor a class visitor.
   */
  public void accept(final ClassVisitor classVisitor) {
    classVisitor.visitInnerClass(name, outerName, innerName, access);
  }
}

package org.objectweb.asm.tree;

import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a parameter of a method.
 *
 * @author Remi Forax
 */
public class ParameterNode {

  /** The parameter's name. */
  public String name;

  /**
   * The parameter's access flags (see {@link org.objectweb.asm.Opcodes}). Valid values are {@code
   * ACC_FINAL}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   */
  public int access;

  /**
   * Constructs a new {@link ParameterNode}.
   *
   * @param access The parameter's access flags. Valid values are {@code ACC_FINAL}, {@code
   *     ACC_SYNTHETIC} or/and {@code ACC_MANDATED} (see {@link org.objectweb.asm.Opcodes}).
   * @param name the parameter's name.
   */
  public ParameterNode(final String name, final int access) {
    this.name = name;
    this.access = access;
  }

  /**
   * Makes the given visitor visit this parameter declaration.
   *
   * @param methodVisitor a method visitor.
   */
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitParameter(name, access);
  }
}

package org.objectweb.asm.tree;

import java.util.List;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a try catch block.
 *
 * @author Eric Bruneton
 */
public class TryCatchBlockNode {

  /** The beginning of the exception handler's scope (inclusive). */
  public LabelNode start;

  /** The end of the exception handler's scope (exclusive). */
  public LabelNode end;

  /** The beginning of the exception handler's code. */
  public LabelNode handler;

  /**
   * The internal name of the type of exceptions handled by the handler. May be {@literal null} to
   * catch any exceptions (for "finally" blocks).
   */
  public @InternalForm String type;

  /** The runtime visible type annotations on the exception handler type. May be {@literal null}. */
  public List<TypeAnnotationNode> visibleTypeAnnotations;

  /**
   * The runtime invisible type annotations on the exception handler type. May be {@literal null}.
   */
  public List<TypeAnnotationNode> invisibleTypeAnnotations;

  /**
   * Constructs a new {@link TryCatchBlockNode}.
   *
   * @param start the beginning of the exception handler's scope (inclusive).
   * @param end the end of the exception handler's scope (exclusive).
   * @param handler the beginning of the exception handler's code.
   * @param type the internal name of the type of exceptions handled by the handler (see {@link
   *     org.objectweb.asm.Type#getInternalName()}), or {@literal null} to catch any exceptions (for
   *     "finally" blocks).
   */
  public TryCatchBlockNode(
      final LabelNode start, final LabelNode end, final LabelNode handler, final @InternalForm String type) {
    this.start = start;
    this.end = end;
    this.handler = handler;
    this.type = type;
  }

  /**
   * Updates the index of this try catch block in the method's list of try catch block nodes. This
   * index maybe stored in the 'target' field of the type annotations of this block.
   *
   * @param index the new index of this try catch block in the method's list of try catch block
   *     nodes.
   */
  public void updateIndex(final int index) {
    int newTypeRef = 0x42000000 | (index << 8);
    if (visibleTypeAnnotations != null) {
      for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
        visibleTypeAnnotations.get(i).typeRef = newTypeRef;
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
        invisibleTypeAnnotations.get(i).typeRef = newTypeRef;
      }
    }
  }

  /**
   * Makes the given visitor visit this try catch block.
   *
   * @param methodVisitor a method visitor.
   */
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitTryCatchBlock(
        start.getLabel(), end.getLabel(), handler == null ? null : handler.getLabel(), type);
    if (visibleTypeAnnotations != null) {
      for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = visibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            methodVisitor.visitTryCatchAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, true));
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            methodVisitor.visitTryCatchAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
      }
    }
  }
}

package org.objectweb.asm.tree;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a bytecode instruction. <i>An instruction can appear at most once in at
 * most one {@link InsnList} at a time</i>.
 *
 * @author Eric Bruneton
 */
public abstract class AbstractInsnNode {

  /** The type of {@link InsnNode} instructions. */
  public static final int INSN = 0;

  /** The type of {@link IntInsnNode} instructions. */
  public static final int INT_INSN = 1;

  /** The type of {@link VarInsnNode} instructions. */
  public static final int VAR_INSN = 2;

  /** The type of {@link TypeInsnNode} instructions. */
  public static final int TYPE_INSN = 3;

  /** The type of {@link FieldInsnNode} instructions. */
  public static final int FIELD_INSN = 4;

  /** The type of {@link MethodInsnNode} instructions. */
  public static final int METHOD_INSN = 5;

  /** The type of {@link InvokeDynamicInsnNode} instructions. */
  public static final int INVOKE_DYNAMIC_INSN = 6;

  /** The type of {@link JumpInsnNode} instructions. */
  public static final int JUMP_INSN = 7;

  /** The type of {@link LabelNode} "instructions". */
  public static final int LABEL = 8;

  /** The type of {@link LdcInsnNode} instructions. */
  public static final int LDC_INSN = 9;

  /** The type of {@link IincInsnNode} instructions. */
  public static final int IINC_INSN = 10;

  /** The type of {@link TableSwitchInsnNode} instructions. */
  public static final int TABLESWITCH_INSN = 11;

  /** The type of {@link LookupSwitchInsnNode} instructions. */
  public static final int LOOKUPSWITCH_INSN = 12;

  /** The type of {@link MultiANewArrayInsnNode} instructions. */
  public static final int MULTIANEWARRAY_INSN = 13;

  /** The type of {@link FrameNode} "instructions". */
  public static final int FRAME = 14;

  /** The type of {@link LineNumberNode} "instructions". */
  public static final int LINE = 15;

  /**
   * The opcode of this instruction, or -1 if this is not a JVM instruction (e.g. a label or a line
   * number).
   */
  protected int opcode;

  /**
   * The runtime visible type annotations of this instruction. This field is only used for real
   * instructions (i.e. not for labels, frames, or line number nodes). This list is a list of {@link
   * TypeAnnotationNode} objects. May be {@literal null}.
   */
  public List<TypeAnnotationNode> visibleTypeAnnotations;

  /**
   * The runtime invisible type annotations of this instruction. This field is only used for real
   * instructions (i.e. not for labels, frames, or line number nodes). This list is a list of {@link
   * TypeAnnotationNode} objects. May be {@literal null}.
   */
  public List<TypeAnnotationNode> invisibleTypeAnnotations;

  /** The previous instruction in the list to which this instruction belongs. */
  AbstractInsnNode previousInsn;

  /** The next instruction in the list to which this instruction belongs. */
  AbstractInsnNode nextInsn;

  /**
   * The index of this instruction in the list to which it belongs. The value of this field is
   * correct only when {@link InsnList#cache} is not null. A value of -1 indicates that this
   * instruction does not belong to any {@link InsnList}.
   */
  int index;

  /**
   * Constructs a new {@link AbstractInsnNode}.
   *
   * @param opcode the opcode of the instruction to be constructed.
   */
  protected AbstractInsnNode(final int opcode) {
    this.opcode = opcode;
    this.index = -1;
  }

  /**
   * Returns the opcode of this instruction.
   *
   * @return the opcode of this instruction, or -1 if this is not a JVM instruction (e.g. a label or
   *     a line number).
   */
  public int getOpcode() {
    return opcode;
  }

  /**
   * Returns the type of this instruction.
   *
   * @return the type of this instruction, i.e. one the constants defined in this class.
   */
  public abstract int getType();

  /**
   * Returns the previous instruction in the list to which this instruction belongs, if any.
   *
   * @return the previous instruction in the list to which this instruction belongs, if any. May be
   *     {@literal null}.
   */
  public AbstractInsnNode getPrevious() {
    return previousInsn;
  }

  /**
   * Returns the next instruction in the list to which this instruction belongs, if any.
   *
   * @return the next instruction in the list to which this instruction belongs, if any. May be
   *     {@literal null}.
   */
  public AbstractInsnNode getNext() {
    return nextInsn;
  }

  /**
   * Makes the given method visitor visit this instruction.
   *
   * @param methodVisitor a method visitor.
   */
  public abstract void accept(MethodVisitor methodVisitor);

  /**
   * Makes the given visitor visit the annotations of this instruction.
   *
   * @param methodVisitor a method visitor.
   */
  protected final void acceptAnnotations(final MethodVisitor methodVisitor) {
    if (visibleTypeAnnotations != null) {
      for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = visibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            methodVisitor.visitInsnAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, true));
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            methodVisitor.visitInsnAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
      }
    }
  }

  /**
   * Returns a copy of this instruction.
   *
   * @param clonedLabels a map from LabelNodes to cloned LabelNodes.
   * @return a copy of this instruction. The returned instruction does not belong to any {@link
   *     InsnList}.
   */
  public abstract AbstractInsnNode clone(Map<LabelNode, LabelNode> clonedLabels);

  /**
   * Returns the clone of the given label.
   *
   * @param label a label.
   * @param clonedLabels a map from LabelNodes to cloned LabelNodes.
   * @return the clone of the given label.
   */
  static LabelNode clone(final LabelNode label, final Map<LabelNode, LabelNode> clonedLabels) {
    return clonedLabels.get(label);
  }

  /**
   * Returns the clones of the given labels.
   *
   * @param labels a list of labels.
   * @param clonedLabels a map from LabelNodes to cloned LabelNodes.
   * @return the clones of the given labels.
   */
  static LabelNode[] clone(
      final List<LabelNode> labels, final Map<LabelNode, LabelNode> clonedLabels) {
    LabelNode[] clones = new LabelNode[labels.size()];
    for (int i = 0, n = clones.length; i < n; ++i) {
      clones[i] = clonedLabels.get(labels.get(i));
    }
    return clones;
  }

  /**
   * Clones the annotations of the given instruction into this instruction.
   *
   * @param insnNode the source instruction.
   * @return this instruction.
   */
  protected final AbstractInsnNode cloneAnnotations(final AbstractInsnNode insnNode) {
    if (insnNode.visibleTypeAnnotations != null) {
      this.visibleTypeAnnotations = new ArrayList<>();
      for (int i = 0, n = insnNode.visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode sourceAnnotation = insnNode.visibleTypeAnnotations.get(i);
        TypeAnnotationNode cloneAnnotation =
            new TypeAnnotationNode(
                sourceAnnotation.typeRef, sourceAnnotation.typePath, sourceAnnotation.desc);
        sourceAnnotation.accept(cloneAnnotation);
        this.visibleTypeAnnotations.add(cloneAnnotation);
      }
    }
    if (insnNode.invisibleTypeAnnotations != null) {
      this.invisibleTypeAnnotations = new ArrayList<>();
      for (int i = 0, n = insnNode.invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode sourceAnnotation = insnNode.invisibleTypeAnnotations.get(i);
        TypeAnnotationNode cloneAnnotation =
            new TypeAnnotationNode(
                sourceAnnotation.typeRef, sourceAnnotation.typePath, sourceAnnotation.desc);
        sourceAnnotation.accept(cloneAnnotation);
        this.invisibleTypeAnnotations.add(cloneAnnotation);
      }
    }
    return this;
  }
}

package org.objectweb.asm.tree;

import java.util.List;
import java.util.Map;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents a LOOKUPSWITCH instruction.
 *
 * @author Eric Bruneton
 */
public class LookupSwitchInsnNode extends AbstractInsnNode {

  /** Beginning of the default handler block. */
  public LabelNode dflt;

  /** The values of the keys. */
  public List<Integer> keys;

  /** Beginnings of the handler blocks. */
  public List<LabelNode> labels;

  /**
   * Constructs a new {@link LookupSwitchInsnNode}.
   *
   * @param dflt beginning of the default handler block.
   * @param keys the values of the keys.
   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the
   *     handler block for the {@code keys[i]} key.
   */
  public LookupSwitchInsnNode(final LabelNode dflt, final int[] keys, final LabelNode[] labels) {
    super(Opcodes.LOOKUPSWITCH);
    this.dflt = dflt;
    this.keys = Util.asArrayList(keys);
    this.labels = Util.asArrayList(labels);
  }

  @Override
  public int getType() {
    return LOOKUPSWITCH_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    int[] keysArray = new int[this.keys.size()];
    for (int i = 0, n = keysArray.length; i < n; ++i) {
      keysArray[i] = this.keys.get(i).intValue();
    }
    Label[] labelsArray = new Label[this.labels.size()];
    for (int i = 0, n = labelsArray.length; i < n; ++i) {
      labelsArray[i] = this.labels.get(i).getLabel();
    }
    methodVisitor.visitLookupSwitchInsn(dflt.getLabel(), keysArray, labelsArray);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    LookupSwitchInsnNode clone =
        new LookupSwitchInsnNode(clone(dflt, clonedLabels), null, clone(labels, clonedLabels));
    clone.keys.addAll(keys);
    return clone.cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents a stack map frame. These nodes are pseudo instruction nodes in order to be
 * inserted in an instruction list. In fact these nodes must(*) be inserted <i>just before</i> any
 * instruction node <b>i</b> that follows an unconditionnal branch instruction such as GOTO or
 * THROW, that is the target of a jump instruction, or that starts an exception handler block. The
 * stack map frame types must describe the values of the local variables and of the operand stack
 * elements <i>just before</i> <b>i</b> is executed. <br>
 * <br>
 * (*) this is mandatory only for classes whose version is greater than or equal to {@link
 * Opcodes#V1_6}.
 *
 * @author Eric Bruneton
 */
public class FrameNode extends AbstractInsnNode {

  /**
   * The type of this frame. Must be {@link Opcodes#F_NEW} for expanded frames, or {@link
   * Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or
   * {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.
   */
  public int type;

  /**
   * The types of the local variables of this stack map frame. Elements of this list can be Integer,
   * String or LabelNode objects (for primitive, reference and uninitialized types respectively -
   * see {@link MethodVisitor}).
   */
  public List<Object> local;

  /**
   * The types of the operand stack elements of this stack map frame. Elements of this list can be
   * Integer, String or LabelNode objects (for primitive, reference and uninitialized types
   * respectively - see {@link MethodVisitor}).
   */
  public List<Object> stack;

  private FrameNode() {
    super(-1);
  }

  /**
   * Constructs a new {@link FrameNode}.
   *
   * @param type the type of this frame. Must be {@link Opcodes#F_NEW} for expanded frames, or
   *     {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link
   *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.
   * @param numLocal number of local variables of this stack map frame. Long and double values count
   *     for one variable.
   * @param local the types of the local variables of this stack map frame. Elements of this list
   *     can be Integer, String or LabelNode objects (for primitive, reference and uninitialized
   *     types respectively - see {@link MethodVisitor}). Long and double values are represented by
   *     a single element.
   * @param numStack number of operand stack elements of this stack map frame. Long and double
   *     values count for one stack element.
   * @param stack the types of the operand stack elements of this stack map frame. Elements of this
   *     list can be Integer, String or LabelNode objects (for primitive, reference and
   *     uninitialized types respectively - see {@link MethodVisitor}). Long and double values are
   *     represented by a single element.
   */
  public FrameNode(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    super(-1);
    this.type = type;
    switch (type) {
      case Opcodes.F_NEW:
      case Opcodes.F_FULL:
        this.local = Util.asArrayList(numLocal, local);
        this.stack = Util.asArrayList(numStack, stack);
        break;
      case Opcodes.F_APPEND:
        this.local = Util.asArrayList(numLocal, local);
        break;
      case Opcodes.F_CHOP:
        this.local = Util.asArrayList(numLocal);
        break;
      case Opcodes.F_SAME:
        break;
      case Opcodes.F_SAME1:
        this.stack = Util.asArrayList(1, stack);
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public int getType() {
    return FRAME;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    switch (type) {
      case Opcodes.F_NEW:
      case Opcodes.F_FULL:
        methodVisitor.visitFrame(type, local.size(), asArray(local), stack.size(), asArray(stack));
        break;
      case Opcodes.F_APPEND:
        methodVisitor.visitFrame(type, local.size(), asArray(local), 0, null);
        break;
      case Opcodes.F_CHOP:
        methodVisitor.visitFrame(type, local.size(), null, 0, null);
        break;
      case Opcodes.F_SAME:
        methodVisitor.visitFrame(type, 0, null, 0, null);
        break;
      case Opcodes.F_SAME1:
        methodVisitor.visitFrame(type, 0, null, 1, asArray(stack));
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    FrameNode clone = new FrameNode();
    clone.type = type;
    if (local != null) {
      clone.local = new ArrayList<>();
      for (int i = 0, n = local.size(); i < n; ++i) {
        Object localElement = local.get(i);
        if (localElement instanceof LabelNode) {
          localElement = clonedLabels.get(localElement);
        }
        clone.local.add(localElement);
      }
    }
    if (stack != null) {
      clone.stack = new ArrayList<>();
      for (int i = 0, n = stack.size(); i < n; ++i) {
        Object stackElement = stack.get(i);
        if (stackElement instanceof LabelNode) {
          stackElement = clonedLabels.get(stackElement);
        }
        clone.stack.add(stackElement);
      }
    }
    return clone;
  }

  private static Object[] asArray(final List<Object> list) {
    Object[] array = new Object[list.size()];
    for (int i = 0, n = array.length; i < n; ++i) {
      Object o = list.get(i);
      if (o instanceof LabelNode) {
        o = ((LabelNode) o).getLabel();
      }
      array[i] = o;
    }
    return array;
  }
}

package org.objectweb.asm.tree;

import java.util.ListIterator;
import java.util.NoSuchElementException;
import org.objectweb.asm.MethodVisitor;

/**
 * A doubly linked list of {@link AbstractInsnNode} objects. <i>This implementation is not thread
 * safe</i>.
 */
public class InsnList implements Iterable<AbstractInsnNode> {

  /** The number of instructions in this list. */
  private int size;

  /** The first instruction in this list. May be {@literal null}. */
  private AbstractInsnNode firstInsn;

  /** The last instruction in this list. May be {@literal null}. */
  private AbstractInsnNode lastInsn;

  /**
   * A cache of the instructions of this list. This cache is used to improve the performance of the
   * {@link #get} method.
   */
  AbstractInsnNode[] cache;

  /**
   * Returns the number of instructions in this list.
   *
   * @return the number of instructions in this list.
   */
  public int size() {
    return size;
  }

  /**
   * Returns the first instruction in this list.
   *
   * @return the first instruction in this list, or {@literal null} if the list is empty.
   */
  public AbstractInsnNode getFirst() {
    return firstInsn;
  }

  /**
   * Returns the last instruction in this list.
   *
   * @return the last instruction in this list, or {@literal null} if the list is empty.
   */
  public AbstractInsnNode getLast() {
    return lastInsn;
  }

  /**
   * Returns the instruction whose index is given. This method builds a cache of the instructions in
   * this list to avoid scanning the whole list each time it is called. Once the cache is built,
   * this method runs in constant time. This cache is invalidated by all the methods that modify the
   * list.
   *
   * @param index the index of the instruction that must be returned.
   * @return the instruction whose index is given.
   * @throws IndexOutOfBoundsException if (index &lt; 0 || index &gt;= size()).
   */
  public AbstractInsnNode get(final int index) {
    if (index < 0 || index >= size) {
      throw new IndexOutOfBoundsException();
    }
    if (cache == null) {
      cache = toArray();
    }
    return cache[index];
  }

  /**
   * Returns {@literal true} if the given instruction belongs to this list. This method always scans
   * the instructions of this list until it finds the given instruction or reaches the end of the
   * list.
   *
   * @param insnNode an instruction.
   * @return {@literal true} if the given instruction belongs to this list.
   */
  public boolean contains(final AbstractInsnNode insnNode) {
    AbstractInsnNode currentInsn = firstInsn;
    while (currentInsn != null && currentInsn != insnNode) {
      currentInsn = currentInsn.nextInsn;
    }
    return currentInsn != null;
  }

  /**
   * Returns the index of the given instruction in this list. This method builds a cache of the
   * instruction indexes to avoid scanning the whole list each time it is called. Once the cache is
   * built, this method run in constant time. The cache is invalidated by all the methods that
   * modify the list.
   *
   * @param insnNode an instruction <i>of this list</i>.
   * @return the index of the given instruction in this list. <i>The result of this method is
   *     undefined if the given instruction does not belong to this list</i>. Use {@link #contains }
   *     to test if an instruction belongs to an instruction list or not.
   */
  public int indexOf(final AbstractInsnNode insnNode) {
    if (cache == null) {
      cache = toArray();
    }
    return insnNode.index;
  }

  /**
   * Makes the given visitor visit all the instructions in this list.
   *
   * @param methodVisitor the method visitor that must visit the instructions.
   */
  public void accept(final MethodVisitor methodVisitor) {
    AbstractInsnNode currentInsn = firstInsn;
    while (currentInsn != null) {
      currentInsn.accept(methodVisitor);
      currentInsn = currentInsn.nextInsn;
    }
  }

  /**
   * Returns an iterator over the instructions in this list.
   *
   * @return an iterator over the instructions in this list.
   */
  @Override
  public ListIterator<AbstractInsnNode> iterator() {
    return iterator(0);
  }

  /**
   * Returns an iterator over the instructions in this list.
   *
   * @param index index of instruction for the iterator to start at.
   * @return an iterator over the instructions in this list.
   */
  @SuppressWarnings("unchecked")
  public ListIterator<AbstractInsnNode> iterator(final int index) {
    return new InsnListIterator(index);
  }

  /**
   * Returns an array containing all the instructions in this list.
   *
   * @return an array containing all the instructions in this list.
   */
  public AbstractInsnNode[] toArray() {
    int currentInsnIndex = 0;
    AbstractInsnNode currentInsn = firstInsn;
    AbstractInsnNode[] insnNodeArray = new AbstractInsnNode[size];
    while (currentInsn != null) {
      insnNodeArray[currentInsnIndex] = currentInsn;
      currentInsn.index = currentInsnIndex++;
      currentInsn = currentInsn.nextInsn;
    }
    return insnNodeArray;
  }

  /**
   * Replaces an instruction of this list with another instruction.
   *
   * @param oldInsnNode an instruction <i>of this list</i>.
   * @param newInsnNode another instruction, <i>which must not belong to any {@link InsnList}</i>.
   */
  public void set(final AbstractInsnNode oldInsnNode, final AbstractInsnNode newInsnNode) {
    AbstractInsnNode nextInsn = oldInsnNode.nextInsn;
    newInsnNode.nextInsn = nextInsn;
    if (nextInsn != null) {
      nextInsn.previousInsn = newInsnNode;
    } else {
      lastInsn = newInsnNode;
    }
    AbstractInsnNode previousInsn = oldInsnNode.previousInsn;
    newInsnNode.previousInsn = previousInsn;
    if (previousInsn != null) {
      previousInsn.nextInsn = newInsnNode;
    } else {
      firstInsn = newInsnNode;
    }
    if (cache != null) {
      int index = oldInsnNode.index;
      cache[index] = newInsnNode;
      newInsnNode.index = index;
    } else {
      newInsnNode.index = 0; // newInsnNode now belongs to an InsnList.
    }
    oldInsnNode.index = -1; // oldInsnNode no longer belongs to an InsnList.
    oldInsnNode.previousInsn = null;
    oldInsnNode.nextInsn = null;
  }

  /**
   * Adds the given instruction to the end of this list.
   *
   * @param insnNode an instruction, <i>which must not belong to any {@link InsnList}</i>.
   */
  public void add(final AbstractInsnNode insnNode) {
    ++size;
    if (lastInsn == null) {
      firstInsn = insnNode;
      lastInsn = insnNode;
    } else {
      lastInsn.nextInsn = insnNode;
      insnNode.previousInsn = lastInsn;
    }
    lastInsn = insnNode;
    cache = null;
    insnNode.index = 0; // insnNode now belongs to an InsnList.
  }

  /**
   * Adds the given instructions to the end of this list.
   *
   * @param insnList an instruction list, which is cleared during the process. This list must be
   *     different from 'this'.
   */
  public void add(final InsnList insnList) {
    if (insnList.size == 0) {
      return;
    }
    size += insnList.size;
    if (lastInsn == null) {
      firstInsn = insnList.firstInsn;
      lastInsn = insnList.lastInsn;
    } else {
      AbstractInsnNode firstInsnListElement = insnList.firstInsn;
      lastInsn.nextInsn = firstInsnListElement;
      firstInsnListElement.previousInsn = lastInsn;
      lastInsn = insnList.lastInsn;
    }
    cache = null;
    insnList.removeAll(false);
  }

  /**
   * Inserts the given instruction at the beginning of this list.
   *
   * @param insnNode an instruction, <i>which must not belong to any {@link InsnList}</i>.
   */
  public void insert(final AbstractInsnNode insnNode) {
    ++size;
    if (firstInsn == null) {
      firstInsn = insnNode;
      lastInsn = insnNode;
    } else {
      firstInsn.previousInsn = insnNode;
      insnNode.nextInsn = firstInsn;
    }
    firstInsn = insnNode;
    cache = null;
    insnNode.index = 0; // insnNode now belongs to an InsnList.
  }

  /**
   * Inserts the given instructions at the beginning of this list.
   *
   * @param insnList an instruction list, which is cleared during the process. This list must be
   *     different from 'this'.
   */
  public void insert(final InsnList insnList) {
    if (insnList.size == 0) {
      return;
    }
    size += insnList.size;
    if (firstInsn == null) {
      firstInsn = insnList.firstInsn;
      lastInsn = insnList.lastInsn;
    } else {
      AbstractInsnNode lastInsnListElement = insnList.lastInsn;
      firstInsn.previousInsn = lastInsnListElement;
      lastInsnListElement.nextInsn = firstInsn;
      firstInsn = insnList.firstInsn;
    }
    cache = null;
    insnList.removeAll(false);
  }

  /**
   * Inserts the given instruction after the specified instruction.
   *
   * @param previousInsn an instruction <i>of this list</i> after which insnNode must be inserted.
   * @param insnNode the instruction to be inserted, <i>which must not belong to any {@link
   *     InsnList}</i>.
   */
  public void insert(final AbstractInsnNode previousInsn, final AbstractInsnNode insnNode) {
    ++size;
    AbstractInsnNode nextInsn = previousInsn.nextInsn;
    if (nextInsn == null) {
      lastInsn = insnNode;
    } else {
      nextInsn.previousInsn = insnNode;
    }
    previousInsn.nextInsn = insnNode;
    insnNode.nextInsn = nextInsn;
    insnNode.previousInsn = previousInsn;
    cache = null;
    insnNode.index = 0; // insnNode now belongs to an InsnList.
  }

  /**
   * Inserts the given instructions after the specified instruction.
   *
   * @param previousInsn an instruction <i>of this list</i> after which the instructions must be
   *     inserted.
   * @param insnList the instruction list to be inserted, which is cleared during the process. This
   *     list must be different from 'this'.
   */
  public void insert(final AbstractInsnNode previousInsn, final InsnList insnList) {
    if (insnList.size == 0) {
      return;
    }
    size += insnList.size;
    AbstractInsnNode firstInsnListElement = insnList.firstInsn;
    AbstractInsnNode lastInsnListElement = insnList.lastInsn;
    AbstractInsnNode nextInsn = previousInsn.nextInsn;
    if (nextInsn == null) {
      lastInsn = lastInsnListElement;
    } else {
      nextInsn.previousInsn = lastInsnListElement;
    }
    previousInsn.nextInsn = firstInsnListElement;
    lastInsnListElement.nextInsn = nextInsn;
    firstInsnListElement.previousInsn = previousInsn;
    cache = null;
    insnList.removeAll(false);
  }

  /**
   * Inserts the given instruction before the specified instruction.
   *
   * @param nextInsn an instruction <i>of this list</i> before which insnNode must be inserted.
   * @param insnNode the instruction to be inserted, <i>which must not belong to any {@link
   *     InsnList}</i>.
   */
  public void insertBefore(final AbstractInsnNode nextInsn, final AbstractInsnNode insnNode) {
    ++size;
    AbstractInsnNode previousInsn = nextInsn.previousInsn;
    if (previousInsn == null) {
      firstInsn = insnNode;
    } else {
      previousInsn.nextInsn = insnNode;
    }
    nextInsn.previousInsn = insnNode;
    insnNode.nextInsn = nextInsn;
    insnNode.previousInsn = previousInsn;
    cache = null;
    insnNode.index = 0; // insnNode now belongs to an InsnList.
  }

  /**
   * Inserts the given instructions before the specified instruction.
   *
   * @param nextInsn an instruction <i>of this list</i> before which the instructions must be
   *     inserted.
   * @param insnList the instruction list to be inserted, which is cleared during the process. This
   *     list must be different from 'this'.
   */
  public void insertBefore(final AbstractInsnNode nextInsn, final InsnList insnList) {
    if (insnList.size == 0) {
      return;
    }
    size += insnList.size;
    AbstractInsnNode firstInsnListElement = insnList.firstInsn;
    AbstractInsnNode lastInsnListElement = insnList.lastInsn;
    AbstractInsnNode previousInsn = nextInsn.previousInsn;
    if (previousInsn == null) {
      firstInsn = firstInsnListElement;
    } else {
      previousInsn.nextInsn = firstInsnListElement;
    }
    nextInsn.previousInsn = lastInsnListElement;
    lastInsnListElement.nextInsn = nextInsn;
    firstInsnListElement.previousInsn = previousInsn;
    cache = null;
    insnList.removeAll(false);
  }

  /**
   * Removes the given instruction from this list.
   *
   * @param insnNode the instruction <i>of this list</i> that must be removed.
   */
  public void remove(final AbstractInsnNode insnNode) {
    --size;
    AbstractInsnNode nextInsn = insnNode.nextInsn;
    AbstractInsnNode previousInsn = insnNode.previousInsn;
    if (nextInsn == null) {
      if (previousInsn == null) {
        firstInsn = null;
        lastInsn = null;
      } else {
        previousInsn.nextInsn = null;
        lastInsn = previousInsn;
      }
    } else {
      if (previousInsn == null) {
        firstInsn = nextInsn;
        nextInsn.previousInsn = null;
      } else {
        previousInsn.nextInsn = nextInsn;
        nextInsn.previousInsn = previousInsn;
      }
    }
    cache = null;
    insnNode.index = -1; // insnNode no longer belongs to an InsnList.
    insnNode.previousInsn = null;
    insnNode.nextInsn = null;
  }

  /**
   * Removes all the instructions of this list.
   *
   * @param mark if the instructions must be marked as no longer belonging to any {@link InsnList}.
   */
  void removeAll(final boolean mark) {
    if (mark) {
      AbstractInsnNode currentInsn = firstInsn;
      while (currentInsn != null) {
        AbstractInsnNode next = currentInsn.nextInsn;
        currentInsn.index = -1; // currentInsn no longer belongs to an InsnList.
        currentInsn.previousInsn = null;
        currentInsn.nextInsn = null;
        currentInsn = next;
      }
    }
    size = 0;
    firstInsn = null;
    lastInsn = null;
    cache = null;
  }

  /** Removes all the instructions of this list. */
  public void clear() {
    removeAll(false);
  }

  /**
   * Resets all the labels in the instruction list. This method should be called before reusing an
   * instruction list between several <code>ClassWriter</code>s.
   */
  public void resetLabels() {
    AbstractInsnNode currentInsn = firstInsn;
    while (currentInsn != null) {
      if (currentInsn instanceof LabelNode) {
        ((LabelNode) currentInsn).resetLabel();
      }
      currentInsn = currentInsn.nextInsn;
    }
  }

  // Note: this class is not generified because it would create bridges.
  @SuppressWarnings("rawtypes")
  private final class InsnListIterator implements ListIterator {

    AbstractInsnNode nextInsn;

    AbstractInsnNode previousInsn;

    AbstractInsnNode remove;

    InsnListIterator(final int index) {
      if (index < 0 || index > size()) {
        throw new IndexOutOfBoundsException();
      } else if (index == size()) {
        nextInsn = null;
        previousInsn = getLast();
      } else {
        AbstractInsnNode currentInsn = getFirst();
        for (int i = 0; i < index; i++) {
          currentInsn = currentInsn.nextInsn;
        }

        nextInsn = currentInsn;
        previousInsn = currentInsn.previousInsn;
      }
    }

    @Override
    public boolean hasNext() {
      return nextInsn != null;
    }

    @Override
    public Object next() {
      if (nextInsn == null) {
        throw new NoSuchElementException();
      }
      AbstractInsnNode result = nextInsn;
      previousInsn = result;
      nextInsn = result.nextInsn;
      remove = result;
      return result;
    }

    @Override
    public void remove() {
      if (remove != null) {
        if (remove == nextInsn) {
          nextInsn = nextInsn.nextInsn;
        } else {
          previousInsn = previousInsn.previousInsn;
        }
        InsnList.this.remove(remove);
        remove = null;
      } else {
        throw new IllegalStateException();
      }
    }

    @Override
    public boolean hasPrevious() {
      return previousInsn != null;
    }

    @Override
    public Object previous() {
      if (previousInsn == null) {
        throw new NoSuchElementException();
      }
      AbstractInsnNode result = previousInsn;
      nextInsn = result;
      previousInsn = result.previousInsn;
      remove = result;
      return result;
    }

    @Override
    public int nextIndex() {
      if (nextInsn == null) {
        return size();
      }
      if (cache == null) {
        cache = toArray();
      }
      return nextInsn.index;
    }

    @Override
    public int previousIndex() {
      if (previousInsn == null) {
        return -1;
      }
      if (cache == null) {
        cache = toArray();
      }
      return previousInsn.index;
    }

    @Override
    public void add(final Object o) {
      if (nextInsn != null) {
        InsnList.this.insertBefore(nextInsn, (AbstractInsnNode) o);
      } else if (previousInsn != null) {
        InsnList.this.insert(previousInsn, (AbstractInsnNode) o);
      } else {
        InsnList.this.add((AbstractInsnNode) o);
      }
      previousInsn = (AbstractInsnNode) o;
      remove = null;
    }

    @Override
    public void set(final Object o) {
      if (remove != null) {
        InsnList.this.set(remove, (AbstractInsnNode) o);
        if (remove == previousInsn) {
          previousInsn = (AbstractInsnNode) o;
        } else {
          nextInsn = (AbstractInsnNode) o;
        }
      } else {
        throw new IllegalStateException();
      }
    }
  }
}

package org.objectweb.asm.tree;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents a module declaration.
 *
 * @author Remi Forax
 */
public class ModuleNode extends ModuleVisitor {

  /** The fully qualified name (using dots) of this module. */
  public String name;

  /**
   * The module's access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code
   * ACC_MANDATED}.
   */
  public int access;

  /** The version of this module. May be {@literal null}. */
  public String version;

  /**
   * The internal name of the main class of this module (see {@link
   * org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  public @InternalForm String mainClass;

  /**
   * The internal name of the packages declared by this module (see {@link
   * org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  public List<@InternalForm String> packages;

  /** The dependencies of this module. May be {@literal null}. */
  public List<ModuleRequireNode> requires;

  /** The packages exported by this module. May be {@literal null}. */
  public List<ModuleExportNode> exports;

  /** The packages opened by this module. May be {@literal null}. */
  public List<ModuleOpenNode> opens;

  /**
   * The internal names of the services used by this module (see {@link
   * org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  public List<@InternalForm String> uses;

  /** The services provided by this module. May be {@literal null}. */
  public List<ModuleProvideNode> provides;

  /**
   * Constructs a {@link ModuleNode}. <i>Subclasses must not use this constructor</i>. Instead, they
   * must use the {@link #ModuleNode(int,String,int,String,List,List,List,List,List)} version.
   *
   * @param name the fully qualified name (using dots) of the module.
   * @param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code
   *     ACC_MANDATED}.
   * @param version the module version, or {@literal null}.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public ModuleNode(final String name, final int access, final String version) {
    super(/* latest api = */ Opcodes.ASM9);
    if (getClass() != ModuleNode.class) {
      throw new IllegalStateException();
    }
    this.name = name;
    this.access = access;
    this.version = version;
  }

  // TODO(forax): why is there no 'mainClass' and 'packages' parameters in this constructor?
  /**
   * Constructs a {@link ModuleNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of {@link
   *     Opcodes#ASM6}, {@link Opcodes#ASM7}, {@link Opcodes#ASM8} or {@link Opcodes#ASM9}.
   * @param name the fully qualified name (using dots) of the module.
   * @param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code
   *     ACC_MANDATED}.
   * @param version the module version, or {@literal null}.
   * @param requires The dependencies of this module. May be {@literal null}.
   * @param exports The packages exported by this module. May be {@literal null}.
   * @param opens The packages opened by this module. May be {@literal null}.
   * @param uses The internal names of the services used by this module (see {@link
   *     org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   * @param provides The services provided by this module. May be {@literal null}.
   */
  public ModuleNode(
      final int api,
      final String name,
      final int access,
      final String version,
      final List<ModuleRequireNode> requires,
      final List<ModuleExportNode> exports,
      final List<ModuleOpenNode> opens,
      final List<@InternalForm String> uses,
      final List<ModuleProvideNode> provides) {
    super(api);
    this.name = name;
    this.access = access;
    this.version = version;
    this.requires = requires;
    this.exports = exports;
    this.opens = opens;
    this.uses = uses;
    this.provides = provides;
  }

  @Override
  public void visitMainClass(final String mainClass) {
    this.mainClass = mainClass;
  }

  @Override
  public void visitPackage(final String packaze) {
    if (packages == null) {
      packages = new ArrayList<>(5);
    }
    packages.add(packaze);
  }

  @Override
  public void visitRequire(final String module, final int access, final String version) {
    if (requires == null) {
      requires = new ArrayList<>(5);
    }
    requires.add(new ModuleRequireNode(module, access, version));
  }

  @Override
  public void visitExport(final String packaze, final int access, final String... modules) {
    if (exports == null) {
      exports = new ArrayList<>(5);
    }
    exports.add(new ModuleExportNode(packaze, access, Util.asArrayList(modules)));
  }

  @Override
  public void visitOpen(final String packaze, final int access, final String... modules) {
    if (opens == null) {
      opens = new ArrayList<>(5);
    }
    opens.add(new ModuleOpenNode(packaze, access, Util.asArrayList(modules)));
  }

  @Override
  public void visitUse(final String service) {
    if (uses == null) {
      uses = new ArrayList<>(5);
    }
    uses.add(service);
  }

  @Override
  public void visitProvide(final String service, final String... providers) {
    if (provides == null) {
      provides = new ArrayList<>(5);
    }
    provides.add(new ModuleProvideNode(service, Util.asArrayList(providers)));
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  /**
   * Makes the given class visitor visit this module.
   *
   * @param classVisitor a class visitor.
   */
  public void accept(final ClassVisitor classVisitor) {
    ModuleVisitor moduleVisitor = classVisitor.visitModule(name, access, version);
    if (moduleVisitor == null) {
      return;
    }
    if (mainClass != null) {
      moduleVisitor.visitMainClass(mainClass);
    }
    if (packages != null) {
      for (int i = 0, n = packages.size(); i < n; i++) {
        moduleVisitor.visitPackage(packages.get(i));
      }
    }
    if (requires != null) {
      for (int i = 0, n = requires.size(); i < n; i++) {
        requires.get(i).accept(moduleVisitor);
      }
    }
    if (exports != null) {
      for (int i = 0, n = exports.size(); i < n; i++) {
        exports.get(i).accept(moduleVisitor);
      }
    }
    if (opens != null) {
      for (int i = 0, n = opens.size(); i < n; i++) {
        opens.get(i).accept(moduleVisitor);
      }
    }
    if (uses != null) {
      for (int i = 0, n = uses.size(); i < n; i++) {
        moduleVisitor.visitUse(uses.get(i));
      }
    }
    if (provides != null) {
      for (int i = 0, n = provides.size(); i < n; i++) {
        provides.get(i).accept(moduleVisitor);
      }
    }
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents a MULTIANEWARRAY instruction.
 *
 * @author Eric Bruneton
 */
public class MultiANewArrayInsnNode extends AbstractInsnNode {

  /** An array type descriptor (see {@link org.objectweb.asm.Type}). */
  public String desc;

  /** Number of dimensions of the array to allocate. */
  public int dims;

  /**
   * Constructs a new {@link MultiANewArrayInsnNode}.
   *
   * @param descriptor an array type descriptor (see {@link org.objectweb.asm.Type}).
   * @param numDimensions the number of dimensions of the array to allocate.
   */
  public MultiANewArrayInsnNode(final String descriptor, final int numDimensions) {
    super(Opcodes.MULTIANEWARRAY);
    this.desc = descriptor;
    this.dims = numDimensions;
  }

  @Override
  public int getType() {
    return MULTIANEWARRAY_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitMultiANewArrayInsn(desc, dims);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new MultiANewArrayInsnNode(desc, dims).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.List;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;

/**
 * A node that represents a field.
 *
 * @author Eric Bruneton
 */
public class FieldNode extends FieldVisitor {

  /**
   * The field's access flags (see {@link org.objectweb.asm.Opcodes}). This field also indicates if
   * the field is synthetic and/or deprecated.
   */
  public int access;

  /** The field's name. */
  public String name;

  /** The field's descriptor (see {@link org.objectweb.asm.Type}). */
  public String desc;

  /** The field's signature. May be {@literal null}. */
  public String signature;

  /**
   * The field's initial value. This field, which may be {@literal null} if the field does not have
   * an initial value, must be an {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double}
   * or a {@link String}.
   */
  public Object value;

  /** The runtime visible annotations of this field. May be {@literal null}. */
  public List<AnnotationNode> visibleAnnotations;

  /** The runtime invisible annotations of this field. May be {@literal null}. */
  public List<AnnotationNode> invisibleAnnotations;

  /** The runtime visible type annotations of this field. May be {@literal null}. */
  public List<TypeAnnotationNode> visibleTypeAnnotations;

  /** The runtime invisible type annotations of this field. May be {@literal null}. */
  public List<TypeAnnotationNode> invisibleTypeAnnotations;

  /** The non standard attributes of this field. * May be {@literal null}. */
  public List<Attribute> attrs;

  /**
   * Constructs a new {@link FieldNode}. <i>Subclasses must not use this constructor</i>. Instead,
   * they must use the {@link #FieldNode(int, int, String, String, String, Object)} version.
   *
   * @param access the field's access flags (see {@link org.objectweb.asm.Opcodes}). This parameter
   *     also indicates if the field is synthetic and/or deprecated.
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link org.objectweb.asm.Type}).
   * @param signature the field's signature.
   * @param value the field's initial value. This parameter, which may be {@literal null} if the
   *     field does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link
   *     Long}, a {@link Double} or a {@link String}.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public FieldNode(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    this(/* latest api = */ Opcodes.ASM9, access, name, descriptor, signature, value);
    if (getClass() != FieldNode.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link FieldNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param access the field's access flags (see {@link org.objectweb.asm.Opcodes}). This parameter
   *     also indicates if the field is synthetic and/or deprecated.
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link org.objectweb.asm.Type}).
   * @param signature the field's signature.
   * @param value the field's initial value. This parameter, which may be {@literal null} if the
   *     field does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link
   *     Long}, a {@link Double} or a {@link String}.
   */
  public FieldNode(
      final int api,
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    super(api);
    this.access = access;
    this.name = name;
    this.desc = descriptor;
    this.signature = signature;
    this.value = value;
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the FieldVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    AnnotationNode annotation = new AnnotationNode(descriptor);
    if (visible) {
      visibleAnnotations = Util.add(visibleAnnotations, annotation);
    } else {
      invisibleAnnotations = Util.add(invisibleAnnotations, annotation);
    }
    return annotation;
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    TypeAnnotationNode typeAnnotation = new TypeAnnotationNode(typeRef, typePath, descriptor);
    if (visible) {
      visibleTypeAnnotations = Util.add(visibleTypeAnnotations, typeAnnotation);
    } else {
      invisibleTypeAnnotations = Util.add(invisibleTypeAnnotations, typeAnnotation);
    }
    return typeAnnotation;
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    attrs = Util.add(attrs, attribute);
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Accept methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Checks that this field node is compatible with the given ASM API version. This method checks
   * that this node, and all its children recursively, do not contain elements that were introduced
   * in more recent versions of the ASM API than the given version.
   *
   * @param api an ASM API version. Must be one of the {@code ASM}<i>x</i> values in {@link
   *     Opcodes}.
   */
  public void check(final int api) {
    if (api == Opcodes.ASM4) {
      if (visibleTypeAnnotations != null && !visibleTypeAnnotations.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
      if (invisibleTypeAnnotations != null && !invisibleTypeAnnotations.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
    }
  }

  /**
   * Makes the given class visitor visit this field.
   *
   * @param classVisitor a class visitor.
   */
  public void accept(final ClassVisitor classVisitor) {
    FieldVisitor fieldVisitor = classVisitor.visitField(access, name, desc, signature, value);
    if (fieldVisitor == null) {
      return;
    }
    // Visit the annotations.
    if (visibleAnnotations != null) {
      for (int i = 0, n = visibleAnnotations.size(); i < n; ++i) {
        AnnotationNode annotation = visibleAnnotations.get(i);
        annotation.accept(fieldVisitor.visitAnnotation(annotation.desc, true));
      }
    }
    if (invisibleAnnotations != null) {
      for (int i = 0, n = invisibleAnnotations.size(); i < n; ++i) {
        AnnotationNode annotation = invisibleAnnotations.get(i);
        annotation.accept(fieldVisitor.visitAnnotation(annotation.desc, false));
      }
    }
    if (visibleTypeAnnotations != null) {
      for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = visibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            fieldVisitor.visitTypeAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, true));
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            fieldVisitor.visitTypeAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
      }
    }
    // Visit the non standard attributes.
    if (attrs != null) {
      for (int i = 0, n = attrs.size(); i < n; ++i) {
        fieldVisitor.visitAttribute(attrs.get(i));
      }
    }
    fieldVisitor.visitEnd();
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * A node that represents an LDC instruction.
 *
 * @author Eric Bruneton
 */
public class LdcInsnNode extends AbstractInsnNode {

  /**
   * The constant to be loaded on the stack. This field must be a non null {@link Integer}, a {@link
   * Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link Type} of OBJECT or ARRAY
   * sort for {@code .class} constants, for classes whose version is 49, a {@link Type} of METHOD
   * sort for MethodType, a {@link Handle} for MethodHandle constants, for classes whose version is
   * 51 or a {@link ConstantDynamic} for a constant dynamic for classes whose version is 55.
   */
  public Object cst;

  /**
   * Constructs a new {@link LdcInsnNode}.
   *
   * @param value the constant to be loaded on the stack. This parameter mist be a non null {@link
   *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link
   *     Type} of OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is
   *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle
   *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant
   *     dynamic for classes whose version is 55.
   */
  public LdcInsnNode(final Object value) {
    super(Opcodes.LDC);
    this.cst = value;
  }

  @Override
  public int getType() {
    return LDC_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitLdcInsn(cst);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new LdcInsnNode(cst).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents a method instruction. A method instruction is an instruction that invokes
 * a method.
 *
 * @author Eric Bruneton
 */
public class MethodInsnNode extends AbstractInsnNode {

  /**
   * The internal name of the method's owner class (see {@link
   * org.objectweb.asm.Type#getInternalName()}).
   *
   * <p>For methods of arrays, e.g., {@code clone()}, the array type descriptor.
   */
  public @InternalForm String owner;

  /** The method's name. */
  public String name;

  /** The method's descriptor (see {@link org.objectweb.asm.Type}). */
  public String desc;

  /** Whether the method's owner class if an interface. */
  public boolean itf;

  /**
   * Constructs a new {@link MethodInsnNode}.
   *
   * @param opcode the opcode of the type instruction to be constructed. This opcode must be
   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *     org.objectweb.asm.Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link org.objectweb.asm.Type}).
   */
  public MethodInsnNode(
      final int opcode, final @InternalForm String owner, final String name, final String descriptor) {
    this(opcode, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);
  }

  /**
   * Constructs a new {@link MethodInsnNode}.
   *
   * @param opcode the opcode of the type instruction to be constructed. This opcode must be
   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *     org.objectweb.asm.Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link org.objectweb.asm.Type}).
   * @param isInterface if the method's owner class is an interface.
   */
  public MethodInsnNode(
      final int opcode,
      final @InternalForm String owner,
      final String name,
      final String descriptor,
      final boolean isInterface) {
    super(opcode);
    this.owner = owner;
    this.name = name;
    this.desc = descriptor;
    this.itf = isInterface;
  }

  /**
   * Sets the opcode of this instruction.
   *
   * @param opcode the new instruction opcode. This opcode must be INVOKEVIRTUAL, INVOKESPECIAL,
   *     INVOKESTATIC or INVOKEINTERFACE.
   */
  public void setOpcode(final int opcode) {
    this.opcode = opcode;
  }

  @Override
  public int getType() {
    return METHOD_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitMethodInsn(opcode, owner, name, desc, itf);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new MethodInsnNode(opcode, owner, name, desc, itf).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.ArrayList;
import java.util.List;

/**
 * Utility methods to convert an array of primitive or object values to a mutable ArrayList, not
 * baked by the array (unlike {@link java.util.Arrays#asList}).
 *
 * @author Eric Bruneton
 */
final class Util {

  private Util() {}

  static <T> List<T> add(final List<T> list, final T element) {
    List<T> newList = list == null ? new ArrayList<>(1) : list;
    newList.add(element);
    return newList;
  }

  static <T> List<T> asArrayList(final int length) {
    List<T> list = new ArrayList<>(length);
    for (int i = 0; i < length; ++i) {
      list.add(null);
    }
    return list;
  }

  static <T> List<T> asArrayList(final T[] array) {
    if (array == null) {
      return new ArrayList<>();
    }
    ArrayList<T> list = new ArrayList<>(array.length);
    for (T t : array) {
      list.add(t); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return list;
  }

  static List<Byte> asArrayList(final byte[] byteArray) {
    if (byteArray == null) {
      return new ArrayList<>();
    }
    ArrayList<Byte> byteList = new ArrayList<>(byteArray.length);
    for (byte b : byteArray) {
      byteList.add(b); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return byteList;
  }

  static List<Boolean> asArrayList(final boolean[] booleanArray) {
    if (booleanArray == null) {
      return new ArrayList<>();
    }
    ArrayList<Boolean> booleanList = new ArrayList<>(booleanArray.length);
    for (boolean b : booleanArray) {
      booleanList.add(b); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return booleanList;
  }

  static List<Short> asArrayList(final short[] shortArray) {
    if (shortArray == null) {
      return new ArrayList<>();
    }
    ArrayList<Short> shortList = new ArrayList<>(shortArray.length);
    for (short s : shortArray) {
      shortList.add(s); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return shortList;
  }

  static List<Character> asArrayList(final char[] charArray) {
    if (charArray == null) {
      return new ArrayList<>();
    }
    ArrayList<Character> charList = new ArrayList<>(charArray.length);
    for (char c : charArray) {
      charList.add(c); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return charList;
  }

  static List<Integer> asArrayList(final int[] intArray) {
    if (intArray == null) {
      return new ArrayList<>();
    }
    ArrayList<Integer> intList = new ArrayList<>(intArray.length);
    for (int i : intArray) {
      intList.add(i); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return intList;
  }

  static List<Float> asArrayList(final float[] floatArray) {
    if (floatArray == null) {
      return new ArrayList<>();
    }
    ArrayList<Float> floatList = new ArrayList<>(floatArray.length);
    for (float f : floatArray) {
      floatList.add(f); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return floatList;
  }

  static List<Long> asArrayList(final long[] longArray) {
    if (longArray == null) {
      return new ArrayList<>();
    }
    ArrayList<Long> longList = new ArrayList<>(longArray.length);
    for (long l : longArray) {
      longList.add(l); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return longList;
  }

  static List<Double> asArrayList(final double[] doubleArray) {
    if (doubleArray == null) {
      return new ArrayList<>();
    }
    ArrayList<Double> doubleList = new ArrayList<>(doubleArray.length);
    for (double d : doubleArray) {
      doubleList.add(d); // NOPMD(UseArraysAsList): we want a modifiable list.
    }
    return doubleList;
  }

  static <T> List<T> asArrayList(final int length, final T[] array) {
    List<T> list = new ArrayList<>(length);
    for (int i = 0; i < length; ++i) {
      list.add(array[i]); // NOPMD(UseArraysAsList): we convert a part of the array.
    }
    return list;
  }
}

package org.objectweb.asm.tree;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.TypePath;

/**
 * A node that represents a method.
 *
 * @author Eric Bruneton
 */
public class MethodNode extends MethodVisitor {

  /**
   * The method's access flags (see {@link Opcodes}). This field also indicates if the method is
   * synthetic and/or deprecated.
   */
  public int access;

  /** The method's name. */
  public String name;

  /** The method's descriptor (see {@link Type}). */
  public String desc;

  /** The method's signature. May be {@literal null}. */
  public String signature;

  /** The internal names of the method's exception classes (see {@link Type#getInternalName()}). */
  public List<@InternalForm String> exceptions;

  /** The method parameter info (access flags and name). */
  public List<ParameterNode> parameters;

  /** The runtime visible annotations of this method. May be {@literal null}. */
  public List<AnnotationNode> visibleAnnotations;

  /** The runtime invisible annotations of this method. May be {@literal null}. */
  public List<AnnotationNode> invisibleAnnotations;

  /** The runtime visible type annotations of this method. May be {@literal null}. */
  public List<TypeAnnotationNode> visibleTypeAnnotations;

  /** The runtime invisible type annotations of this method. May be {@literal null}. */
  public List<TypeAnnotationNode> invisibleTypeAnnotations;

  /** The non standard attributes of this method. May be {@literal null}. */
  public List<Attribute> attrs;

  /**
   * The default value of this annotation interface method. This field must be a {@link Byte},
   * {@link Boolean}, {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link
   * Float}, {@link Double}, {@link String} or {@link Type}, or an two elements String array (for
   * enumeration values), a {@link AnnotationNode}, or a {@link List} of values of one of the
   * preceding types. May be {@literal null}.
   */
  public Object annotationDefault;

  /**
   * The number of method parameters than can have runtime visible annotations. This number must be
   * less or equal than the number of parameter types in the method descriptor (the default value 0
   * indicates that all the parameters described in the method descriptor can have annotations). It
   * can be strictly less when a method has synthetic parameters and when these parameters are
   * ignored when computing parameter indices for the purpose of parameter annotations (see
   * https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
   */
  public int visibleAnnotableParameterCount;

  /**
   * The runtime visible parameter annotations of this method. These lists are lists of {@link
   * AnnotationNode} objects. May be {@literal null}.
   */
  public List<AnnotationNode>[] visibleParameterAnnotations;

  /**
   * The number of method parameters than can have runtime invisible annotations. This number must
   * be less or equal than the number of parameter types in the method descriptor (the default value
   * 0 indicates that all the parameters described in the method descriptor can have annotations).
   * It can be strictly less when a method has synthetic parameters and when these parameters are
   * ignored when computing parameter indices for the purpose of parameter annotations (see
   * https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
   */
  public int invisibleAnnotableParameterCount;

  /**
   * The runtime invisible parameter annotations of this method. These lists are lists of {@link
   * AnnotationNode} objects. May be {@literal null}.
   */
  public List<AnnotationNode>[] invisibleParameterAnnotations;

  /** The instructions of this method. */
  public InsnList instructions;

  /** The try catch blocks of this method. */
  public List<TryCatchBlockNode> tryCatchBlocks;

  /** The maximum stack size of this method. */
  public int maxStack;

  /** The maximum number of local variables of this method. */
  public int maxLocals;

  /** The local variables of this method. May be {@literal null} */
  public List<LocalVariableNode> localVariables;

  /** The visible local variable annotations of this method. May be {@literal null} */
  public List<LocalVariableAnnotationNode> visibleLocalVariableAnnotations;

  /** The invisible local variable annotations of this method. May be {@literal null} */
  public List<LocalVariableAnnotationNode> invisibleLocalVariableAnnotations;

  /** Whether the accept method has been called on this object. */
  private boolean visited;

  /**
   * Constructs an uninitialized {@link MethodNode}. <i>Subclasses must not use this
   * constructor</i>. Instead, they must use the {@link #MethodNode(int)} version.
   *
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public MethodNode() {
    this(/* latest api = */ Opcodes.ASM9);
    if (getClass() != MethodNode.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs an uninitialized {@link MethodNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  public MethodNode(final int api) {
    super(api);
    this.instructions = new InsnList();
  }

  /**
   * Constructs a new {@link MethodNode}. <i>Subclasses must not use this constructor</i>. Instead,
   * they must use the {@link #MethodNode(int, int, String, String, String, String[])} version.
   *
   * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the method is synthetic and/or deprecated.
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param signature the method's signature. May be {@literal null}.
   * @param exceptions the internal names of the method's exception classes (see {@link
   *     Type#getInternalName()}). May be {@literal null}.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public MethodNode(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String @Nullable [] exceptions) {
    this(/* latest api = */ Opcodes.ASM9, access, name, descriptor, signature, exceptions);
    if (getClass() != MethodNode.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link MethodNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the method is synthetic and/or deprecated.
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param signature the method's signature. May be {@literal null}.
   * @param exceptions the internal names of the method's exception classes (see {@link
   *     Type#getInternalName()}). May be {@literal null}.
   */
  public MethodNode(
      final int api,
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String @Nullable [] exceptions) {
    super(api);
    this.access = access;
    this.name = name;
    this.desc = descriptor;
    this.signature = signature;
    this.exceptions = Util.asArrayList(exceptions);
    if ((access & Opcodes.ACC_ABSTRACT) == 0) {
      this.localVariables = new ArrayList<>(5);
    }
    this.tryCatchBlocks = new ArrayList<>();
    this.instructions = new InsnList();
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the MethodVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visitParameter(final String name, final int access) {
    if (parameters == null) {
      parameters = new ArrayList<>(5);
    }
    parameters.add(new ParameterNode(name, access));
  }

  @Override
  @SuppressWarnings("serial")
  public AnnotationVisitor visitAnnotationDefault() {
    return new AnnotationNode(
        new ArrayList<Object>(0) {
          @Override
          public boolean add(final Object o) {
            annotationDefault = o;
            return super.add(o);
          }
        });
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    AnnotationNode annotation = new AnnotationNode(descriptor);
    if (visible) {
      visibleAnnotations = Util.add(visibleAnnotations, annotation);
    } else {
      invisibleAnnotations = Util.add(invisibleAnnotations, annotation);
    }
    return annotation;
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    TypeAnnotationNode typeAnnotation = new TypeAnnotationNode(typeRef, typePath, descriptor);
    if (visible) {
      visibleTypeAnnotations = Util.add(visibleTypeAnnotations, typeAnnotation);
    } else {
      invisibleTypeAnnotations = Util.add(invisibleTypeAnnotations, typeAnnotation);
    }
    return typeAnnotation;
  }

  @Override
  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    if (visible) {
      visibleAnnotableParameterCount = parameterCount;
    } else {
      invisibleAnnotableParameterCount = parameterCount;
    }
  }

  @Override
  @SuppressWarnings("unchecked")
  public AnnotationVisitor visitParameterAnnotation(
      final int parameter, final String descriptor, final boolean visible) {
    AnnotationNode annotation = new AnnotationNode(descriptor);
    if (visible) {
      if (visibleParameterAnnotations == null) {
        int params = Type.getArgumentCount(desc);
        visibleParameterAnnotations = (List<AnnotationNode>[]) new List<?>[params];
      }
      visibleParameterAnnotations[parameter] =
          Util.add(visibleParameterAnnotations[parameter], annotation);
    } else {
      if (invisibleParameterAnnotations == null) {
        int params = Type.getArgumentCount(desc);
        invisibleParameterAnnotations = (List<AnnotationNode>[]) new List<?>[params];
      }
      invisibleParameterAnnotations[parameter] =
          Util.add(invisibleParameterAnnotations[parameter], annotation);
    }
    return annotation;
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    attrs = Util.add(attrs, attribute);
  }

  @Override
  public void visitCode() {
    // Nothing to do.
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    instructions.add(
        new FrameNode(
            type,
            numLocal,
            local == null ? null : getLabelNodes(local),
            numStack,
            stack == null ? null : getLabelNodes(stack)));
  }

  @Override
  public void visitInsn(final int opcode) {
    instructions.add(new InsnNode(opcode));
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    instructions.add(new IntInsnNode(opcode, operand));
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    instructions.add(new VarInsnNode(opcode, varIndex));
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    instructions.add(new TypeInsnNode(opcode, type));
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    instructions.add(new FieldInsnNode(opcode, owner, name, descriptor));
  }

  @Override
  public void visitMethodInsn(
      final int opcodeAndSource,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
      // Redirect the call to the deprecated version of this method.
      super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
      return;
    }
    int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;

    instructions.add(new MethodInsnNode(opcode, owner, name, descriptor, isInterface));
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    instructions.add(
        new InvokeDynamicInsnNode(
            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments));
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    instructions.add(new JumpInsnNode(opcode, getLabelNode(label)));
  }

  @Override
  public void visitLabel(final Label label) {
    instructions.add(getLabelNode(label));
  }

  @Override
  public void visitLdcInsn(final Object value) {
    instructions.add(new LdcInsnNode(value));
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    instructions.add(new IincInsnNode(varIndex, increment));
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    instructions.add(new TableSwitchInsnNode(min, max, getLabelNode(dflt), getLabelNodes(labels)));
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    instructions.add(new LookupSwitchInsnNode(getLabelNode(dflt), keys, getLabelNodes(labels)));
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    instructions.add(new MultiANewArrayInsnNode(descriptor, numDimensions));
  }

  @Override
  public AnnotationVisitor visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    // Find the last real instruction, i.e. the instruction targeted by this annotation.
    AbstractInsnNode currentInsn = instructions.getLast();
    while (currentInsn.getOpcode() == -1) {
      currentInsn = currentInsn.getPrevious();
    }
    // Add the annotation to this instruction.
    TypeAnnotationNode typeAnnotation = new TypeAnnotationNode(typeRef, typePath, descriptor);
    if (visible) {
      currentInsn.visibleTypeAnnotations =
          Util.add(currentInsn.visibleTypeAnnotations, typeAnnotation);
    } else {
      currentInsn.invisibleTypeAnnotations =
          Util.add(currentInsn.invisibleTypeAnnotations, typeAnnotation);
    }
    return typeAnnotation;
  }

  @Override
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @InternalForm String type) {
    TryCatchBlockNode tryCatchBlock =
        new TryCatchBlockNode(getLabelNode(start), getLabelNode(end), getLabelNode(handler), type);
    tryCatchBlocks = Util.add(tryCatchBlocks, tryCatchBlock);
  }

  @Override
  public AnnotationVisitor visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    TryCatchBlockNode tryCatchBlock = tryCatchBlocks.get((typeRef & 0x00FFFF00) >> 8);
    TypeAnnotationNode typeAnnotation = new TypeAnnotationNode(typeRef, typePath, descriptor);
    if (visible) {
      tryCatchBlock.visibleTypeAnnotations =
          Util.add(tryCatchBlock.visibleTypeAnnotations, typeAnnotation);
    } else {
      tryCatchBlock.invisibleTypeAnnotations =
          Util.add(tryCatchBlock.invisibleTypeAnnotations, typeAnnotation);
    }
    return typeAnnotation;
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    LocalVariableNode localVariable =
        new LocalVariableNode(
            name, descriptor, signature, getLabelNode(start), getLabelNode(end), index);
    localVariables = Util.add(localVariables, localVariable);
  }

  @Override
  public AnnotationVisitor visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    LocalVariableAnnotationNode localVariableAnnotation =
        new LocalVariableAnnotationNode(
            typeRef, typePath, getLabelNodes(start), getLabelNodes(end), index, descriptor);
    if (visible) {
      visibleLocalVariableAnnotations =
          Util.add(visibleLocalVariableAnnotations, localVariableAnnotation);
    } else {
      invisibleLocalVariableAnnotations =
          Util.add(invisibleLocalVariableAnnotations, localVariableAnnotation);
    }
    return localVariableAnnotation;
  }

  @Override
  public void visitLineNumber(final int line, final Label start) {
    instructions.add(new LineNumberNode(line, getLabelNode(start)));
  }

  @Override
  public void visitMaxs(final int maxStack, final int maxLocals) {
    this.maxStack = maxStack;
    this.maxLocals = maxLocals;
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  /**
   * Returns the LabelNode corresponding to the given Label. Creates a new LabelNode if necessary.
   * The default implementation of this method uses the {@link Label#info} field to store
   * associations between labels and label nodes.
   *
   * @param label a Label.
   * @return the LabelNode corresponding to label.
   */
  protected LabelNode getLabelNode(final Label label) {
    if (!(label.info instanceof LabelNode)) {
      label.info = new LabelNode();
    }
    return (LabelNode) label.info;
  }

  private LabelNode[] getLabelNodes(final Label[] labels) {
    LabelNode[] labelNodes = new LabelNode[labels.length];
    for (int i = 0, n = labels.length; i < n; ++i) {
      labelNodes[i] = getLabelNode(labels[i]);
    }
    return labelNodes;
  }

  private Object[] getLabelNodes(final Object[] objects) {
    Object[] labelNodes = new Object[objects.length];
    for (int i = 0, n = objects.length; i < n; ++i) {
      Object o = objects[i];
      if (o instanceof Label) {
        o = getLabelNode((Label) o);
      }
      labelNodes[i] = o;
    }
    return labelNodes;
  }

  // -----------------------------------------------------------------------------------------------
  // Accept method
  // -----------------------------------------------------------------------------------------------

  /**
   * Checks that this method node is compatible with the given ASM API version. This method checks
   * that this node, and all its children recursively, do not contain elements that were introduced
   * in more recent versions of the ASM API than the given version.
   *
   * @param api an ASM API version. Must be one of the {@code ASM}<i>x</i> values in {@link
   *     Opcodes}.
   */
  public void check(final int api) {
    if (api == Opcodes.ASM4) {
      if (parameters != null && !parameters.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
      if (visibleTypeAnnotations != null && !visibleTypeAnnotations.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
      if (invisibleTypeAnnotations != null && !invisibleTypeAnnotations.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
      if (tryCatchBlocks != null) {
        for (int i = tryCatchBlocks.size() - 1; i >= 0; --i) {
          TryCatchBlockNode tryCatchBlock = tryCatchBlocks.get(i);
          if (tryCatchBlock.visibleTypeAnnotations != null
              && !tryCatchBlock.visibleTypeAnnotations.isEmpty()) {
            throw new UnsupportedClassVersionException();
          }
          if (tryCatchBlock.invisibleTypeAnnotations != null
              && !tryCatchBlock.invisibleTypeAnnotations.isEmpty()) {
            throw new UnsupportedClassVersionException();
          }
        }
      }
      for (int i = instructions.size() - 1; i >= 0; --i) {
        AbstractInsnNode insn = instructions.get(i);
        if (insn.visibleTypeAnnotations != null && !insn.visibleTypeAnnotations.isEmpty()) {
          throw new UnsupportedClassVersionException();
        }
        if (insn.invisibleTypeAnnotations != null && !insn.invisibleTypeAnnotations.isEmpty()) {
          throw new UnsupportedClassVersionException();
        }
        if (insn instanceof MethodInsnNode) {
          boolean isInterface = ((MethodInsnNode) insn).itf;
          if (isInterface != (insn.opcode == Opcodes.INVOKEINTERFACE)) {
            throw new UnsupportedClassVersionException();
          }
        } else if (insn instanceof LdcInsnNode) {
          Object value = ((LdcInsnNode) insn).cst;
          if (value instanceof Handle
              || (value instanceof Type && ((Type) value).getSort() == Type.METHOD)) {
            throw new UnsupportedClassVersionException();
          }
        }
      }
      if (visibleLocalVariableAnnotations != null && !visibleLocalVariableAnnotations.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
      if (invisibleLocalVariableAnnotations != null
          && !invisibleLocalVariableAnnotations.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
    }
    if (api < Opcodes.ASM7) {
      for (int i = instructions.size() - 1; i >= 0; --i) {
        AbstractInsnNode insn = instructions.get(i);
        if (insn instanceof LdcInsnNode) {
          Object value = ((LdcInsnNode) insn).cst;
          if (value instanceof ConstantDynamic) {
            throw new UnsupportedClassVersionException();
          }
        }
      }
    }
  }

  /**
   * Makes the given class visitor visit this method.
   *
   * @param classVisitor a class visitor.
   */
  public void accept(final ClassVisitor classVisitor) {
    String[] exceptionsArray = exceptions == null ? null : exceptions.toArray(new String[0]);
    MethodVisitor methodVisitor =
        classVisitor.visitMethod(access, name, desc, signature, exceptionsArray);
    if (methodVisitor != null) {
      accept(methodVisitor);
    }
  }

  /**
   * Makes the given method visitor visit this method.
   *
   * @param methodVisitor a method visitor.
   */
  public void accept(final MethodVisitor methodVisitor) {
    // Visit the parameters.
    if (parameters != null) {
      for (int i = 0, n = parameters.size(); i < n; i++) {
        parameters.get(i).accept(methodVisitor);
      }
    }
    // Visit the annotations.
    if (annotationDefault != null) {
      AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();
      AnnotationNode.accept(annotationVisitor, null, annotationDefault);
      if (annotationVisitor != null) {
        annotationVisitor.visitEnd();
      }
    }
    if (visibleAnnotations != null) {
      for (int i = 0, n = visibleAnnotations.size(); i < n; ++i) {
        AnnotationNode annotation = visibleAnnotations.get(i);
        annotation.accept(methodVisitor.visitAnnotation(annotation.desc, true));
      }
    }
    if (invisibleAnnotations != null) {
      for (int i = 0, n = invisibleAnnotations.size(); i < n; ++i) {
        AnnotationNode annotation = invisibleAnnotations.get(i);
        annotation.accept(methodVisitor.visitAnnotation(annotation.desc, false));
      }
    }
    if (visibleTypeAnnotations != null) {
      for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = visibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            methodVisitor.visitTypeAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, true));
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            methodVisitor.visitTypeAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
      }
    }
    if (visibleAnnotableParameterCount > 0) {
      methodVisitor.visitAnnotableParameterCount(visibleAnnotableParameterCount, true);
    }
    if (visibleParameterAnnotations != null) {
      for (int i = 0, n = visibleParameterAnnotations.length; i < n; ++i) {
        List<AnnotationNode> parameterAnnotations = visibleParameterAnnotations[i];
        if (parameterAnnotations == null) {
          continue;
        }
        for (int j = 0, m = parameterAnnotations.size(); j < m; ++j) {
          AnnotationNode annotation = parameterAnnotations.get(j);
          annotation.accept(methodVisitor.visitParameterAnnotation(i, annotation.desc, true));
        }
      }
    }
    if (invisibleAnnotableParameterCount > 0) {
      methodVisitor.visitAnnotableParameterCount(invisibleAnnotableParameterCount, false);
    }
    if (invisibleParameterAnnotations != null) {
      for (int i = 0, n = invisibleParameterAnnotations.length; i < n; ++i) {
        List<AnnotationNode> parameterAnnotations = invisibleParameterAnnotations[i];
        if (parameterAnnotations == null) {
          continue;
        }
        for (int j = 0, m = parameterAnnotations.size(); j < m; ++j) {
          AnnotationNode annotation = parameterAnnotations.get(j);
          annotation.accept(methodVisitor.visitParameterAnnotation(i, annotation.desc, false));
        }
      }
    }
    // Visit the non standard attributes.
    if (visited) {
      instructions.resetLabels();
    }
    if (attrs != null) {
      for (int i = 0, n = attrs.size(); i < n; ++i) {
        methodVisitor.visitAttribute(attrs.get(i));
      }
    }
    // Visit the code.
    if (instructions.size() > 0) {
      methodVisitor.visitCode();
      // Visits the try catch blocks.
      if (tryCatchBlocks != null) {
        for (int i = 0, n = tryCatchBlocks.size(); i < n; ++i) {
          tryCatchBlocks.get(i).updateIndex(i);
          tryCatchBlocks.get(i).accept(methodVisitor);
        }
      }
      // Visit the instructions.
      instructions.accept(methodVisitor);
      // Visits the local variables.
      if (localVariables != null) {
        for (int i = 0, n = localVariables.size(); i < n; ++i) {
          localVariables.get(i).accept(methodVisitor);
        }
      }
      // Visits the local variable annotations.
      if (visibleLocalVariableAnnotations != null) {
        for (int i = 0, n = visibleLocalVariableAnnotations.size(); i < n; ++i) {
          visibleLocalVariableAnnotations.get(i).accept(methodVisitor, true);
        }
      }
      if (invisibleLocalVariableAnnotations != null) {
        for (int i = 0, n = invisibleLocalVariableAnnotations.size(); i < n; ++i) {
          invisibleLocalVariableAnnotations.get(i).accept(methodVisitor, false);
        }
      }
      methodVisitor.visitMaxs(maxStack, maxLocals);
      visited = true;
    }
    methodVisitor.visitEnd();
  }
}

package org.objectweb.asm.tree;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;

/**
 * A node that represents a type annotation.
 *
 * @author Eric Bruneton
 */
public class TypeAnnotationNode extends AnnotationNode {

  /** A reference to the annotated type. See {@link org.objectweb.asm.TypeReference}. */
  public int typeRef;

  /**
   * The path to the annotated type argument, wildcard bound, array element type, or static outer
   * type within the referenced type. May be {@literal null} if the annotation targets 'typeRef' as
   * a whole.
   */
  public TypePath typePath;

  /**
   * Constructs a new {@link AnnotationNode}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #TypeAnnotationNode(int, int, TypePath, String)} version.
   *
   * @param typeRef a reference to the annotated type. See {@link org.objectweb.asm.TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public TypeAnnotationNode(final int typeRef, final TypePath typePath, final String descriptor) {
    this(/* latest api = */ Opcodes.ASM9, typeRef, typePath, descriptor);
    if (getClass() != TypeAnnotationNode.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link AnnotationNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param typeRef a reference to the annotated type. See {@link org.objectweb.asm.TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   */
  public TypeAnnotationNode(
      final int api, final int typeRef, final TypePath typePath, final String descriptor) {
    super(api, descriptor);
    this.typeRef = typeRef;
    this.typePath = typePath;
  }
}

package org.objectweb.asm.tree;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.TypePath;

/**
 * A node that represents a class.
 *
 * @author Eric Bruneton
 */
public class ClassNode extends ClassVisitor {

  /**
   * The class version. The minor version is stored in the 16 most significant bits, and the major
   * version in the 16 least significant bits.
   */
  public int version;

  /**
   * The class's access flags (see {@link org.objectweb.asm.Opcodes}). This field also indicates if
   * the class is deprecated {@link Opcodes#ACC_DEPRECATED} or a record {@link Opcodes#ACC_RECORD}.
   */
  public int access;

  /** The internal name of this class (see {@link org.objectweb.asm.Type#getInternalName()}). */
  public @InternalForm String name;

  /** The signature of this class. May be {@literal null}. */
  public String signature;

  /**
   * The internal of name of the super class (see {@link org.objectweb.asm.Type#getInternalName()}).
   * For interfaces, the super class is {@link Object}. May be {@literal null}, but only for the
   * {@link Object} class.
   */
  public @InternalForm String superName;

  /**
   * The internal names of the interfaces directly implemented by this class (see {@link
   * org.objectweb.asm.Type#getInternalName()}).
   */
  public List<@InternalForm String> interfaces;

  /** The name of the source file from which this class was compiled. May be {@literal null}. */
  public String sourceFile;

  /**
   * The correspondence between source and compiled elements of this class. May be {@literal null}.
   */
  public String sourceDebug;

  /** The module stored in this class. May be {@literal null}. */
  public ModuleNode module;

  /**
   * The internal name of the enclosing class of this class (see {@link
   * org.objectweb.asm.Type#getInternalName()}). Must be {@literal null} if this class is not a
   * local or anonymous class.
   */
  public @InternalForm String outerClass;

  /**
   * The name of the method that contains the class, or {@literal null} if the class has no
   * enclosing class, or is not enclosed in a method or constructor of its enclosing class (e.g. if
   * it is enclosed in an instance initializer, static initializer, instance variable initializer,
   * or class variable initializer).
   */
  public String outerMethod;

  /**
   * The descriptor of the method that contains the class, or {@literal null} if the class has no
   * enclosing class, or is not enclosed in a method or constructor of its enclosing class (e.g. if
   * it is enclosed in an instance initializer, static initializer, instance variable initializer,
   * or class variable initializer).
   */
  public String outerMethodDesc;

  /** The runtime visible annotations of this class. May be {@literal null}. */
  public List<AnnotationNode> visibleAnnotations;

  /** The runtime invisible annotations of this class. May be {@literal null}. */
  public List<AnnotationNode> invisibleAnnotations;

  /** The runtime visible type annotations of this class. May be {@literal null}. */
  public List<TypeAnnotationNode> visibleTypeAnnotations;

  /** The runtime invisible type annotations of this class. May be {@literal null}. */
  public List<TypeAnnotationNode> invisibleTypeAnnotations;

  /** The non standard attributes of this class. May be {@literal null}. */
  public List<Attribute> attrs;

  /** The inner classes of this class. */
  public List<InnerClassNode> innerClasses;

  /**
   * The internal name of the nest host class of this class (see {@link
   * org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  public @InternalForm String nestHostClass;

  /**
   * The internal names of the nest members of this class (see {@link
   * org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  public List<@InternalForm String> nestMembers;

  /**
   * The internal names of the permitted subclasses of this class (see {@link
   * org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.
   */
  public List<@InternalForm String> permittedSubclasses;

  /** The record components of this class. May be {@literal null}. */
  public List<RecordComponentNode> recordComponents;

  /** The fields of this class. */
  public List<FieldNode> fields;

  /** The methods of this class. */
  public List<MethodNode> methods;

  /**
   * Constructs a new {@link ClassNode}. <i>Subclasses must not use this constructor</i>. Instead,
   * they must use the {@link #ClassNode(int)} version.
   *
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public ClassNode() {
    this(Opcodes.ASM9);
    if (getClass() != ClassNode.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link ClassNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  public ClassNode(final int api) {
    super(api);
    this.interfaces = new ArrayList<>();
    this.innerClasses = new ArrayList<>();
    this.fields = new ArrayList<>();
    this.methods = new ArrayList<>();
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the ClassVisitor abstract class
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visit(
      final int version,
      final int access,
      final String name,
      final String signature,
      final String superName,
      final String[] interfaces) {
    this.version = version;
    this.access = access;
    this.name = name;
    this.signature = signature;
    this.superName = superName;
    this.interfaces = Util.asArrayList(interfaces);
  }

  @Override
  public void visitSource(final String file, final String debug) {
    sourceFile = file;
    sourceDebug = debug;
  }

  @Override
  public ModuleVisitor visitModule(final String name, final int access, final String version) {
    module = new ModuleNode(name, access, version);
    return module;
  }

  @Override
  public void visitNestHost(final String nestHost) {
    this.nestHostClass = nestHost;
  }

  @Override
  public void visitOuterClass(final @InternalForm String owner, final String name, final String descriptor) {
    outerClass = owner;
    outerMethod = name;
    outerMethodDesc = descriptor;
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    AnnotationNode annotation = new AnnotationNode(descriptor);
    if (visible) {
      visibleAnnotations = Util.add(visibleAnnotations, annotation);
    } else {
      invisibleAnnotations = Util.add(invisibleAnnotations, annotation);
    }
    return annotation;
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    TypeAnnotationNode typeAnnotation = new TypeAnnotationNode(typeRef, typePath, descriptor);
    if (visible) {
      visibleTypeAnnotations = Util.add(visibleTypeAnnotations, typeAnnotation);
    } else {
      invisibleTypeAnnotations = Util.add(invisibleTypeAnnotations, typeAnnotation);
    }
    return typeAnnotation;
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    attrs = Util.add(attrs, attribute);
  }

  @Override
  public void visitNestMember(final String nestMember) {
    nestMembers = Util.add(nestMembers, nestMember);
  }

  @Override
  public void visitPermittedSubclass(final String permittedSubclass) {
    permittedSubclasses = Util.add(permittedSubclasses, permittedSubclass);
  }

  @Override
  public void visitInnerClass(
      final @InternalForm String name, final @InternalForm String outerName, final @Identifier String innerName, final int access) {
    InnerClassNode innerClass = new InnerClassNode(name, outerName, innerName, access);
    innerClasses.add(innerClass);
  }

  @Override
  public RecordComponentVisitor visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    RecordComponentNode recordComponent = new RecordComponentNode(name, descriptor, signature);
    recordComponents = Util.add(recordComponents, recordComponent);
    return recordComponent;
  }

  @Override
  public FieldVisitor visitField(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    FieldNode field = new FieldNode(access, name, descriptor, signature, value);
    fields.add(field);
    return field;
  }

  @Override
  public MethodVisitor visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final String[] exceptions) {
    MethodNode method = new MethodNode(access, name, descriptor, signature, exceptions);
    methods.add(method);
    return method;
  }

  @Override
  public void visitEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Accept method
  // -----------------------------------------------------------------------------------------------

  /**
   * Checks that this class node is compatible with the given ASM API version. This method checks
   * that this node, and all its children recursively, do not contain elements that were introduced
   * in more recent versions of the ASM API than the given version.
   *
   * @param api an ASM API version. Must be one of the {@code ASM}<i>x</i> values in {@link
   *     Opcodes}.
   */
  public void check(final int api) {
    if (api < Opcodes.ASM9 && permittedSubclasses != null) {
      throw new UnsupportedClassVersionException();
    }
    if (api < Opcodes.ASM8 && ((access & Opcodes.ACC_RECORD) != 0 || recordComponents != null)) {
      throw new UnsupportedClassVersionException();
    }
    if (api < Opcodes.ASM7 && (nestHostClass != null || nestMembers != null)) {
      throw new UnsupportedClassVersionException();
    }
    if (api < Opcodes.ASM6 && module != null) {
      throw new UnsupportedClassVersionException();
    }
    if (api < Opcodes.ASM5) {
      if (visibleTypeAnnotations != null && !visibleTypeAnnotations.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
      if (invisibleTypeAnnotations != null && !invisibleTypeAnnotations.isEmpty()) {
        throw new UnsupportedClassVersionException();
      }
    }
    // Check the annotations.
    if (visibleAnnotations != null) {
      for (int i = visibleAnnotations.size() - 1; i >= 0; --i) {
        visibleAnnotations.get(i).check(api);
      }
    }
    if (invisibleAnnotations != null) {
      for (int i = invisibleAnnotations.size() - 1; i >= 0; --i) {
        invisibleAnnotations.get(i).check(api);
      }
    }
    if (visibleTypeAnnotations != null) {
      for (int i = visibleTypeAnnotations.size() - 1; i >= 0; --i) {
        visibleTypeAnnotations.get(i).check(api);
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = invisibleTypeAnnotations.size() - 1; i >= 0; --i) {
        invisibleTypeAnnotations.get(i).check(api);
      }
    }
    if (recordComponents != null) {
      for (int i = recordComponents.size() - 1; i >= 0; --i) {
        recordComponents.get(i).check(api);
      }
    }
    for (int i = fields.size() - 1; i >= 0; --i) {
      fields.get(i).check(api);
    }
    for (int i = methods.size() - 1; i >= 0; --i) {
      methods.get(i).check(api);
    }
  }

  /**
   * Makes the given class visitor visit this class.
   *
   * @param classVisitor a class visitor.
   */
  public void accept(final ClassVisitor classVisitor) {
    // Visit the header.
    String[] interfacesArray = new String[this.interfaces.size()];
    this.interfaces.toArray(interfacesArray);
    classVisitor.visit(version, access, name, signature, superName, interfacesArray);
    // Visit the source.
    if (sourceFile != null || sourceDebug != null) {
      classVisitor.visitSource(sourceFile, sourceDebug);
    }
    // Visit the module.
    if (module != null) {
      module.accept(classVisitor);
    }
    // Visit the nest host class.
    if (nestHostClass != null) {
      classVisitor.visitNestHost(nestHostClass);
    }
    // Visit the outer class.
    if (outerClass != null) {
      classVisitor.visitOuterClass(outerClass, outerMethod, outerMethodDesc);
    }
    // Visit the annotations.
    if (visibleAnnotations != null) {
      for (int i = 0, n = visibleAnnotations.size(); i < n; ++i) {
        AnnotationNode annotation = visibleAnnotations.get(i);
        annotation.accept(classVisitor.visitAnnotation(annotation.desc, true));
      }
    }
    if (invisibleAnnotations != null) {
      for (int i = 0, n = invisibleAnnotations.size(); i < n; ++i) {
        AnnotationNode annotation = invisibleAnnotations.get(i);
        annotation.accept(classVisitor.visitAnnotation(annotation.desc, false));
      }
    }
    if (visibleTypeAnnotations != null) {
      for (int i = 0, n = visibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = visibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            classVisitor.visitTypeAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, true));
      }
    }
    if (invisibleTypeAnnotations != null) {
      for (int i = 0, n = invisibleTypeAnnotations.size(); i < n; ++i) {
        TypeAnnotationNode typeAnnotation = invisibleTypeAnnotations.get(i);
        typeAnnotation.accept(
            classVisitor.visitTypeAnnotation(
                typeAnnotation.typeRef, typeAnnotation.typePath, typeAnnotation.desc, false));
      }
    }
    // Visit the non standard attributes.
    if (attrs != null) {
      for (int i = 0, n = attrs.size(); i < n; ++i) {
        classVisitor.visitAttribute(attrs.get(i));
      }
    }
    // Visit the nest members.
    if (nestMembers != null) {
      for (int i = 0, n = nestMembers.size(); i < n; ++i) {
        classVisitor.visitNestMember(nestMembers.get(i));
      }
    }
    // Visit the permitted subclasses.
    if (permittedSubclasses != null) {
      for (int i = 0, n = permittedSubclasses.size(); i < n; ++i) {
        classVisitor.visitPermittedSubclass(permittedSubclasses.get(i));
      }
    }
    // Visit the inner classes.
    for (int i = 0, n = innerClasses.size(); i < n; ++i) {
      innerClasses.get(i).accept(classVisitor);
    }
    // Visit the record components.
    if (recordComponents != null) {
      for (int i = 0, n = recordComponents.size(); i < n; ++i) {
        recordComponents.get(i).accept(classVisitor);
      }
    }
    // Visit the fields.
    for (int i = 0, n = fields.size(); i < n; ++i) {
      fields.get(i).accept(classVisitor);
    }
    // Visit the methods.
    for (int i = 0, n = methods.size(); i < n; ++i) {
      methods.get(i).accept(classVisitor);
    }
    classVisitor.visitEnd();
  }
}

package org.objectweb.asm.tree;

import java.util.List;
import org.objectweb.asm.ModuleVisitor;

/**
 * A node that represents an opened package with its name and the module that can access it.
 *
 * @author Remi Forax
 */
public class ModuleOpenNode {

  /**
   * The internal name of the opened package (see {@link org.objectweb.asm.Type#getInternalName()}).
   */
  public String packaze;

  /**
   * The access flag of the opened package, valid values are among {@code ACC_SYNTHETIC} and {@code
   * ACC_MANDATED}.
   */
  public int access;

  /**
   * The fully qualified names (using dots) of the modules that can use deep reflection to the
   * classes of the open package, or {@literal null}.
   */
  public List<String> modules;

  /**
   * Constructs a new {@link ModuleOpenNode}.
   *
   * @param packaze the internal name of the opened package (see {@link
   *     org.objectweb.asm.Type#getInternalName()}).
   * @param access the access flag of the opened package, valid values are among {@code
   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   * @param modules the fully qualified names (using dots) of the modules that can use deep
   *     reflection to the classes of the open package, or {@literal null}.
   */
  public ModuleOpenNode(final String packaze, final int access, final List<String> modules) {
    this.packaze = packaze;
    this.access = access;
    this.modules = modules;
  }

  /**
   * Makes the given module visitor visit this opened package.
   *
   * @param moduleVisitor a module visitor.
   */
  public void accept(final ModuleVisitor moduleVisitor) {
    moduleVisitor.visitOpen(
        packaze, access, modules == null ? null : modules.toArray(new String[0]));
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a line number declaration. These nodes are pseudo instruction nodes in
 * order to be inserted in an instruction list.
 *
 * @author Eric Bruneton
 */
public class LineNumberNode extends AbstractInsnNode {

  /** A line number. This number refers to the source file from which the class was compiled. */
  public int line;

  /** The first instruction corresponding to this line number. */
  public LabelNode start;

  /**
   * Constructs a new {@link LineNumberNode}.
   *
   * @param line a line number. This number refers to the source file from which the class was
   *     compiled.
   * @param start the first instruction corresponding to this line number.
   */
  public LineNumberNode(final int line, final LabelNode start) {
    super(-1);
    this.line = line;
    this.start = start;
  }

  @Override
  public int getType() {
    return LINE;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitLineNumber(line, start.getLabel());
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new LineNumberNode(line, clone(start, clonedLabels));
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a type instruction. A type instruction is an instruction which takes an
 * internal name as parameter (see {@link org.objectweb.asm.Type#getInternalName()}).
 *
 * @author Eric Bruneton
 */
public class TypeInsnNode extends AbstractInsnNode {

  /**
   * The operand of this instruction. Despite its name (due to historical reasons), this operand is
   * an internal name (see {@link org.objectweb.asm.Type#getInternalName()}).
   */
  public @InternalForm String desc;

  /**
   * Constructs a new {@link TypeInsnNode}.
   *
   * @param opcode the opcode of the type instruction to be constructed. This opcode must be NEW,
   *     ANEWARRAY, CHECKCAST or INSTANCEOF.
   * @param type the operand of the instruction to be constructed. This operand is an internal name
   *     (see {@link org.objectweb.asm.Type#getInternalName()}).
   */
  public TypeInsnNode(final int opcode, final @InternalForm String type) {
    super(opcode);
    this.desc = type;
  }

  /**
   * Sets the opcode of this instruction.
   *
   * @param opcode the new instruction opcode. This opcode must be NEW, ANEWARRAY, CHECKCAST or
   *     INSTANCEOF.
   */
  public void setOpcode(final int opcode) {
    this.opcode = opcode;
  }

  @Override
  public int getType() {
    return TYPE_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitTypeInsn(opcode, desc);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new TypeInsnNode(opcode, desc).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.List;
import java.util.Map;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents a TABLESWITCH instruction.
 *
 * @author Eric Bruneton
 */
public class TableSwitchInsnNode extends AbstractInsnNode {

  /** The minimum key value. */
  public int min;

  /** The maximum key value. */
  public int max;

  /** Beginning of the default handler block. */
  public LabelNode dflt;

  /** Beginnings of the handler blocks. This list is a list of {@link LabelNode} objects. */
  public List<LabelNode> labels;

  /**
   * Constructs a new {@link TableSwitchInsnNode}.
   *
   * @param min the minimum key value.
   * @param max the maximum key value.
   * @param dflt beginning of the default handler block.
   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the
   *     handler block for the {@code min + i} key.
   */
  public TableSwitchInsnNode(
      final int min, final int max, final LabelNode dflt, final LabelNode... labels) {
    super(Opcodes.TABLESWITCH);
    this.min = min;
    this.max = max;
    this.dflt = dflt;
    this.labels = Util.asArrayList(labels);
  }

  @Override
  public int getType() {
    return TABLESWITCH_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    Label[] labelsArray = new Label[this.labels.size()];
    for (int i = 0, n = labelsArray.length; i < n; ++i) {
      labelsArray[i] = this.labels.get(i).getLabel();
    }
    methodVisitor.visitTableSwitchInsn(min, max, dflt.getLabel(), labelsArray);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new TableSwitchInsnNode(min, max, clone(dflt, clonedLabels), clone(labels, clonedLabels))
        .cloneAnnotations(this);
  }
}


package org.objectweb.asm.tree;

import java.util.List;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;

/**
 * A node that represents a type annotation on a local or resource variable.
 *
 * @author Eric Bruneton
 */
public class LocalVariableAnnotationNode extends TypeAnnotationNode {

  /**
   * The fist instructions corresponding to the continuous ranges that make the scope of this local
   * variable (inclusive). Must not be {@literal null}.
   */
  public List<LabelNode> start;

  /**
   * The last instructions corresponding to the continuous ranges that make the scope of this local
   * variable (exclusive). This list must have the same size as the 'start' list. Must not be
   * {@literal null}.
   */
  public List<LabelNode> end;

  /**
   * The local variable's index in each range. This list must have the same size as the 'start'
   * list. Must not be {@literal null}.
   */
  public List<Integer> index;

  /**
   * Constructs a new {@link LocalVariableAnnotationNode}. <i>Subclasses must not use this
   * constructor</i>. Instead, they must use the {@link #LocalVariableAnnotationNode(int, TypePath,
   * LabelNode[], LabelNode[], int[], String)} version.
   *
   * @param typeRef a reference to the annotated type. See {@link org.objectweb.asm.TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param start the fist instructions corresponding to the continuous ranges that make the scope
   *     of this local variable (inclusive).
   * @param end the last instructions corresponding to the continuous ranges that make the scope of
   *     this local variable (exclusive). This array must have the same size as the 'start' array.
   * @param index the local variable's index in each range. This array must have the same size as
   *     the 'start' array.
   * @param descriptor the class descriptor of the annotation class.
   */
  public LocalVariableAnnotationNode(
      final int typeRef,
      final TypePath typePath,
      final LabelNode[] start,
      final LabelNode[] end,
      final int[] index,
      final String descriptor) {
    this(/* latest api = */ Opcodes.ASM9, typeRef, typePath, start, end, index, descriptor);
  }

  /**
   * Constructs a new {@link LocalVariableAnnotationNode}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param typeRef a reference to the annotated type. See {@link org.objectweb.asm.TypeReference}.
   * @param start the fist instructions corresponding to the continuous ranges that make the scope
   *     of this local variable (inclusive).
   * @param end the last instructions corresponding to the continuous ranges that make the scope of
   *     this local variable (exclusive). This array must have the same size as the 'start' array.
   * @param index the local variable's index in each range. This array must have the same size as
   *     the 'start' array.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   */
  public LocalVariableAnnotationNode(
      final int api,
      final int typeRef,
      final TypePath typePath,
      final LabelNode[] start,
      final LabelNode[] end,
      final int[] index,
      final String descriptor) {
    super(api, typeRef, typePath, descriptor);
    this.start = Util.asArrayList(start);
    this.end = Util.asArrayList(end);
    this.index = Util.asArrayList(index);
  }

  /**
   * Makes the given visitor visit this type annotation.
   *
   * @param methodVisitor the visitor that must visit this annotation.
   * @param visible {@literal true} if the annotation is visible at runtime.
   */
  public void accept(final MethodVisitor methodVisitor, final boolean visible) {
    Label[] startLabels = new Label[this.start.size()];
    Label[] endLabels = new Label[this.end.size()];
    int[] indices = new int[this.index.size()];
    for (int i = 0, n = startLabels.length; i < n; ++i) {
      startLabels[i] = this.start.get(i).getLabel();
      endLabels[i] = this.end.get(i).getLabel();
      indices[i] = this.index.get(i);
    }
    accept(
        methodVisitor.visitLocalVariableAnnotation(
            typeRef, typePath, startLabels, endLabels, indices, desc, visible));
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;

/**
 * A node that represents a jump instruction. A jump instruction is an instruction that may jump to
 * another instruction.
 *
 * @author Eric Bruneton
 */
public class JumpInsnNode extends AbstractInsnNode {

  /**
   * The operand of this instruction. This operand is a label that designates the instruction to
   * which this instruction may jump.
   */
  public LabelNode label;

  /**
   * Constructs a new {@link JumpInsnNode}.
   *
   * @param opcode the opcode of the type instruction to be constructed. This opcode must be IFEQ,
   *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,
   *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
   * @param label the operand of the instruction to be constructed. This operand is a label that
   *     designates the instruction to which the jump instruction may jump.
   */
  public JumpInsnNode(final int opcode, final LabelNode label) {
    super(opcode);
    this.label = label;
  }

  /**
   * Sets the opcode of this instruction.
   *
   * @param opcode the new instruction opcode. This opcode must be IFEQ, IFNE, IFLT, IFGE, IFGT,
   *     IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ,
   *     IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
   */
  public void setOpcode(final int opcode) {
    this.opcode = opcode;
  }

  @Override
  public int getType() {
    return JUMP_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitJumpInsn(opcode, label.getLabel());
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new JumpInsnNode(opcode, clone(label, clonedLabels)).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents an IINC instruction.
 *
 * @author Eric Bruneton
 */
public class IincInsnNode extends AbstractInsnNode {

  /** Index of the local variable to be incremented. */
  public int var;

  /** Amount to increment the local variable by. */
  public int incr;

  /**
   * Constructs a new {@link IincInsnNode}.
   *
   * @param varIndex index of the local variable to be incremented.
   * @param incr increment amount to increment the local variable by.
   */
  public IincInsnNode(final int varIndex, final int incr) {
    super(Opcodes.IINC);
    this.var = varIndex;
    this.incr = incr;
  }

  @Override
  public int getType() {
    return IINC_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitIincInsn(var, incr);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new IincInsnNode(var, incr).cloneAnnotations(this);
  }
}

package org.objectweb.asm.tree;

import java.util.Map;
import org.objectweb.asm.Handle;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A node that represents an invokedynamic instruction.
 *
 * @author Remi Forax
 */
public class InvokeDynamicInsnNode extends AbstractInsnNode {

  /** The method's name. */
  public String name;

  /** The method's descriptor (see {@link org.objectweb.asm.Type}). */
  public String desc;

  /** The bootstrap method. */
  public Handle bsm;

  /** The bootstrap method constant arguments. */
  public Object[] bsmArgs;

  /**
   * Constructs a new {@link InvokeDynamicInsnNode}.
   *
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link org.objectweb.asm.Type}).
   * @param bootstrapMethodHandle the bootstrap method.
   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be
   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link
   *     org.objectweb.asm.Type} or {@link Handle} value. This method is allowed to modify the
   *     content of the array so a caller should expect that this array may change.
   */
  public InvokeDynamicInsnNode(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    super(Opcodes.INVOKEDYNAMIC);
    this.name = name;
    this.desc = descriptor;
    this.bsm = bootstrapMethodHandle;
    this.bsmArgs = bootstrapMethodArguments; // NOPMD(ArrayIsStoredDirectly): public field.
  }

  @Override
  public int getType() {
    return INVOKE_DYNAMIC_INSN;
  }

  @Override
  public void accept(final MethodVisitor methodVisitor) {
    methodVisitor.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);
    acceptAnnotations(methodVisitor);
  }

  @Override
  public AbstractInsnNode clone(final Map<LabelNode, LabelNode> clonedLabels) {
    return new InvokeDynamicInsnNode(name, desc, bsm, bsmArgs).cloneAnnotations(this);
  }
}

package org.objectweb.asm.util;

import java.util.Collections;
import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FrameNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LookupSwitchInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.TryCatchBlockNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.Interpreter;
import org.objectweb.asm.tree.analysis.Value;

/**
 * An {@link Analyzer} subclass which checks that methods provide stack map frames where expected
 * (i.e. at jump target and after instructions without immediate successor), and that these stack
 * map frames are valid (for the provided interpreter; they may still be invalid for the JVM, if the
 * {@link Interpreter} uses a simplified type system compared to the JVM verifier). This is done in
 * two steps:
 *
 * <ul>
 *   <li>First, the stack map frames in {@link FrameNode}s are expanded, and stored at their
 *       respective instruction offsets. The expansion process uncompresses the APPEND, CHOP and
 *       SAME frames to FULL frames. It also converts the stack map frame verification types to
 *       {@link Value}s, via the provided {@link Interpreter}. The expansion is done in {@link
 *       #expandFrames}, by looking at each {@link FrameNode} in sequence (compressed frames are
 *       defined relatively to the previous {@link FrameNode}, or the implicit first frame). The
 *       actual decompression is done in {@link #expandFrame}, and the type conversion in {@link
 *       #newFrameValue}.
 *   <li>Next, the method instructions are checked in sequence. Starting from the implicit initial
 *       frame, the execution of each instruction <em>i</em> is simulated on the current stack map
 *       frame, with the {@link Frame#execute} method. This gives a new stack map frame <em>f</em>,
 *       representing the stack map frame state after the execution of <em>i</em>. Then:
 *       <ul>
 *         <li>If there is a next instruction and if the control flow cannot continue to it (e.g. if
 *             <em>i</em> is a RETURN or an ATHROW, for instance): an existing stack map frame
 *             <em>f0</em> (coming from the first step) is expected after <em>i</em>.
 *         <li>If there is a next instruction and if the control flow can continue to it (e.g. if
 *             <em>i</em> is a ALOAD, for instance): either there an existing stack map frame
 *             <em>f0</em> (coming from the first step) after <em>i</em>, or there is none. In the
 *             first case <em>f</em> and <em>f0</em> must be <em>compatible</em>: the types in
 *             <em>f</em> must be sub types of the corresponding types in the existing frame
 *             <em>f0</em> (otherwise an exception is thrown). In the second case, <em>f0</em> is
 *             simply set to the value of <em>f</em>.
 *         <li>If the control flow can continue to some instruction <em>j</em> (e.g. if <em>i</em>
 *             is an IF_EQ, for instance): an existing stack map frame <em>f0</em> (coming from the
 *             first step) is expected at <em>j</em>, which must be compatible with <em>f</em> (as
 *             defined previously).
 *       </ul>
 *       The sequential loop over the instructions is done in {@link #init}, which is called from
 *       the {@link Analyzer#analyze} method. Cases where the control flow cannot continue to the
 *       next instruction are handled in {@link #endControlFlow}. Cases where the control flow can
 *       continue to the next instruction, or jump to another instruction, are handled in {@link
 *       #checkFrame}. This method checks that an existing stack map frame is present when required,
 *       and checks the stack map frames compatibility with {@link #checkMerge}.
 * </ul>
 *
 * @author Eric Bruneton
 * @param <V> type of the {@link Value} used for the analysis.
 */
class CheckFrameAnalyzer<V extends Value> extends Analyzer<V> {

  /** The interpreter to use to symbolically interpret the bytecode instructions. */
  private final Interpreter<V> interpreter;

  /** The instructions of the currently analyzed method. */
  private InsnList insnList;

  /**
   * The number of locals in the last stack map frame processed by {@link expandFrame}. Long and
   * double values are represented with two elements.
   */
  private int currentLocals;

  CheckFrameAnalyzer(final Interpreter<V> interpreter) {
    super(interpreter);
    this.interpreter = interpreter;
  }

  @Override
  protected void init(final @InternalForm String owner, final MethodNode method) throws AnalyzerException {
    insnList = method.instructions;
    currentLocals = Type.getArgumentsAndReturnSizes(method.desc) >> 2;
    if ((method.access & Opcodes.ACC_STATIC) != 0) {
      currentLocals -= 1;
    }

    Frame<V>[] frames = getFrames();
    Frame<V> currentFrame = newFrame(frames[0]);
    expandFrames(owner, method, currentFrame);
    for (int insnIndex = 0; insnIndex < insnList.size(); ++insnIndex) {
      Frame<V> oldFrame = frames[insnIndex];

      // Simulate the execution of this instruction.
      AbstractInsnNode insnNode = null;
      try {
        insnNode = method.instructions.get(insnIndex);
        int insnOpcode = insnNode.getOpcode();
        int insnType = insnNode.getType();

        if (insnType == AbstractInsnNode.LABEL
            || insnType == AbstractInsnNode.LINE
            || insnType == AbstractInsnNode.FRAME) {
          checkFrame(insnIndex + 1, oldFrame, /* requireFrame= */ false);
        } else {
          currentFrame.init(oldFrame).execute(insnNode, interpreter);

          if (insnNode instanceof JumpInsnNode) {
            if (insnOpcode == JSR) {
              throw new AnalyzerException(insnNode, "JSR instructions are unsupported");
            }
            JumpInsnNode jumpInsn = (JumpInsnNode) insnNode;
            int targetInsnIndex = insnList.indexOf(jumpInsn.label);
            checkFrame(targetInsnIndex, currentFrame, /* requireFrame= */ true);
            if (insnOpcode == GOTO) {
              endControlFlow(insnIndex);
            } else {
              checkFrame(insnIndex + 1, currentFrame, /* requireFrame= */ false);
            }
          } else if (insnNode instanceof LookupSwitchInsnNode) {
            LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) insnNode;
            int targetInsnIndex = insnList.indexOf(lookupSwitchInsn.dflt);
            checkFrame(targetInsnIndex, currentFrame, /* requireFrame= */ true);
            for (int i = 0; i < lookupSwitchInsn.labels.size(); ++i) {
              LabelNode label = lookupSwitchInsn.labels.get(i);
              targetInsnIndex = insnList.indexOf(label);
              currentFrame.initJumpTarget(insnOpcode, label);
              checkFrame(targetInsnIndex, currentFrame, /* requireFrame= */ true);
            }
            endControlFlow(insnIndex);
          } else if (insnNode instanceof TableSwitchInsnNode) {
            TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) insnNode;
            int targetInsnIndex = insnList.indexOf(tableSwitchInsn.dflt);
            currentFrame.initJumpTarget(insnOpcode, tableSwitchInsn.dflt);
            checkFrame(targetInsnIndex, currentFrame, /* requireFrame= */ true);
            newControlFlowEdge(insnIndex, targetInsnIndex);
            for (int i = 0; i < tableSwitchInsn.labels.size(); ++i) {
              LabelNode label = tableSwitchInsn.labels.get(i);
              currentFrame.initJumpTarget(insnOpcode, label);
              targetInsnIndex = insnList.indexOf(label);
              checkFrame(targetInsnIndex, currentFrame, /* requireFrame= */ true);
            }
            endControlFlow(insnIndex);
          } else if (insnOpcode == RET) {
            throw new AnalyzerException(insnNode, "RET instructions are unsupported");
          } else if (insnOpcode != ATHROW && (insnOpcode < IRETURN || insnOpcode > RETURN)) {
            checkFrame(insnIndex + 1, currentFrame, /* requireFrame= */ false);
          } else {
            endControlFlow(insnIndex);
          }
        }

        List<TryCatchBlockNode> insnHandlers = getHandlers(insnIndex);
        if (insnHandlers != null) {
          for (TryCatchBlockNode tryCatchBlock : insnHandlers) {
            Type catchType;
            if (tryCatchBlock.type == null) {
              catchType = Type.getObjectType("java/lang/Throwable");
            } else {
              catchType = Type.getObjectType(tryCatchBlock.type);
            }
            Frame<V> handler = newFrame(oldFrame);
            handler.clearStack();
            handler.push(interpreter.newExceptionValue(tryCatchBlock, handler, catchType));
            checkFrame(insnList.indexOf(tryCatchBlock.handler), handler, /* requireFrame= */ true);
          }
        }

        if (!hasNextJvmInsnOrFrame(insnIndex)) {
          break;
        }
      } catch (AnalyzerException e) {
        throw new AnalyzerException(
            e.node, "Error at instruction " + insnIndex + ": " + e.getMessage(), e);
      } catch (RuntimeException e) {
        // DontCheck(IllegalCatch): can't be fixed, for backward compatibility.
        throw new AnalyzerException(
            insnNode, "Error at instruction " + insnIndex + ": " + e.getMessage(), e);
      }
    }
  }

  /**
   * Expands the {@link FrameNode} "instructions" of the given method into {@link Frame} objects and
   * stores them at the corresponding indices of the {@link #frames} array. The expanded frames are
   * also associated with the label and line number nodes immediately preceding each frame node.
   *
   * @param owner the internal name of the class to which 'method' belongs.
   * @param method the method whose frames must be expanded.
   * @param initialFrame the implicit initial frame of 'method'.
   * @throws AnalyzerException if the stack map frames of 'method', i.e. its FrameNode
   *     "instructions", are invalid.
   */
  private void expandFrames(
      final @InternalForm String owner, final MethodNode method, final Frame<V> initialFrame)
      throws AnalyzerException {
    int lastJvmOrFrameInsnIndex = -1;
    Frame<V> currentFrame = initialFrame;
    int currentInsnIndex = 0;
    for (AbstractInsnNode insnNode : method.instructions) {
      if (insnNode instanceof FrameNode) {
        try {
          currentFrame = expandFrame(owner, currentFrame, (FrameNode) insnNode);
        } catch (AnalyzerException e) {
          throw new AnalyzerException(
              e.node, "Error at instruction " + currentInsnIndex + ": " + e.getMessage(), e);
        }
        for (int index = lastJvmOrFrameInsnIndex + 1; index <= currentInsnIndex; ++index) {
          getFrames()[index] = currentFrame;
        }
      }
      if (isJvmInsnNode(insnNode) || insnNode instanceof FrameNode) {
        lastJvmOrFrameInsnIndex = currentInsnIndex;
      }
      currentInsnIndex += 1;
    }
  }

  /**
   * Returns the expanded representation of the given {@link FrameNode}.
   *
   * @param owner the internal name of the class to which 'frameNode' belongs.
   * @param previousFrame the frame before 'frameNode', in expanded form.
   * @param frameNode a possibly compressed stack map frame.
   * @return the expanded version of 'frameNode'.
   * @throws AnalyzerException if 'frameNode' is invalid.
   */
  private Frame<V> expandFrame(
      final @InternalForm String owner, final Frame<V> previousFrame, final FrameNode frameNode)
      throws AnalyzerException {
    Frame<V> frame = newFrame(previousFrame);
    List<Object> locals = frameNode.local == null ? Collections.emptyList() : frameNode.local;
    int currentLocal = currentLocals;
    switch (frameNode.type) {
      case Opcodes.F_NEW:
      case Opcodes.F_FULL:
        currentLocal = 0;
        // fall through
      case Opcodes.F_APPEND:
        for (Object type : locals) {
          V value = newFrameValue(owner, frameNode, type);
          if (currentLocal + value.getSize() > frame.getLocals()) {
            throw new AnalyzerException(frameNode, "Cannot append more locals than maxLocals");
          }
          frame.setLocal(currentLocal++, value);
          if (value.getSize() == 2) {
            frame.setLocal(currentLocal++, interpreter.newValue(null));
          }
        }
        break;
      case Opcodes.F_CHOP:
        for (Object unusedType : locals) {
          if (currentLocal <= 0) {
            throw new AnalyzerException(frameNode, "Cannot chop more locals than defined");
          }
          if (currentLocal > 1 && frame.getLocal(currentLocal - 2).getSize() == 2) {
            currentLocal -= 2;
          } else {
            currentLocal -= 1;
          }
        }
        break;
      case Opcodes.F_SAME:
      case Opcodes.F_SAME1:
        break;
      default:
        throw new AnalyzerException(frameNode, "Illegal frame type " + frameNode.type);
    }
    currentLocals = currentLocal;
    while (currentLocal < frame.getLocals()) {
      frame.setLocal(currentLocal++, interpreter.newValue(null));
    }

    List<Object> stack = frameNode.stack == null ? Collections.emptyList() : frameNode.stack;
    frame.clearStack();
    for (Object type : stack) {
      frame.push(newFrameValue(owner, frameNode, type));
    }
    return frame;
  }

  /**
   * Creates a new {@link Value} that represents the given stack map frame type.
   *
   * @param owner the internal name of the class to which 'frameNode' belongs.
   * @param frameNode the stack map frame to which 'type' belongs.
   * @param type an Integer, String or LabelNode object representing a primitive, reference or
   *     uninitialized a stack map frame type, respectively. See {@link FrameNode}.
   * @return a value that represents the given type.
   * @throws AnalyzerException if 'type' is an invalid stack map frame type.
   */
  private V newFrameValue(final @InternalForm String owner, final FrameNode frameNode, final Object type)
      throws AnalyzerException {
    if (type == Opcodes.TOP) {
      return interpreter.newValue(null);
    } else if (type == Opcodes.INTEGER) {
      return interpreter.newValue(Type.INT_TYPE);
    } else if (type == Opcodes.FLOAT) {
      return interpreter.newValue(Type.FLOAT_TYPE);
    } else if (type == Opcodes.LONG) {
      return interpreter.newValue(Type.LONG_TYPE);
    } else if (type == Opcodes.DOUBLE) {
      return interpreter.newValue(Type.DOUBLE_TYPE);
    } else if (type == Opcodes.NULL) {
      return interpreter.newOperation(new InsnNode(Opcodes.ACONST_NULL));
    } else if (type == Opcodes.UNINITIALIZED_THIS) {
      return interpreter.newValue(Type.getObjectType(owner));
    } else if (type instanceof String) {
      return interpreter.newValue(Type.getObjectType((String) type));
    } else if (type instanceof LabelNode) {
      AbstractInsnNode referencedNode = (LabelNode) type;
      while (referencedNode != null && !isJvmInsnNode(referencedNode)) {
        referencedNode = referencedNode.getNext();
      }
      if (referencedNode == null || referencedNode.getOpcode() != Opcodes.NEW) {
        throw new AnalyzerException(frameNode, "LabelNode does not designate a NEW instruction");
      }
      return interpreter.newValue(Type.getObjectType(((TypeInsnNode) referencedNode).desc));
    }
    throw new AnalyzerException(frameNode, "Illegal stack map frame value " + type);
  }

  /**
   * Checks that the given frame is compatible with the frame at the given instruction index, if
   * any. If there is no frame at this instruction index and none is required, the frame at
   * 'insnIndex' is set to the given frame. Otherwise, if the merge of the two frames is not equal
   * to the current frame at 'insnIndex', an exception is thrown.
   *
   * @param insnIndex an instruction index.
   * @param frame a frame. This frame is left unchanged by this method.
   * @param requireFrame whether a frame must already exist or not in {@link #frames} at
   *     'insnIndex'.
   * @throws AnalyzerException if the frames have incompatible sizes or if the frame at 'insnIndex'
   *     is missing (if required) or not compatible with 'frame'.
   */
  private void checkFrame(final int insnIndex, final Frame<V> frame, final boolean requireFrame)
      throws AnalyzerException {
    Frame<V> oldFrame = getFrames()[insnIndex];
    if (oldFrame == null) {
      if (requireFrame) {
        throw new AnalyzerException(null, "Expected stack map frame at instruction " + insnIndex);
      }
      getFrames()[insnIndex] = newFrame(frame);
    } else {
      String error = checkMerge(frame, oldFrame);
      if (error != null) {
        throw new AnalyzerException(
            null,
            "Stack map frame incompatible with frame at instruction "
                + insnIndex
                + " ("
                + error
                + ")");
      }
    }
  }

  /**
   * Checks that merging the two given frames would not produce any change, i.e. that the types in
   * the source frame are sub types of the corresponding types in the destination frame.
   *
   * @param srcFrame a source frame. This frame is left unchanged by this method.
   * @param dstFrame a destination frame. This frame is left unchanged by this method.
   * @return an error message if the frames have incompatible sizes, or if a type in the source
   *     frame is not a sub type of the corresponding type in the destination frame. Returns
   *     {@literal null} otherwise.
   */
  private String checkMerge(final Frame<V> srcFrame, final Frame<V> dstFrame) {
    int numLocals = srcFrame.getLocals();
    if (numLocals != dstFrame.getLocals()) {
      throw new AssertionError();
    }
    for (int i = 0; i < numLocals; ++i) {
      V v = interpreter.merge(srcFrame.getLocal(i), dstFrame.getLocal(i));
      if (!v.equals(dstFrame.getLocal(i))) {
        return "incompatible types at local "
            + i
            + ": "
            + srcFrame.getLocal(i)
            + " and "
            + dstFrame.getLocal(i);
      }
    }
    int numStack = srcFrame.getStackSize();
    if (numStack != dstFrame.getStackSize()) {
      return "incompatible stack heights";
    }
    for (int i = 0; i < numStack; ++i) {
      V v = interpreter.merge(srcFrame.getStack(i), dstFrame.getStack(i));
      if (!v.equals(dstFrame.getStack(i))) {
        return "incompatible types at stack item "
            + i
            + ": "
            + srcFrame.getStack(i)
            + " and "
            + dstFrame.getStack(i);
      }
    }
    return null;
  }

  /**
   * Ends the control flow graph at the given instruction. This method checks that there is an
   * existing frame for the next instruction, if any.
   *
   * @param insnIndex an instruction index.
   * @throws AnalyzerException if 'insnIndex' is not the last instruction and there is no frame at
   *     'insnIndex' + 1 in {@link #getFrames}.
   */
  private void endControlFlow(final int insnIndex) throws AnalyzerException {
    if (hasNextJvmInsnOrFrame(insnIndex) && getFrames()[insnIndex + 1] == null) {
      throw new AnalyzerException(
          null, "Expected stack map frame at instruction " + (insnIndex + 1));
    }
  }

  /**
   * Returns true if the given instruction is followed by a JVM instruction or a by stack map frame.
   *
   * @param insnIndex an instruction index.
   * @return true if 'insnIndex' is followed by a JVM instruction or a by stack map frame.
   */
  private boolean hasNextJvmInsnOrFrame(final int insnIndex) {
    AbstractInsnNode insn = insnList.get(insnIndex).getNext();
    while (insn != null) {
      if (isJvmInsnNode(insn) || insn instanceof FrameNode) {
        return true;
      }
      insn = insn.getNext();
    }
    return false;
  }

  /**
   * Returns true if the given instruction node corresponds to a real JVM instruction.
   *
   * @param insnNode an instruction node.
   * @return true except for label, line number and stack map frame nodes.
   */
  private static boolean isJvmInsnNode(final AbstractInsnNode insnNode) {
    return insnNode.getOpcode() >= 0;
  }
}

package org.objectweb.asm.util;

import java.util.EnumSet;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.signature.SignatureVisitor;

/**
 * A {@link SignatureVisitor} that checks that its methods are properly used.
 *
 * @author Eric Bruneton
 */
public class CheckSignatureAdapter extends SignatureVisitor {

  /**
   * Type to be used to check class signatures. See {@link #CheckSignatureAdapter(int,
   * SignatureVisitor)}.
   */
  public static final int CLASS_SIGNATURE = 0;

  /**
   * Type to be used to check method signatures. See {@link #CheckSignatureAdapter(int,
   * SignatureVisitor)}.
   */
  public static final int METHOD_SIGNATURE = 1;

  /**
   * Type to be used to check type signatures.See {@link #CheckSignatureAdapter(int,
   * SignatureVisitor)}.
   */
  public static final int TYPE_SIGNATURE = 2;

  /** The valid automaton states for a {@link #visitFormalTypeParameter} method call. */
  private static final EnumSet<State> VISIT_FORMAL_TYPE_PARAMETER_STATES =
      EnumSet.of(State.EMPTY, State.FORMAL, State.BOUND);

  /** The valid automaton states for a {@link #visitClassBound} method call. */
  private static final EnumSet<State> VISIT_CLASS_BOUND_STATES = EnumSet.of(State.FORMAL);

  /** The valid automaton states for a {@link #visitInterfaceBound} method call. */
  private static final EnumSet<State> VISIT_INTERFACE_BOUND_STATES =
      EnumSet.of(State.FORMAL, State.BOUND);

  /** The valid automaton states for a {@link #visitSuperclass} method call. */
  private static final EnumSet<State> VISIT_SUPER_CLASS_STATES =
      EnumSet.of(State.EMPTY, State.FORMAL, State.BOUND);

  /** The valid automaton states for a {@link #visitInterface} method call. */
  private static final EnumSet<State> VISIT_INTERFACE_STATES = EnumSet.of(State.SUPER);

  /** The valid automaton states for a {@link #visitParameterType} method call. */
  private static final EnumSet<State> VISIT_PARAMETER_TYPE_STATES =
      EnumSet.of(State.EMPTY, State.FORMAL, State.BOUND, State.PARAM);

  /** The valid automaton states for a {@link #visitReturnType} method call. */
  private static final EnumSet<State> VISIT_RETURN_TYPE_STATES =
      EnumSet.of(State.EMPTY, State.FORMAL, State.BOUND, State.PARAM);

  /** The valid automaton states for a {@link #visitExceptionType} method call. */
  private static final EnumSet<State> VISIT_EXCEPTION_TYPE_STATES = EnumSet.of(State.RETURN);

  /** The possible states of the automaton used to check the order of method calls. */
  private enum State {
    EMPTY,
    FORMAL,
    BOUND,
    SUPER,
    PARAM,
    RETURN,
    SIMPLE_TYPE,
    CLASS_TYPE,
    END;
  }

  private static final String INVALID = "Invalid ";

  /** The type of the visited signature. */
  private final int type;

  /** The current state of the automaton used to check the order of method calls. */
  private State state;

  /** Whether the visited signature can be 'V'. */
  private boolean canBeVoid;

  /** The visitor to which this adapter must delegate calls. May be {@literal null}. */
  private final SignatureVisitor signatureVisitor;

  /**
   * Constructs a new {@link CheckSignatureAdapter}. <i>Subclasses must not use this
   * constructor</i>. Instead, they must use the {@link #CheckSignatureAdapter(int, int,
   * SignatureVisitor)} version.
   *
   * @param type the type of signature to be checked. See {@link #CLASS_SIGNATURE}, {@link
   *     #METHOD_SIGNATURE} and {@link #TYPE_SIGNATURE}.
   * @param signatureVisitor the visitor to which this adapter must delegate calls. May be {@literal
   *     null}.
   */
  public CheckSignatureAdapter(final int type, final SignatureVisitor signatureVisitor) {
    this(/* latest api = */ Opcodes.ASM9, type, signatureVisitor);
  }

  /**
   * Constructs a new {@link CheckSignatureAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param type the type of signature to be checked. See {@link #CLASS_SIGNATURE}, {@link
   *     #METHOD_SIGNATURE} and {@link #TYPE_SIGNATURE}.
   * @param signatureVisitor the visitor to which this adapter must delegate calls. May be {@literal
   *     null}.
   */
  protected CheckSignatureAdapter(
      final int api, final int type, final SignatureVisitor signatureVisitor) {
    super(api);
    this.type = type;
    this.state = State.EMPTY;
    this.signatureVisitor = signatureVisitor;
  }

  // class and method signatures

  @Override
  public void visitFormalTypeParameter(final String name) {
    if (type == TYPE_SIGNATURE || !VISIT_FORMAL_TYPE_PARAMETER_STATES.contains(state)) {
      throw new IllegalStateException();
    }
    checkIdentifier(name, "formal type parameter");
    state = State.FORMAL;
    if (signatureVisitor != null) {
      signatureVisitor.visitFormalTypeParameter(name);
    }
  }

  @Override
  public SignatureVisitor visitClassBound() {
    if (type == TYPE_SIGNATURE || !VISIT_CLASS_BOUND_STATES.contains(state)) {
      throw new IllegalStateException();
    }
    state = State.BOUND;
    return new CheckSignatureAdapter(
        TYPE_SIGNATURE, signatureVisitor == null ? null : signatureVisitor.visitClassBound());
  }

  @Override
  public SignatureVisitor visitInterfaceBound() {
    if (type == TYPE_SIGNATURE || !VISIT_INTERFACE_BOUND_STATES.contains(state)) {
      throw new IllegalStateException();
    }
    return new CheckSignatureAdapter(
        TYPE_SIGNATURE, signatureVisitor == null ? null : signatureVisitor.visitInterfaceBound());
  }

  // class signatures

  @Override
  public SignatureVisitor visitSuperclass() {
    if (type != CLASS_SIGNATURE || !VISIT_SUPER_CLASS_STATES.contains(state)) {
      throw new IllegalStateException();
    }
    state = State.SUPER;
    return new CheckSignatureAdapter(
        TYPE_SIGNATURE, signatureVisitor == null ? null : signatureVisitor.visitSuperclass());
  }

  @Override
  public SignatureVisitor visitInterface() {
    if (type != CLASS_SIGNATURE || !VISIT_INTERFACE_STATES.contains(state)) {
      throw new IllegalStateException();
    }
    return new CheckSignatureAdapter(
        TYPE_SIGNATURE, signatureVisitor == null ? null : signatureVisitor.visitInterface());
  }

  // method signatures

  @Override
  public SignatureVisitor visitParameterType() {
    if (type != METHOD_SIGNATURE || !VISIT_PARAMETER_TYPE_STATES.contains(state)) {
      throw new IllegalStateException();
    }
    state = State.PARAM;
    return new CheckSignatureAdapter(
        TYPE_SIGNATURE, signatureVisitor == null ? null : signatureVisitor.visitParameterType());
  }

  @Override
  public SignatureVisitor visitReturnType() {
    if (type != METHOD_SIGNATURE || !VISIT_RETURN_TYPE_STATES.contains(state)) {
      throw new IllegalStateException();
    }
    state = State.RETURN;
    CheckSignatureAdapter checkSignatureAdapter =
        new CheckSignatureAdapter(
            TYPE_SIGNATURE, signatureVisitor == null ? null : signatureVisitor.visitReturnType());
    checkSignatureAdapter.canBeVoid = true;
    return checkSignatureAdapter;
  }

  @Override
  public SignatureVisitor visitExceptionType() {
    if (type != METHOD_SIGNATURE || !VISIT_EXCEPTION_TYPE_STATES.contains(state)) {
      throw new IllegalStateException();
    }
    return new CheckSignatureAdapter(
        TYPE_SIGNATURE, signatureVisitor == null ? null : signatureVisitor.visitExceptionType());
  }

  // type signatures

  @Override
  public void visitBaseType(final char descriptor) {
    if (type != TYPE_SIGNATURE || state != State.EMPTY) {
      throw new IllegalStateException();
    }
    if (descriptor == 'V') {
      if (!canBeVoid) {
        throw new IllegalArgumentException("Base type descriptor can't be V");
      }
    } else {
      if ("ZCBSIFJD".indexOf(descriptor) == -1) {
        throw new IllegalArgumentException("Base type descriptor must be one of ZCBSIFJD");
      }
    }
    state = State.SIMPLE_TYPE;
    if (signatureVisitor != null) {
      signatureVisitor.visitBaseType(descriptor);
    }
  }

  @Override
  public void visitTypeVariable(final String name) {
    if (type != TYPE_SIGNATURE || state != State.EMPTY) {
      throw new IllegalStateException();
    }
    checkIdentifier(name, "type variable");
    state = State.SIMPLE_TYPE;
    if (signatureVisitor != null) {
      signatureVisitor.visitTypeVariable(name);
    }
  }

  @Override
  public SignatureVisitor visitArrayType() {
    if (type != TYPE_SIGNATURE || state != State.EMPTY) {
      throw new IllegalStateException();
    }
    state = State.SIMPLE_TYPE;
    return new CheckSignatureAdapter(
        TYPE_SIGNATURE, signatureVisitor == null ? null : signatureVisitor.visitArrayType());
  }

  @Override
  public void visitClassType(final String name) {
    if (type != TYPE_SIGNATURE || state != State.EMPTY) {
      throw new IllegalStateException();
    }
    checkClassName(name, "class name");
    state = State.CLASS_TYPE;
    if (signatureVisitor != null) {
      signatureVisitor.visitClassType(name);
    }
  }

  @Override
  public void visitInnerClassType(final String name) {
    if (state != State.CLASS_TYPE) {
      throw new IllegalStateException();
    }
    checkIdentifier(name, "inner class name");
    if (signatureVisitor != null) {
      signatureVisitor.visitInnerClassType(name);
    }
  }

  @Override
  public void visitTypeArgument() {
    if (state != State.CLASS_TYPE) {
      throw new IllegalStateException();
    }
    if (signatureVisitor != null) {
      signatureVisitor.visitTypeArgument();
    }
  }

  @Override
  public SignatureVisitor visitTypeArgument(final char wildcard) {
    if (state != State.CLASS_TYPE) {
      throw new IllegalStateException();
    }
    if ("+-=".indexOf(wildcard) == -1) {
      throw new IllegalArgumentException("Wildcard must be one of +-=");
    }
    return new CheckSignatureAdapter(
        TYPE_SIGNATURE,
        signatureVisitor == null ? null : signatureVisitor.visitTypeArgument(wildcard));
  }

  @Override
  public void visitEnd() {
    if (state != State.CLASS_TYPE) {
      throw new IllegalStateException();
    }
    state = State.END;
    if (signatureVisitor != null) {
      signatureVisitor.visitEnd();
    }
  }

  private void checkClassName(final String name, final String message) {
    if (name == null || name.length() == 0) {
      throw new IllegalArgumentException(INVALID + message + " (must not be null or empty)");
    }
    for (int i = 0; i < name.length(); ++i) {
      if (".;[<>:".indexOf(name.charAt(i)) != -1) {
        throw new IllegalArgumentException(
            INVALID + message + " (must not contain . ; [ < > or :): " + name);
      }
    }
  }

  private void checkIdentifier(final String name, final String message) {
    if (name == null || name.length() == 0) {
      throw new IllegalArgumentException(INVALID + message + " (must not be null or empty)");
    }
    for (int i = 0; i < name.length(); ++i) {
      if (".;[/<>:".indexOf(name.charAt(i)) != -1) {
        throw new IllegalArgumentException(
            INVALID + message + " (must not contain . ; [ / < > or :): " + name);
      }
    }
  }
}

package org.objectweb.asm.util;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;

/**
 * An abstract converter from visit events to text.
 *
 * @author Eric Bruneton
 */
public abstract class Printer {

  /** The names of the Java Virtual Machine opcodes. */
  public static final String[] OPCODES = {
    "NOP", // 0 (0x0)
    "ACONST_NULL", // 1 (0x1)
    "ICONST_M1", // 2 (0x2)
    "ICONST_0", // 3 (0x3)
    "ICONST_1", // 4 (0x4)
    "ICONST_2", // 5 (0x5)
    "ICONST_3", // 6 (0x6)
    "ICONST_4", // 7 (0x7)
    "ICONST_5", // 8 (0x8)
    "LCONST_0", // 9 (0x9)
    "LCONST_1", // 10 (0xa)
    "FCONST_0", // 11 (0xb)
    "FCONST_1", // 12 (0xc)
    "FCONST_2", // 13 (0xd)
    "DCONST_0", // 14 (0xe)
    "DCONST_1", // 15 (0xf)
    "BIPUSH", // 16 (0x10)
    "SIPUSH", // 17 (0x11)
    "LDC", // 18 (0x12)
    "LDC_W", // 19 (0x13)
    "LDC2_W", // 20 (0x14)
    "ILOAD", // 21 (0x15)
    "LLOAD", // 22 (0x16)
    "FLOAD", // 23 (0x17)
    "DLOAD", // 24 (0x18)
    "ALOAD", // 25 (0x19)
    "ILOAD_0", // 26 (0x1a)
    "ILOAD_1", // 27 (0x1b)
    "ILOAD_2", // 28 (0x1c)
    "ILOAD_3", // 29 (0x1d)
    "LLOAD_0", // 30 (0x1e)
    "LLOAD_1", // 31 (0x1f)
    "LLOAD_2", // 32 (0x20)
    "LLOAD_3", // 33 (0x21)
    "FLOAD_0", // 34 (0x22)
    "FLOAD_1", // 35 (0x23)
    "FLOAD_2", // 36 (0x24)
    "FLOAD_3", // 37 (0x25)
    "DLOAD_0", // 38 (0x26)
    "DLOAD_1", // 39 (0x27)
    "DLOAD_2", // 40 (0x28)
    "DLOAD_3", // 41 (0x29)
    "ALOAD_0", // 42 (0x2a)
    "ALOAD_1", // 43 (0x2b)
    "ALOAD_2", // 44 (0x2c)
    "ALOAD_3", // 45 (0x2d)
    "IALOAD", // 46 (0x2e)
    "LALOAD", // 47 (0x2f)
    "FALOAD", // 48 (0x30)
    "DALOAD", // 49 (0x31)
    "AALOAD", // 50 (0x32)
    "BALOAD", // 51 (0x33)
    "CALOAD", // 52 (0x34)
    "SALOAD", // 53 (0x35)
    "ISTORE", // 54 (0x36)
    "LSTORE", // 55 (0x37)
    "FSTORE", // 56 (0x38)
    "DSTORE", // 57 (0x39)
    "ASTORE", // 58 (0x3a)
    "ISTORE_0", // 59 (0x3b)
    "ISTORE_1", // 60 (0x3c)
    "ISTORE_2", // 61 (0x3d)
    "ISTORE_3", // 62 (0x3e)
    "LSTORE_0", // 63 (0x3f)
    "LSTORE_1", // 64 (0x40)
    "LSTORE_2", // 65 (0x41)
    "LSTORE_3", // 66 (0x42)
    "FSTORE_0", // 67 (0x43)
    "FSTORE_1", // 68 (0x44)
    "FSTORE_2", // 69 (0x45)
    "FSTORE_3", // 70 (0x46)
    "DSTORE_0", // 71 (0x47)
    "DSTORE_1", // 72 (0x48)
    "DSTORE_2", // 73 (0x49)
    "DSTORE_3", // 74 (0x4a)
    "ASTORE_0", // 75 (0x4b)
    "ASTORE_1", // 76 (0x4c)
    "ASTORE_2", // 77 (0x4d)
    "ASTORE_3", // 78 (0x4e)
    "IASTORE", // 79 (0x4f)
    "LASTORE", // 80 (0x50)
    "FASTORE", // 81 (0x51)
    "DASTORE", // 82 (0x52)
    "AASTORE", // 83 (0x53)
    "BASTORE", // 84 (0x54)
    "CASTORE", // 85 (0x55)
    "SASTORE", // 86 (0x56)
    "POP", // 87 (0x57)
    "POP2", // 88 (0x58)
    "DUP", // 89 (0x59)
    "DUP_X1", // 90 (0x5a)
    "DUP_X2", // 91 (0x5b)
    "DUP2", // 92 (0x5c)
    "DUP2_X1", // 93 (0x5d)
    "DUP2_X2", // 94 (0x5e)
    "SWAP", // 95 (0x5f)
    "IADD", // 96 (0x60)
    "LADD", // 97 (0x61)
    "FADD", // 98 (0x62)
    "DADD", // 99 (0x63)
    "ISUB", // 100 (0x64)
    "LSUB", // 101 (0x65)
    "FSUB", // 102 (0x66)
    "DSUB", // 103 (0x67)
    "IMUL", // 104 (0x68)
    "LMUL", // 105 (0x69)
    "FMUL", // 106 (0x6a)
    "DMUL", // 107 (0x6b)
    "IDIV", // 108 (0x6c)
    "LDIV", // 109 (0x6d)
    "FDIV", // 110 (0x6e)
    "DDIV", // 111 (0x6f)
    "IREM", // 112 (0x70)
    "LREM", // 113 (0x71)
    "FREM", // 114 (0x72)
    "DREM", // 115 (0x73)
    "INEG", // 116 (0x74)
    "LNEG", // 117 (0x75)
    "FNEG", // 118 (0x76)
    "DNEG", // 119 (0x77)
    "ISHL", // 120 (0x78)
    "LSHL", // 121 (0x79)
    "ISHR", // 122 (0x7a)
    "LSHR", // 123 (0x7b)
    "IUSHR", // 124 (0x7c)
    "LUSHR", // 125 (0x7d)
    "IAND", // 126 (0x7e)
    "LAND", // 127 (0x7f)
    "IOR", // 128 (0x80)
    "LOR", // 129 (0x81)
    "IXOR", // 130 (0x82)
    "LXOR", // 131 (0x83)
    "IINC", // 132 (0x84)
    "I2L", // 133 (0x85)
    "I2F", // 134 (0x86)
    "I2D", // 135 (0x87)
    "L2I", // 136 (0x88)
    "L2F", // 137 (0x89)
    "L2D", // 138 (0x8a)
    "F2I", // 139 (0x8b)
    "F2L", // 140 (0x8c)
    "F2D", // 141 (0x8d)
    "D2I", // 142 (0x8e)
    "D2L", // 143 (0x8f)
    "D2F", // 144 (0x90)
    "I2B", // 145 (0x91)
    "I2C", // 146 (0x92)
    "I2S", // 147 (0x93)
    "LCMP", // 148 (0x94)
    "FCMPL", // 149 (0x95)
    "FCMPG", // 150 (0x96)
    "DCMPL", // 151 (0x97)
    "DCMPG", // 152 (0x98)
    "IFEQ", // 153 (0x99)
    "IFNE", // 154 (0x9a)
    "IFLT", // 155 (0x9b)
    "IFGE", // 156 (0x9c)
    "IFGT", // 157 (0x9d)
    "IFLE", // 158 (0x9e)
    "IF_ICMPEQ", // 159 (0x9f)
    "IF_ICMPNE", // 160 (0xa0)
    "IF_ICMPLT", // 161 (0xa1)
    "IF_ICMPGE", // 162 (0xa2)
    "IF_ICMPGT", // 163 (0xa3)
    "IF_ICMPLE", // 164 (0xa4)
    "IF_ACMPEQ", // 165 (0xa5)
    "IF_ACMPNE", // 166 (0xa6)
    "GOTO", // 167 (0xa7)
    "JSR", // 168 (0xa8)
    "RET", // 169 (0xa9)
    "TABLESWITCH", // 170 (0xaa)
    "LOOKUPSWITCH", // 171 (0xab)
    "IRETURN", // 172 (0xac)
    "LRETURN", // 173 (0xad)
    "FRETURN", // 174 (0xae)
    "DRETURN", // 175 (0xaf)
    "ARETURN", // 176 (0xb0)
    "RETURN", // 177 (0xb1)
    "GETSTATIC", // 178 (0xb2)
    "PUTSTATIC", // 179 (0xb3)
    "GETFIELD", // 180 (0xb4)
    "PUTFIELD", // 181 (0xb5)
    "INVOKEVIRTUAL", // 182 (0xb6)
    "INVOKESPECIAL", // 183 (0xb7)
    "INVOKESTATIC", // 184 (0xb8)
    "INVOKEINTERFACE", // 185 (0xb9)
    "INVOKEDYNAMIC", // 186 (0xba)
    "NEW", // 187 (0xbb)
    "NEWARRAY", // 188 (0xbc)
    "ANEWARRAY", // 189 (0xbd)
    "ARRAYLENGTH", // 190 (0xbe)
    "ATHROW", // 191 (0xbf)
    "CHECKCAST", // 192 (0xc0)
    "INSTANCEOF", // 193 (0xc1)
    "MONITORENTER", // 194 (0xc2)
    "MONITOREXIT", // 195 (0xc3)
    "WIDE", // 196 (0xc4)
    "MULTIANEWARRAY", // 197 (0xc5)
    "IFNULL", // 198 (0xc6)
    "IFNONNULL" // 199 (0xc7)
  };

  /**
   * The names of the {@code operand} values of the {@link
   * org.objectweb.asm.MethodVisitor#visitIntInsn} method when {@code opcode} is {@code NEWARRAY}.
   */
  public static final String[] TYPES = {
    "",
    "",
    "",
    "",
    "T_BOOLEAN",
    "T_CHAR",
    "T_FLOAT",
    "T_DOUBLE",
    "T_BYTE",
    "T_SHORT",
    "T_INT",
    "T_LONG"
  };

  /** The names of the {@code tag} field values for {@link org.objectweb.asm.Handle}. */
  public static final String[] HANDLE_TAG = {
    "",
    "H_GETFIELD",
    "H_GETSTATIC",
    "H_PUTFIELD",
    "H_PUTSTATIC",
    "H_INVOKEVIRTUAL",
    "H_INVOKESTATIC",
    "H_INVOKESPECIAL",
    "H_NEWINVOKESPECIAL",
    "H_INVOKEINTERFACE"
  };

  /** Message of the UnsupportedOperationException thrown by methods which must be overridden. */
  private static final String UNSUPPORTED_OPERATION = "Must be overridden";

  /**
   * The ASM API version implemented by this class. The value of this field must be one of the
   * {@code ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected final int api;

  /** The builder used to build strings in the various visit methods. */
  protected final StringBuilder stringBuilder;

  /**
   * The text to be printed. Since the code of methods is not necessarily visited in sequential
   * order, one method after the other, but can be interlaced (some instructions from method one,
   * then some instructions from method two, then some instructions from method one again...), it is
   * not possible to print the visited instructions directly to a sequential stream. A class is
   * therefore printed in a two steps process: a string tree is constructed during the visit, and
   * printed to a sequential stream at the end of the visit. This string tree is stored in this
   * field, as a string list that can contain other string lists, which can themselves contain other
   * string lists, and so on.
   */
  public final List<Object> text;

  // -----------------------------------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link Printer}.
   *
   * @param api the ASM API version implemented by this printer. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected Printer(final int api) {
    this.api = api;
    this.stringBuilder = new StringBuilder();
    this.text = new ArrayList<>();
  }

  // -----------------------------------------------------------------------------------------------
  // Classes
  // -----------------------------------------------------------------------------------------------

  /**
   * Class header. See {@link org.objectweb.asm.ClassVisitor#visit}.
   *
   * @param version the class version. The minor version is stored in the 16 most significant bits,
   *     and the major version in the 16 least significant bits.
   * @param access the class's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the class is deprecated.
   * @param name the internal name of the class (see {@link Type#getInternalName()}).
   * @param signature the signature of this class. May be {@literal null} if the class is not a
   *     generic one, and does not extend or implement generic classes or interfaces.
   * @param superName the internal of name of the super class (see {@link Type#getInternalName()}).
   *     For interfaces, the super class is {@link Object}. May be {@literal null}, but only for the
   *     {@link Object} class.
   * @param interfaces the internal names of the class's interfaces (see {@link
   *     Type#getInternalName()}). May be {@literal null}.
   */
  public abstract void visit(
      int version,
      int access,
      @InternalForm String name,
      String signature,
      @InternalForm String superName,
      @InternalForm String[] interfaces);

  /**
   * Class source. See {@link org.objectweb.asm.ClassVisitor#visitSource}.
   *
   * @param source the name of the source file from which the class was compiled. May be {@literal
   *     null}.
   * @param debug additional debug information to compute the correspondence between source and
   *     compiled elements of the class. May be {@literal null}.
   */
  public abstract void visitSource(String source, String debug);

  /**
   * Module. See {@link org.objectweb.asm.ClassVisitor#visitModule}.
   *
   * @param name the fully qualified name (using dots) of the module.
   * @param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code
   *     ACC_MANDATED}.
   * @param version the module version, or {@literal null}.
   * @return the printer.
   */
  public Printer visitModule(final String name, final int access, final String version) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Visits the nest host class of the class. A nest is a set of classes of the same package that
   * share access to their private members. One of these classes, called the host, lists the other
   * members of the nest, which in turn should link to the host of their nest. This method must be
   * called only once and only if the visited class is a non-host member of a nest. A class is
   * implicitly its own nest, so it's invalid to call this method with the visited class name as
   * argument.
   *
   * @param nestHost the internal name of the host class of the nest (see {@link
   *     Type#getInternalName()}).
   */
  public void visitNestHost(final @InternalForm String nestHost) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Class outer class. See {@link org.objectweb.asm.ClassVisitor#visitOuterClass}.
   *
   * @param owner internal name of the enclosing class of the class (see {@link
   *     Type#getInternalName()}).
   * @param name the name of the method that contains the class, or {@literal null} if the class is
   *     not enclosed in a method of its enclosing class.
   * @param descriptor the descriptor of the method that contains the class, or {@literal null} if
   *     the class is not enclosed in a method of its enclosing class.
   */
  public abstract void visitOuterClass(@InternalForm String owner, String name, String descriptor);

  /**
   * Class annotation. See {@link org.objectweb.asm.ClassVisitor#visitAnnotation}.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public abstract Printer visitClassAnnotation(String descriptor, boolean visible);

  /**
   * Class type annotation. See {@link org.objectweb.asm.ClassVisitor#visitTypeAnnotation}.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link
   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See
   *     {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public Printer visitClassTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Class attribute. See {@link org.objectweb.asm.ClassVisitor#visitAttribute}.
   *
   * @param attribute an attribute.
   */
  public abstract void visitClassAttribute(Attribute attribute);

  /**
   * Visits a member of the nest. A nest is a set of classes of the same package that share access
   * to their private members. One of these classes, called the host, lists the other members of the
   * nest, which in turn should link to the host of their nest. This method must be called only if
   * the visited class is the host of a nest. A nest host is implicitly a member of its own nest, so
   * it's invalid to call this method with the visited class name as argument.
   *
   * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).
   */
  public void visitNestMember(final @InternalForm String nestMember) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Visits a permitted subclasses. A permitted subclass is one of the allowed subclasses of the
   * current class. See {@link org.objectweb.asm.ClassVisitor#visitPermittedSubclass(String)}.
   *
   * @param permittedSubclass the internal name of a permitted subclass (see {@link
   *     Type#getInternalName()}).
   */
  public void visitPermittedSubclass(final @InternalForm String permittedSubclass) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Class inner name. See {@link org.objectweb.asm.ClassVisitor#visitInnerClass}.
   *
   * @param name the internal name of an inner class (see {@link Type#getInternalName()}).
   * @param outerName the internal name of the class to which the inner class belongs (see {@link
   *     Type#getInternalName()}). May be {@literal null} for not member classes.
   * @param innerName the (simple) name of the inner class inside its enclosing class. May be
   *     {@literal null} for anonymous inner classes.
   * @param access the access flags of the inner class as originally declared in the enclosing
   *     class.
   */
  public abstract void visitInnerClass(@InternalForm String name, @InternalForm String outerName, @Identifier String innerName, int access);

  /**
   * Visits a record component of the class. See {@link
   * org.objectweb.asm.ClassVisitor#visitRecordComponent(String, String, String)}.
   *
   * @param name the field's name.
   * @param descriptor the record component descriptor (see {@link Type}).
   * @param signature the record component signature. May be {@literal null} if the record component
   *     type does not use generic types.
   * @return a visitor to visit this record component annotations and attributes, or {@literal null}
   *     if this class visitor is not interested in visiting these annotations and attributes.
   */
  public Printer visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Class field. See {@link org.objectweb.asm.ClassVisitor#visitField}.
   *
   * @param access the field's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the field is synthetic and/or deprecated.
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link Type}).
   * @param signature the field's signature. May be {@literal null} if the field's type does not use
   *     generic types.
   * @param value the field's initial value. This parameter, which may be {@literal null} if the
   *     field does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link
   *     Long}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}
   *     or {@code String} fields respectively). <i>This parameter is only used for static
   *     fields</i>. Its value is ignored for non static fields, which must be initialized through
   *     bytecode instructions in constructors or methods.
   * @return the printer.
   */
  public abstract Printer visitField(
      int access, String name, String descriptor, String signature, Object value);

  /**
   * Class method. See {@link org.objectweb.asm.ClassVisitor#visitMethod}.
   *
   * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if
   *     the method is synthetic and/or deprecated.
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param signature the method's signature. May be {@literal null} if the method parameters,
   *     return type and exceptions do not use generic types.
   * @param exceptions the internal names of the method's exception classes (see {@link
   *     Type#getInternalName()}). May be {@literal null}.
   * @return the printer.
   */
  public abstract Printer visitMethod(
      int access, String name, String descriptor, String signature, @InternalForm String[] exceptions);

  /** Class end. See {@link org.objectweb.asm.ClassVisitor#visitEnd}. */
  public abstract void visitClassEnd();

  // -----------------------------------------------------------------------------------------------
  // Modules
  // -----------------------------------------------------------------------------------------------

  /**
   * Module main class. See {@link org.objectweb.asm.ModuleVisitor#visitMainClass}.
   *
   * @param mainClass the internal name of the main class of the current module (see {@link
   *     Type#getInternalName()}).
   */
  public void visitMainClass(final @InternalForm String mainClass) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Module package. See {@link org.objectweb.asm.ModuleVisitor#visitPackage}.
   *
   * @param packaze the internal name of a package (see {@link Type#getInternalName()}).
   */
  public void visitPackage(final String packaze) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Module require. See {@link org.objectweb.asm.ModuleVisitor#visitRequire}.
   *
   * @param module the fully qualified name (using dots) of the dependence.
   * @param access the access flag of the dependence among {@code ACC_TRANSITIVE}, {@code
   *     ACC_STATIC_PHASE}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   * @param version the module version at compile time, or {@literal null}.
   */
  public void visitRequire(final String module, final int access, final String version) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Module export. See {@link org.objectweb.asm.ModuleVisitor#visitExport}.
   *
   * @param packaze the internal name of the exported package (see {@link Type#getInternalName()}).
   * @param access the access flag of the exported package, valid values are among {@code
   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   * @param modules the fully qualified names (using dots) of the modules that can access the public
   *     classes of the exported package, or {@literal null}.
   */
  public void visitExport(final String packaze, final int access, final String... modules) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Module open. See {@link org.objectweb.asm.ModuleVisitor#visitOpen}.
   *
   * @param packaze the internal name of the opened package (see {@link Type#getInternalName()}).
   * @param access the access flag of the opened package, valid values are among {@code
   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.
   * @param modules the fully qualified names (using dots) of the modules that can use deep
   *     reflection to the classes of the open package, or {@literal null}.
   */
  public void visitOpen(final String packaze, final int access, final String... modules) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Module use. See {@link org.objectweb.asm.ModuleVisitor#visitUse}.
   *
   * @param service the internal name of the service (see {@link Type#getInternalName()}).
   */
  public void visitUse(final @InternalForm String service) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Module provide. See {@link org.objectweb.asm.ModuleVisitor#visitProvide}.
   *
   * @param service the internal name of the service (see {@link Type#getInternalName()}).
   * @param providers the internal names of the implementations of the service (there is at least
   *     one provider).
   */
  public void visitProvide(final @InternalForm String service, final @InternalForm String... providers) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /** Module end. See {@link org.objectweb.asm.ModuleVisitor#visitEnd}. */
  public void visitModuleEnd() {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  // -----------------------------------------------------------------------------------------------
  // Annotations
  // -----------------------------------------------------------------------------------------------

  /**
   * Annotation value. See {@link org.objectweb.asm.AnnotationVisitor#visit}.
   *
   * @param name the value name.
   * @param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link
   *     Character}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},
   *     {@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This
   *     value can also be an array of byte, boolean, short, char, int, long, float or double values
   *     (this is equivalent to using {@link #visitArray} and visiting each array element in turn,
   *     but is more convenient).
   */
  // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
  public abstract void visit(String name, Object value);

  /**
   * Annotation enum value. See {@link org.objectweb.asm.AnnotationVisitor#visitEnum}.
   *
   * @param name the value name.
   * @param descriptor the class descriptor of the enumeration class.
   * @param value the actual enumeration value.
   */
  public abstract void visitEnum(String name, String descriptor, String value);

  /**
   * Nested annotation value. See {@link org.objectweb.asm.AnnotationVisitor#visitAnnotation}.
   *
   * @param name the value name.
   * @param descriptor the class descriptor of the nested annotation class.
   * @return the printer.
   */
  public abstract Printer visitAnnotation(String name, String descriptor);

  /**
   * Annotation array value. See {@link org.objectweb.asm.AnnotationVisitor#visitArray}.
   *
   * @param name the value name.
   * @return the printer.
   */
  public abstract Printer visitArray(String name);

  /** Annotation end. See {@link org.objectweb.asm.AnnotationVisitor#visitEnd}. */
  public abstract void visitAnnotationEnd();

  // -----------------------------------------------------------------------------------------------
  // Record components
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits an annotation of the record component. See {@link
   * org.objectweb.asm.RecordComponentVisitor#visitAnnotation}.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public Printer visitRecordComponentAnnotation(final String descriptor, final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Visits an annotation on a type in the record component signature. See {@link
   * org.objectweb.asm.RecordComponentVisitor#visitTypeAnnotation}.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link
   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See
   *     {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not
   *     interested in visiting this annotation.
   */
  public Printer visitRecordComponentTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Visits a non standard attribute of the record component. See {@link
   * org.objectweb.asm.RecordComponentVisitor#visitAttribute}.
   *
   * @param attribute an attribute.
   */
  public void visitRecordComponentAttribute(final Attribute attribute) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Visits the end of the record component. See {@link
   * org.objectweb.asm.RecordComponentVisitor#visitEnd}. This method, which is the last one to be
   * called, is used to inform the visitor that everything have been visited.
   */
  public void visitRecordComponentEnd() {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  // -----------------------------------------------------------------------------------------------
  // Fields
  // -----------------------------------------------------------------------------------------------

  /**
   * Field annotation. See {@link org.objectweb.asm.FieldVisitor#visitAnnotation}.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public abstract Printer visitFieldAnnotation(String descriptor, boolean visible);

  /**
   * Field type annotation. See {@link org.objectweb.asm.FieldVisitor#visitTypeAnnotation}.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#FIELD}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public Printer visitFieldTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Field attribute. See {@link org.objectweb.asm.FieldVisitor#visitAttribute}.
   *
   * @param attribute an attribute.
   */
  public abstract void visitFieldAttribute(Attribute attribute);

  /** Field end. See {@link org.objectweb.asm.FieldVisitor#visitEnd}. */
  public abstract void visitFieldEnd();

  // -----------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Method parameter. See {@link org.objectweb.asm.MethodVisitor#visitParameter(String, int)}.
   *
   * @param name parameter name or {@literal null} if none is provided.
   * @param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}
   *     or/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).
   */
  public void visitParameter(final String name, final int access) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Method default annotation. See {@link org.objectweb.asm.MethodVisitor#visitAnnotationDefault}.
   *
   * @return the printer.
   */
  public abstract Printer visitAnnotationDefault();

  /**
   * Method annotation. See {@link org.objectweb.asm.MethodVisitor#visitAnnotation}.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public abstract Printer visitMethodAnnotation(String descriptor, boolean visible);

  /**
   * Method type annotation. See {@link org.objectweb.asm.MethodVisitor#visitTypeAnnotation}.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link
   *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link
   *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link
   *     TypeReference#THROWS}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public Printer visitMethodTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Number of method parameters that can have annotations. See {@link
   * org.objectweb.asm.MethodVisitor#visitAnnotableParameterCount}.
   *
   * @param parameterCount the number of method parameters than can have annotations. This number
   *     must be less or equal than the number of parameter types in the method descriptor. It can
   *     be strictly less when a method has synthetic parameters and when these parameters are
   *     ignored when computing parameter indices for the purpose of parameter annotations (see
   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
   * @param visible {@literal true} to define the number of method parameters that can have
   *     annotations visible at runtime, {@literal false} to define the number of method parameters
   *     that can have annotations invisible at runtime.
   * @return the printer.
   */
  public Printer visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Method parameter annotation. See {@link
   * org.objectweb.asm.MethodVisitor#visitParameterAnnotation}.
   *
   * @param parameter the parameter index. This index must be strictly smaller than the number of
   *     parameters in the method descriptor, and strictly smaller than the parameter count
   *     specified in {@link #visitAnnotableParameterCount}. Important note: <i>a parameter index i
   *     is not required to correspond to the i'th parameter descriptor in the method
   *     descriptor</i>, in particular in case of synthetic parameters (see
   *     https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public abstract Printer visitParameterAnnotation(
      int parameter, String descriptor, boolean visible);

  /**
   * Method attribute. See {@link org.objectweb.asm.MethodVisitor#visitAttribute}.
   *
   * @param attribute an attribute.
   */
  public abstract void visitMethodAttribute(Attribute attribute);

  /** Method start. See {@link org.objectweb.asm.MethodVisitor#visitCode}. */
  public abstract void visitCode();

  /**
   * Method stack frame. See {@link org.objectweb.asm.MethodVisitor#visitFrame}.
   *
   * @param type the type of this stack map frame. Must be {@link Opcodes#F_NEW} for expanded
   *     frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link
   *     Opcodes#F_SAME} or {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.
   * @param numLocal the number of local variables in the visited frame.
   * @param local the local variable types in this frame. This array must not be modified. Primitive
   *     types are represented by {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link
   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL} or
   *     {@link Opcodes#UNINITIALIZED_THIS} (long and double are represented by a single element).
   *     Reference types are represented by String objects (representing internal names, see {@link
   *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates
   *     the NEW instruction that created this uninitialized value).
   * @param numStack the number of operand stack elements in the visited frame.
   * @param stack the operand stack types in this frame. This array must not be modified. Its
   *     content has the same format as the "local" array.
   */
  public abstract void visitFrame(
      int type, int numLocal, Object[] local, int numStack, Object[] stack);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitInsn}
   *
   * @param opcode the opcode of the instruction to be visited. This opcode is either NOP,
   *     ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5,
   *     LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,
   *     FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE,
   *     AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2,
   *     SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,
   *     FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR,
   *     LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I,
   *     D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,
   *     DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.
   */
  public abstract void visitInsn(int opcode);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitIntInsn}.
   *
   * @param opcode the opcode of the instruction to be visited. This opcode is either BIPUSH, SIPUSH
   *     or NEWARRAY.
   * @param operand the operand of the instruction to be visited.<br>
   *     When opcode is BIPUSH, operand value should be between Byte.MIN_VALUE and Byte.MAX_VALUE.
   *     <br>
   *     When opcode is SIPUSH, operand value should be between Short.MIN_VALUE and Short.MAX_VALUE.
   *     <br>
   *     When opcode is NEWARRAY, operand value should be one of {@link Opcodes#T_BOOLEAN}, {@link
   *     Opcodes#T_CHAR}, {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE}, {@link Opcodes#T_BYTE},
   *     {@link Opcodes#T_SHORT}, {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
   */
  public abstract void visitIntInsn(int opcode, int operand);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitVarInsn}.
   *
   * @param opcode the opcode of the local variable instruction to be visited. This opcode is either
   *     ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
   * @param varIndex the operand of the instruction to be visited. This operand is the index of a
   *     local variable.
   */
  public abstract void visitVarInsn(int opcode, int varIndex);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitTypeInsn}.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either NEW,
   *     ANEWARRAY, CHECKCAST or INSTANCEOF.
   * @param type the operand of the instruction to be visited. This operand must be the internal
   *     name of an object or array class (see {@link Type#getInternalName()}).
   */
  public abstract void visitTypeInsn(int opcode, @InternalForm String type);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitFieldInsn}.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
   * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).
   * @param name the field's name.
   * @param descriptor the field's descriptor (see {@link Type}).
   */
  public abstract void visitFieldInsn(int opcode, @InternalForm String owner, @Identifier String name, String descriptor);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitMethodInsn}.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.
   */
  @Deprecated
  public void visitMethodInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    // This method was abstract before ASM5, and was therefore always overridden (without any
    // call to 'super'). Thus, at this point we necessarily have api >= ASM5, and we must then
    // redirect the method call to the ASM5 visitMethodInsn() method.
    visitMethodInsn(opcode, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);
  }

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitMethodInsn}.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either
   *     INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.
   * @param owner the internal name of the method's owner class (see {@link
   *     Type#getInternalName()}).
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param isInterface if the method's owner class is an interface.
   */
  public void visitMethodInsn(
      final int opcode,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitInvokeDynamicInsn}.
   *
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param bootstrapMethodHandle the bootstrap method.
   * @param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be
   *     an {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link
   *     Type} or {@link Handle} value. This method is allowed to modify the content of the array so
   *     a caller should expect that this array may change.
   */
  public abstract void visitInvokeDynamicInsn(
      String name,
      String descriptor,
      Handle bootstrapMethodHandle,
      Object... bootstrapMethodArguments);

  /**
   * Method jump instruction. See {@link org.objectweb.asm.MethodVisitor#visitJumpInsn}.
   *
   * @param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,
   *     IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,
   *     IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
   * @param label the operand of the instruction to be visited. This operand is a label that
   *     designates the instruction to which the jump instruction may jump.
   */
  public abstract void visitJumpInsn(int opcode, Label label);

  /**
   * Method label. See {@link org.objectweb.asm.MethodVisitor#visitLabel}.
   *
   * @param label a {@link Label} object.
   */
  public abstract void visitLabel(Label label);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitLdcInsn}.
   *
   * @param value the constant to be loaded on the stack. This parameter must be a non null {@link
   *     Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a {@link String}, a {@link
   *     Type} of OBJECT or ARRAY sort for {@code .class} constants, for classes whose version is
   *     49, a {@link Type} of METHOD sort for MethodType, a {@link Handle} for MethodHandle
   *     constants, for classes whose version is 51 or a {@link ConstantDynamic} for a constant
   *     dynamic for classes whose version is 55.
   */
  public abstract void visitLdcInsn(Object value);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitIincInsn}.
   *
   * @param varIndex index of the local variable to be incremented.
   * @param increment amount to increment the local variable by.
   */
  public abstract void visitIincInsn(int varIndex, int increment);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitTableSwitchInsn}.
   *
   * @param min the minimum key value.
   * @param max the maximum key value.
   * @param dflt beginning of the default handler block.
   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the
   *     handler block for the {@code min + i} key.
   */
  public abstract void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitLookupSwitchInsn}.
   *
   * @param dflt beginning of the default handler block.
   * @param keys the values of the keys.
   * @param labels beginnings of the handler blocks. {@code labels[i]} is the beginning of the
   *     handler block for the {@code keys[i]} key.
   */
  public abstract void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels);

  /**
   * Method instruction. See {@link org.objectweb.asm.MethodVisitor#visitMultiANewArrayInsn}.
   *
   * @param descriptor an array type descriptor (see {@link Type}).
   * @param numDimensions the number of dimensions of the array to allocate.
   */
  public abstract void visitMultiANewArrayInsn(String descriptor, int numDimensions);

  /**
   * Instruction type annotation. See {@link org.objectweb.asm.MethodVisitor#visitInsnAnnotation}.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link
   *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link
   *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link
   *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link
   *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link
   *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public Printer visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Method exception handler. See {@link org.objectweb.asm.MethodVisitor#visitTryCatchBlock}.
   *
   * @param start the beginning of the exception handler's scope (inclusive).
   * @param end the end of the exception handler's scope (exclusive).
   * @param handler the beginning of the exception handler's code.
   * @param type the internal name of the type of exceptions handled by the handler (see {@link
   *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for "finally"
   *     blocks).
   */
  public abstract void visitTryCatchBlock(Label start, Label end, Label handler, @InternalForm String type);

  /**
   * Try catch block type annotation. See {@link
   * org.objectweb.asm.MethodVisitor#visitTryCatchAnnotation}.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public Printer visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Method debug info. See {@link org.objectweb.asm.MethodVisitor#visitLocalVariable}.
   *
   * @param name the name of a local variable.
   * @param descriptor the type descriptor of this local variable.
   * @param signature the type signature of this local variable. May be {@literal null} if the local
   *     variable type does not use generic types.
   * @param start the first instruction corresponding to the scope of this local variable
   *     (inclusive).
   * @param end the last instruction corresponding to the scope of this local variable (exclusive).
   * @param index the local variable's index.
   */
  public abstract void visitLocalVariable(
      String name, String descriptor, String signature, Label start, Label end, int index);

  /**
   * Local variable type annotation. See {@link
   * org.objectweb.asm.MethodVisitor#visitTryCatchAnnotation}.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link
   *     TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param start the fist instructions corresponding to the continuous ranges that make the scope
   *     of this local variable (inclusive).
   * @param end the last instructions corresponding to the continuous ranges that make the scope of
   *     this local variable (exclusive). This array must have the same size as the 'start' array.
   * @param index the local variable's index in each range. This array must have the same size as
   *     the 'start' array.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return the printer.
   */
  public Printer visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    throw new UnsupportedOperationException(UNSUPPORTED_OPERATION);
  }

  /**
   * Method debug info. See {@link org.objectweb.asm.MethodVisitor#visitLineNumber}.
   *
   * @param line a line number. This number refers to the source file from which the class was
   *     compiled.
   * @param start the first instruction corresponding to this line number.
   */
  public abstract void visitLineNumber(int line, Label start);

  /**
   * Method max stack and max locals. See {@link org.objectweb.asm.MethodVisitor#visitMaxs}.
   *
   * @param maxStack maximum stack size of the method.
   * @param maxLocals maximum number of local variables for the method.
   */
  public abstract void visitMaxs(int maxStack, int maxLocals);

  /** Method end. See {@link org.objectweb.asm.MethodVisitor#visitEnd}. */
  public abstract void visitMethodEnd();

  // -----------------------------------------------------------------------------------------------
  // Print and utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the text constructed by this visitor.
   *
   * @return the text constructed by this visitor. See {@link #text}.
   */
  public List<Object> getText() {
    return text;
  }

  /**
   * Prints the text constructed by this visitor.
   *
   * @param printWriter the print writer to be used.
   */
  public void print(final PrintWriter printWriter) {
    printList(printWriter, text);
  }

  /**
   * Prints the given string tree.
   *
   * @param printWriter the writer to be used to print the tree.
   * @param list a string tree, i.e., a string list that can contain other string lists, and so on
   *     recursively.
   */
  static void printList(final PrintWriter printWriter, final List<?> list) {
    for (Object o : list) {
      if (o instanceof List) {
        printList(printWriter, (List<?>) o);
      } else {
        printWriter.print(o.toString());
      }
    }
  }

  /**
   * Appends a quoted string to the given string builder.
   *
   * @param stringBuilder the buffer where the string must be added.
   * @param string the string to be added.
   */
  public static void appendString(final StringBuilder stringBuilder, final String string) {
    stringBuilder.append('\"');
    for (int i = 0; i < string.length(); ++i) {
      char c = string.charAt(i);
      if (c == '\n') {
        stringBuilder.append("\\n");
      } else if (c == '\r') {
        stringBuilder.append("\\r");
      } else if (c == '\\') {
        stringBuilder.append("\\\\");
      } else if (c == '"') {
        stringBuilder.append("\\\"");
      } else if (c < 0x20 || c > 0x7f) {
        stringBuilder.append("\\u");
        if (c < 0x10) {
          stringBuilder.append("000");
        } else if (c < 0x100) {
          stringBuilder.append("00");
        } else if (c < 0x1000) {
          stringBuilder.append('0');
        }
        stringBuilder.append(Integer.toString(c, 16));
      } else {
        stringBuilder.append(c);
      }
    }
    stringBuilder.append('\"');
  }

  /**
   * Prints the given class to the given output.
   *
   * <p>Command line arguments: [-nodebug] &lt;binary class name or class file name &gt;
   *
   * @param args the command line arguments.
   * @param usage the help message to show when command line arguments are incorrect.
   * @param printer the printer to convert the class into text.
   * @param output where to print the result.
   * @param logger where to log errors.
   * @throws IOException if the class cannot be found, or if an IOException occurs.
   */
  static void main(
      final String[] args,
      final String usage,
      final Printer printer,
      final PrintWriter output,
      final PrintWriter logger)
      throws IOException {
    if (args.length < 1
        || args.length > 2
        || ((args[0].equals("-debug") || args[0].equals("-nodebug")) && args.length != 2)) {
      logger.println(usage);
      return;
    }

    TraceClassVisitor traceClassVisitor = new TraceClassVisitor(null, printer, output);

    String className;
    int parsingOptions;
    if (args[0].equals("-nodebug")) {
      className = args[1];
      parsingOptions = ClassReader.SKIP_DEBUG;
    } else {
      className = args[0];
      parsingOptions = 0;
    }

    if (className.endsWith(".class")
        || className.indexOf('\\') != -1
        || className.indexOf('/') != -1) {
      // Can't fix PMD warning for 1.5 compatibility.
      try (InputStream inputStream = new FileInputStream(className)) { // NOPMD(AvoidFileStream)
        new ClassReader(inputStream).accept(traceClassVisitor, parsingOptions);
      }
    } else {
      new ClassReader(className).accept(traceClassVisitor, parsingOptions);
    }
  }
}

package org.objectweb.asm.util;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.Type;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TryCatchBlockNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.BasicValue;
import org.objectweb.asm.tree.analysis.Frame;
import org.objectweb.asm.tree.analysis.SimpleVerifier;

/**
 * A {@link ClassVisitor} that checks that its methods are properly used. More precisely this class
 * adapter checks each method call individually, based <i>only</i> on its arguments, but does
 * <i>not</i> check the <i>sequence</i> of method calls. For example, the invalid sequence {@code
 * visitField(ACC_PUBLIC, "i", "I", null)} {@code visitField(ACC_PUBLIC, "i", "D", null)} will
 * <i>not</i> be detected by this class adapter.
 *
 * <p><code>CheckClassAdapter</code> can be also used to verify bytecode transformations in order to
 * make sure that the transformed bytecode is sane. For example:
 *
 * <pre>
 * InputStream inputStream = ...; // get bytes for the source class
 * ClassReader classReader = new ClassReader(inputStream);
 * ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);
 * ClassVisitor classVisitor = new <b>MyClassAdapter</b>(new CheckClassAdapter(classWriter, true));
 * classReader.accept(classVisitor, 0);
 *
 * StringWriter stringWriter = new StringWriter();
 * PrintWriter printWriter = new PrintWriter(stringWriter);
 * CheckClassAdapter.verify(new ClassReader(classWriter.toByteArray()), false, printWriter);
 * assertTrue(stringWriter.toString().isEmpty());
 * </pre>
 *
 * <p>The above code pass the transformed bytecode through a <code>CheckClassAdapter</code>, with
 * data flow checks enabled. These checks are not exactly the same as the JVM verification, but
 * provide some basic type checking for each method instruction. If the bytecode has errors, the
 * output text shows the erroneous instruction number, and a dump of the failed method with
 * information about the type of the local variables and of the operand stack slots for each
 * instruction. For example (format is - insnNumber locals : stack):
 *
 * <pre>
 * org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 71: Expected I, but found .
 *   at org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:...)
 *   at org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:...)
 * ...
 * remove()V
 * 00000 LinkedBlockingQueue$Itr . . . . . . . .  : ICONST_0
 * 00001 LinkedBlockingQueue$Itr . . . . . . . .  : I ISTORE 2
 * 00001 LinkedBlockingQueue$Itr <b>.</b> I . . . . . .  :
 * ...
 * 00071 LinkedBlockingQueue$Itr <b>.</b> I . . . . . .  : ILOAD 1
 * 00072 <b>?</b> INVOKESPECIAL java/lang/Integer.&lt;init&gt; (I)V
 * ...
 * </pre>
 *
 * <p>The above output shows that the local variable 1, loaded by the <code>ILOAD 1</code>
 * instruction at position <code>00071</code> is not initialized, whereas the local variable 2 is
 * initialized and contains an int value.
 *
 * @author Eric Bruneton
 */
public class CheckClassAdapter extends ClassVisitor {

  /** The help message shown when command line arguments are incorrect. */
  private static final String USAGE =
      "Verifies the given class.\n"
          + "Usage: CheckClassAdapter <fully qualified class name or class file name>";

  private static final String ERROR_AT = ": error at index ";

  /** Whether the bytecode must be checked with a BasicVerifier. */
  private boolean checkDataFlow;

  /** The class version number. */
  private int version;

  /** Whether the {@link #visit} method has been called. */
  private boolean visitCalled;

  /** Whether the {@link #visitModule} method has been called. */
  private boolean visitModuleCalled;

  /** Whether the {@link #visitSource} method has been called. */
  private boolean visitSourceCalled;

  /** Whether the {@link #visitOuterClass} method has been called. */
  private boolean visitOuterClassCalled;

  /** Whether the {@link #visitNestHost} method has been called. */
  private boolean visitNestHostCalled;

  /**
   * The common package of all the nest members. Not {@literal null} if the visitNestMember method
   * has been called.
   */
  private String nestMemberPackageName;

  /** Whether the {@link #visitEnd} method has been called. */
  private boolean visitEndCalled;

  /** The index of the instruction designated by each visited label so far. */
  private Map<Label, Integer> labelInsnIndices;

  // -----------------------------------------------------------------------------------------------
  // Constructors
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link CheckClassAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
   *
   * @param classVisitor the class visitor to which this adapter must delegate calls.
   */
  public CheckClassAdapter(final ClassVisitor classVisitor) {
    this(classVisitor, /* checkDataFlow= */ true);
  }

  /**
   * Constructs a new {@link CheckClassAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
   *
   * @param classVisitor the class visitor to which this adapter must delegate calls.
   * @param checkDataFlow whether to perform basic data flow checks.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public CheckClassAdapter(final ClassVisitor classVisitor, final boolean checkDataFlow) {
    this(/* latest api = */ Opcodes.ASM9, classVisitor, checkDataFlow);
    if (getClass() != CheckClassAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link CheckClassAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param classVisitor the class visitor to which this adapter must delegate calls.
   * @param checkDataFlow {@literal true} to perform basic data flow checks, or {@literal false} to
   *     not perform any data flow check (see {@link CheckMethodAdapter}).
   */
  protected CheckClassAdapter(
      final int api, final ClassVisitor classVisitor, final boolean checkDataFlow) {
    super(api, classVisitor);
    this.labelInsnIndices = new HashMap<>();
    this.checkDataFlow = checkDataFlow;
  }

  // -----------------------------------------------------------------------------------------------
  // Implementation of the ClassVisitor interface
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visit(
      final int version,
      final int access,
      final @InternalForm String name, // might end with "package-info" or "module-info"
      final String signature,
      final @InternalForm String superName,
      final @InternalForm String[] interfaces) {
    if (visitCalled) {
      throw new IllegalStateException("visit must be called only once");
    }
    visitCalled = true;
    checkState();
    checkAccess(
        access,
        Opcodes.ACC_PUBLIC
            | Opcodes.ACC_FINAL
            | Opcodes.ACC_SUPER
            | Opcodes.ACC_INTERFACE
            | Opcodes.ACC_ABSTRACT
            | Opcodes.ACC_SYNTHETIC
            | Opcodes.ACC_ANNOTATION
            | Opcodes.ACC_ENUM
            | Opcodes.ACC_DEPRECATED
            | Opcodes.ACC_RECORD
            | Opcodes.ACC_MODULE);
    if (name == null) {
      throw new IllegalArgumentException("Illegal class name (null)");
    }
    if (!name.endsWith("package-info") && !name.endsWith("module-info")) {
      CheckMethodAdapter.checkInternalName(version, name, "class name");
    }
    if ("java/lang/Object".equals(name)) {
      if (superName != null) {
        throw new IllegalArgumentException(
            "The super class name of the Object class must be 'null'");
      }
    } else if (name.endsWith("module-info")) {
      if (superName != null) {
        throw new IllegalArgumentException(
            "The super class name of a module-info class must be 'null'");
      }
    } else {
      CheckMethodAdapter.checkInternalName(version, superName, "super class name");
    }
    if (signature != null) {
      checkClassSignature(signature);
    }
    if ((access & Opcodes.ACC_INTERFACE) != 0 && !"java/lang/Object".equals(superName)) {
      throw new IllegalArgumentException(
          "The super class name of interfaces must be 'java/lang/Object'");
    }
    if (interfaces != null) {
      for (int i = 0; i < interfaces.length; ++i) {
        CheckMethodAdapter.checkInternalName(
            version, interfaces[i], "interface name at index " + i);
      }
    }
    this.version = version;
    super.visit(version, access, name, signature, superName, interfaces);
  }

  @Override
  public void visitSource(final String file, final String debug) {
    checkState();
    if (visitSourceCalled) {
      throw new IllegalStateException("visitSource can be called only once.");
    }
    visitSourceCalled = true;
    super.visitSource(file, debug);
  }

  @Override
  public ModuleVisitor visitModule(final String name, final int access, final String version) {
    checkState();
    if (visitModuleCalled) {
      throw new IllegalStateException("visitModule can be called only once.");
    }
    visitModuleCalled = true;
    checkFullyQualifiedName(this.version, name, "module name");
    checkAccess(access, Opcodes.ACC_OPEN | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_MANDATED);
    CheckModuleAdapter checkModuleAdapter =
        new CheckModuleAdapter(
            api, super.visitModule(name, access, version), (access & Opcodes.ACC_OPEN) != 0);
    checkModuleAdapter.classVersion = this.version;
    return checkModuleAdapter;
  }

  @Override
  public void visitNestHost(final @InternalForm String nestHost) {
    checkState();
    CheckMethodAdapter.checkInternalName(version, nestHost, "nestHost");
    if (visitNestHostCalled) {
      throw new IllegalStateException("visitNestHost can be called only once.");
    }
    if (nestMemberPackageName != null) {
      throw new IllegalStateException("visitNestHost and visitNestMember are mutually exclusive.");
    }
    visitNestHostCalled = true;
    super.visitNestHost(nestHost);
  }

  @Override
  public void visitNestMember(final @InternalForm String nestMember) {
    checkState();
    CheckMethodAdapter.checkInternalName(version, nestMember, "nestMember");
    if (visitNestHostCalled) {
      throw new IllegalStateException(
          "visitMemberOfNest and visitNestHost are mutually exclusive.");
    }
    String packageName = packageName(nestMember);
    if (nestMemberPackageName == null) {
      nestMemberPackageName = packageName;
    } else if (!nestMemberPackageName.equals(packageName)) {
      throw new IllegalStateException(
          "nest member " + nestMember + " should be in the package " + nestMemberPackageName);
    }
    super.visitNestMember(nestMember);
  }

  @Override
  public void visitPermittedSubclass(final @InternalForm String permittedSubclass) {
    checkState();
    CheckMethodAdapter.checkInternalName(version, permittedSubclass, "permittedSubclass");
    super.visitPermittedSubclass(permittedSubclass);
  }

  @Override
  public void visitOuterClass(final @InternalForm String owner, final String name, final String descriptor) {
    checkState();
    if (visitOuterClassCalled) {
      throw new IllegalStateException("visitOuterClass can be called only once.");
    }
    visitOuterClassCalled = true;
    if (owner == null) {
      throw new IllegalArgumentException("Illegal outer class owner");
    }
    if (descriptor != null) {
      CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
    }
    super.visitOuterClass(owner, name, descriptor);
  }

  @Override
  public void visitInnerClass(
      final @InternalForm String name, final @InternalForm String outerName, final @Identifier String innerName, final int access) {
    checkState();
    CheckMethodAdapter.checkInternalName(version, name, "class name");
    if (outerName != null) {
      CheckMethodAdapter.checkInternalName(version, outerName, "outer class name");
    }
    if (innerName != null) {
      int startIndex = 0;
      while (startIndex < innerName.length() && Character.isDigit(innerName.charAt(startIndex))) {
        startIndex++;
      }
      if (startIndex == 0 || startIndex < innerName.length()) {
        CheckMethodAdapter.checkIdentifier(version, innerName, startIndex, -1, "inner class name");
      }
    }
    checkAccess(
        access,
        Opcodes.ACC_PUBLIC
            | Opcodes.ACC_PRIVATE
            | Opcodes.ACC_PROTECTED
            | Opcodes.ACC_STATIC
            | Opcodes.ACC_FINAL
            | Opcodes.ACC_INTERFACE
            | Opcodes.ACC_ABSTRACT
            | Opcodes.ACC_SYNTHETIC
            | Opcodes.ACC_ANNOTATION
            | Opcodes.ACC_ENUM);
    super.visitInnerClass(name, outerName, innerName, access);
  }

  @Override
  public RecordComponentVisitor visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    checkState();
    CheckMethodAdapter.checkUnqualifiedName(version, name, "record component name");
    CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid= */ false);
    if (signature != null) {
      checkFieldSignature(signature);
    }
    return new CheckRecordComponentAdapter(
        api, super.visitRecordComponent(name, descriptor, signature));
  }

  @Override
  public FieldVisitor visitField(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    checkState();
    checkAccess(
        access,
        Opcodes.ACC_PUBLIC
            | Opcodes.ACC_PRIVATE
            | Opcodes.ACC_PROTECTED
            | Opcodes.ACC_STATIC
            | Opcodes.ACC_FINAL
            | Opcodes.ACC_VOLATILE
            | Opcodes.ACC_TRANSIENT
            | Opcodes.ACC_SYNTHETIC
            | Opcodes.ACC_ENUM
            | Opcodes.ACC_MANDATED
            | Opcodes.ACC_DEPRECATED);
    CheckMethodAdapter.checkUnqualifiedName(version, name, "field name");
    CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid= */ false);
    if (signature != null) {
      checkFieldSignature(signature);
    }
    if (value != null) {
      CheckMethodAdapter.checkConstant(value);
    }
    return new CheckFieldAdapter(api, super.visitField(access, name, descriptor, signature, value));
  }

  @Override
  public MethodVisitor visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String[] exceptions) {
    checkState();
    checkMethodAccess(
        version,
        access,
        Opcodes.ACC_PUBLIC
            | Opcodes.ACC_PRIVATE
            | Opcodes.ACC_PROTECTED
            | Opcodes.ACC_STATIC
            | Opcodes.ACC_FINAL
            | Opcodes.ACC_SYNCHRONIZED
            | Opcodes.ACC_BRIDGE
            | Opcodes.ACC_VARARGS
            | Opcodes.ACC_NATIVE
            | Opcodes.ACC_ABSTRACT
            | Opcodes.ACC_STRICT
            | Opcodes.ACC_SYNTHETIC
            | Opcodes.ACC_MANDATED
            | Opcodes.ACC_DEPRECATED);
    if (!"<init>".equals(name) && !"<clinit>".equals(name)) {
      CheckMethodAdapter.checkMethodIdentifier(version, name, "method name");
    }
    CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
    if (signature != null) {
      checkMethodSignature(signature);
    }
    if (exceptions != null) {
      for (int i = 0; i < exceptions.length; ++i) {
        CheckMethodAdapter.checkInternalName(
            version, exceptions[i], "exception name at index " + i);
      }
    }
    CheckMethodAdapter checkMethodAdapter;
    MethodVisitor methodVisitor =
        super.visitMethod(access, name, descriptor, signature, exceptions);
    if (checkDataFlow) {
      if (cv instanceof ClassWriter) {
        methodVisitor =
            new CheckMethodAdapter.MethodWriterWrapper(
                api, version, (ClassWriter) cv, methodVisitor);
      }
      checkMethodAdapter =
          new CheckMethodAdapter(api, access, name, descriptor, methodVisitor, labelInsnIndices);
    } else {
      checkMethodAdapter = new CheckMethodAdapter(api, methodVisitor, labelInsnIndices);
    }
    checkMethodAdapter.version = version;
    return checkMethodAdapter;
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    checkState();
    CheckMethodAdapter.checkDescriptor(version, descriptor, false);
    return new CheckAnnotationAdapter(super.visitAnnotation(descriptor, visible));
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    checkState();
    int sort = new TypeReference(typeRef).getSort();
    if (sort != TypeReference.CLASS_TYPE_PARAMETER
        && sort != TypeReference.CLASS_TYPE_PARAMETER_BOUND
        && sort != TypeReference.CLASS_EXTENDS) {
      throw new IllegalArgumentException(
          "Invalid type reference sort 0x" + Integer.toHexString(sort));
    }
    checkTypeRef(typeRef);
    CheckMethodAdapter.checkDescriptor(version, descriptor, false);
    return new CheckAnnotationAdapter(
        super.visitTypeAnnotation(typeRef, typePath, descriptor, visible));
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    checkState();
    if (attribute == null) {
      throw new IllegalArgumentException("Invalid attribute (must not be null)");
    }
    super.visitAttribute(attribute);
  }

  @Override
  public void visitEnd() {
    checkState();
    visitEndCalled = true;
    super.visitEnd();
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /** Checks that the visit method has been called and that visitEnd has not been called. */
  private void checkState() {
    if (!visitCalled) {
      throw new IllegalStateException("Cannot visit member before visit has been called.");
    }
    if (visitEndCalled) {
      throw new IllegalStateException("Cannot visit member after visitEnd has been called.");
    }
  }

  /**
   * Checks that the given access flags do not contain invalid flags. This method also checks that
   * mutually incompatible flags are not set simultaneously.
   *
   * @param access the access flags to be checked.
   * @param possibleAccess the valid access flags.
   */
  static void checkAccess(final int access, final int possibleAccess) {
    if ((access & ~possibleAccess) != 0) {
      throw new IllegalArgumentException("Invalid access flags: " + access);
    }
    int publicProtectedPrivate = Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE;
    if (Integer.bitCount(access & publicProtectedPrivate) > 1) {
      throw new IllegalArgumentException(
          "public, protected and private are mutually exclusive: " + access);
    }
    if (Integer.bitCount(access & (Opcodes.ACC_FINAL | Opcodes.ACC_ABSTRACT)) > 1) {
      throw new IllegalArgumentException("final and abstract are mutually exclusive: " + access);
    }
  }

  /**
   * Checks that the given access flags do not contain invalid flags for a method. This method also
   * checks that mutually incompatible flags are not set simultaneously.
   *
   * @param version the class version.
   * @param access the method access flags to be checked.
   * @param possibleAccess the valid access flags.
   */
  private static void checkMethodAccess(
      final int version, final int access, final int possibleAccess) {
    checkAccess(access, possibleAccess);
    if ((version & 0xFFFF) < Opcodes.V17
        && Integer.bitCount(access & (Opcodes.ACC_STRICT | Opcodes.ACC_ABSTRACT)) > 1) {
      throw new IllegalArgumentException("strictfp and abstract are mutually exclusive: " + access);
    }
  }

  /**
   * Checks that the given name is a fully qualified name, using dots.
   *
   * @param version the class version.
   * @param name the name to be checked.
   * @param source the source of 'name' (e.g 'module' for a module name).
   */
  static void checkFullyQualifiedName(final int version, final String name, final String source) {
    try {
      int startIndex = 0;
      int dotIndex;
      while ((dotIndex = name.indexOf('.', startIndex + 1)) != -1) {
        CheckMethodAdapter.checkIdentifier(version, name, startIndex, dotIndex, null);
        startIndex = dotIndex + 1;
      }
      CheckMethodAdapter.checkIdentifier(version, name, startIndex, name.length(), null);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException(
          "Invalid " + source + " (must be a fully qualified name): " + name, e);
    }
  }

  /**
   * Checks a class signature.
   *
   * @param signature a string containing the signature that must be checked.
   */
  public static void checkClassSignature(final String signature) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // ClassSignature:
    //   [TypeParameters] SuperclassSignature SuperinterfaceSignature*
    // SuperclassSignature:
    //   ClassTypeSignature
    // SuperinterfaceSignature:
    //   ClassTypeSignature
    int pos = 0;
    if (getChar(signature, 0) == '<') {
      pos = checkTypeParameters(signature, pos);
    }
    pos = checkClassTypeSignature(signature, pos);
    while (getChar(signature, pos) == 'L') {
      pos = checkClassTypeSignature(signature, pos);
    }
    if (pos != signature.length()) {
      throw new IllegalArgumentException(signature + ERROR_AT + pos);
    }
  }

  /**
   * Checks a method signature.
   *
   * @param signature a string containing the signature that must be checked.
   */
  public static void checkMethodSignature(final String signature) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // MethodSignature:
    //   [TypeParameters] ( JavaTypeSignature* ) Result ThrowsSignature*
    // Result:
    //   JavaTypeSignature
    //   VoidDescriptor
    // ThrowsSignature:
    //   ^ ClassTypeSignature
    //   ^ TypeVariableSignature
    int pos = 0;
    if (getChar(signature, 0) == '<') {
      pos = checkTypeParameters(signature, pos);
    }
    pos = checkChar('(', signature, pos);
    while ("ZCBSIFJDL[T".indexOf(getChar(signature, pos)) != -1) {
      pos = checkJavaTypeSignature(signature, pos);
    }
    pos = checkChar(')', signature, pos);
    if (getChar(signature, pos) == 'V') {
      ++pos;
    } else {
      pos = checkJavaTypeSignature(signature, pos);
    }
    while (getChar(signature, pos) == '^') {
      ++pos;
      if (getChar(signature, pos) == 'L') {
        pos = checkClassTypeSignature(signature, pos);
      } else {
        pos = checkTypeVariableSignature(signature, pos);
      }
    }
    if (pos != signature.length()) {
      throw new IllegalArgumentException(signature + ERROR_AT + pos);
    }
  }

  /**
   * Checks a field signature.
   *
   * @param signature a string containing the signature that must be checked.
   */
  public static void checkFieldSignature(final String signature) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // FieldSignature:
    //   ReferenceTypeSignature
    int pos = checkReferenceTypeSignature(signature, 0);
    if (pos != signature.length()) {
      throw new IllegalArgumentException(signature + ERROR_AT + pos);
    }
  }

  /**
   * Checks the type parameters of a class or method signature.
   *
   * @param signature a string containing the signature that must be checked.
   * @param startPos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkTypeParameters(final String signature, final int startPos) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // TypeParameters:
    //   < TypeParameter TypeParameter* >
    int pos = startPos;
    pos = checkChar('<', signature, pos);
    pos = checkTypeParameter(signature, pos);
    while (getChar(signature, pos) != '>') {
      pos = checkTypeParameter(signature, pos);
    }
    return pos + 1;
  }

  /**
   * Checks a type parameter of a class or method signature.
   *
   * @param signature a string containing the signature that must be checked.
   * @param startPos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkTypeParameter(final String signature, final int startPos) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // TypeParameter:
    //   Identifier ClassBound InterfaceBound*
    // ClassBound:
    //   : [ReferenceTypeSignature]
    // InterfaceBound:
    //   : ReferenceTypeSignature
    int pos = startPos;
    pos = checkSignatureIdentifier(signature, pos);
    pos = checkChar(':', signature, pos);
    if ("L[T".indexOf(getChar(signature, pos)) != -1) {
      pos = checkReferenceTypeSignature(signature, pos);
    }
    while (getChar(signature, pos) == ':') {
      pos = checkReferenceTypeSignature(signature, pos + 1);
    }
    return pos;
  }

  /**
   * Checks a reference type signature.
   *
   * @param signature a string containing the signature that must be checked.
   * @param pos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkReferenceTypeSignature(final String signature, final int pos) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // ReferenceTypeSignature:
    //   ClassTypeSignature
    //   TypeVariableSignature
    //   ArrayTypeSignature
    // ArrayTypeSignature:
    //   [ JavaTypeSignature
    switch (getChar(signature, pos)) {
      case 'L':
        return checkClassTypeSignature(signature, pos);
      case '[':
        return checkJavaTypeSignature(signature, pos + 1);
      default:
        return checkTypeVariableSignature(signature, pos);
    }
  }

  /**
   * Checks a class type signature.
   *
   * @param signature a string containing the signature that must be checked.
   * @param startPos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkClassTypeSignature(final String signature, final int startPos) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // ClassTypeSignature:
    //   L [PackageSpecifier] SimpleClassTypeSignature ClassTypeSignatureSuffix* ;
    // PackageSpecifier:
    //   Identifier / PackageSpecifier*
    // SimpleClassTypeSignature:
    //   Identifier [TypeArguments]
    // ClassTypeSignatureSuffix:
    //   . SimpleClassTypeSignature
    int pos = startPos;
    pos = checkChar('L', signature, pos);
    pos = checkSignatureIdentifier(signature, pos);
    while (getChar(signature, pos) == '/') {
      pos = checkSignatureIdentifier(signature, pos + 1);
    }
    if (getChar(signature, pos) == '<') {
      pos = checkTypeArguments(signature, pos);
    }
    while (getChar(signature, pos) == '.') {
      pos = checkSignatureIdentifier(signature, pos + 1);
      if (getChar(signature, pos) == '<') {
        pos = checkTypeArguments(signature, pos);
      }
    }
    return checkChar(';', signature, pos);
  }

  /**
   * Checks the type arguments in a class type signature.
   *
   * @param signature a string containing the signature that must be checked.
   * @param startPos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkTypeArguments(final String signature, final int startPos) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // TypeArguments:
    //   < TypeArgument TypeArgument* >
    int pos = startPos;
    pos = checkChar('<', signature, pos);
    pos = checkTypeArgument(signature, pos);
    while (getChar(signature, pos) != '>') {
      pos = checkTypeArgument(signature, pos);
    }
    return pos + 1;
  }

  /**
   * Checks a type argument in a class type signature.
   *
   * @param signature a string containing the signature that must be checked.
   * @param startPos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkTypeArgument(final String signature, final int startPos) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // TypeArgument:
    //   [WildcardIndicator] ReferenceTypeSignature
    //   *
    // WildcardIndicator:
    //   +
    //   -
    int pos = startPos;
    char c = getChar(signature, pos);
    if (c == '*') {
      return pos + 1;
    } else if (c == '+' || c == '-') {
      pos++;
    }
    return checkReferenceTypeSignature(signature, pos);
  }

  /**
   * Checks a type variable signature.
   *
   * @param signature a string containing the signature that must be checked.
   * @param startPos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkTypeVariableSignature(final String signature, final int startPos) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // TypeVariableSignature:
    //  T Identifier ;
    int pos = startPos;
    pos = checkChar('T', signature, pos);
    pos = checkSignatureIdentifier(signature, pos);
    return checkChar(';', signature, pos);
  }

  /**
   * Checks a Java type signature.
   *
   * @param signature a string containing the signature that must be checked.
   * @param startPos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkJavaTypeSignature(final String signature, final int startPos) {
    // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
    // JavaTypeSignature:
    //   ReferenceTypeSignature
    //   BaseType
    // BaseType:
    //   (one of)
    //   B C D F I J S Z
    int pos = startPos;
    switch (getChar(signature, pos)) {
      case 'B':
      case 'C':
      case 'D':
      case 'F':
      case 'I':
      case 'J':
      case 'S':
      case 'Z':
        return pos + 1;
      default:
        return checkReferenceTypeSignature(signature, pos);
    }
  }

  /**
   * Checks an identifier.
   *
   * @param signature a string containing the signature that must be checked.
   * @param startPos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkSignatureIdentifier(final String signature, final int startPos) {
    int pos = startPos;
    while (pos < signature.length() && ".;[/<>:".indexOf(signature.codePointAt(pos)) == -1) {
      pos = signature.offsetByCodePoints(pos, 1);
    }
    if (pos == startPos) {
      throw new IllegalArgumentException(signature + ": identifier expected at index " + startPos);
    }
    return pos;
  }

  /**
   * Checks a single character.
   *
   * @param c a character.
   * @param signature a string containing the signature that must be checked.
   * @param pos index of first character to be checked.
   * @return the index of the first character after the checked part.
   */
  private static int checkChar(final char c, final String signature, final int pos) {
    if (getChar(signature, pos) == c) {
      return pos + 1;
    }
    throw new IllegalArgumentException(signature + ": '" + c + "' expected at index " + pos);
  }

  /**
   * Returns the string character at the given index, or 0.
   *
   * @param string a string.
   * @param pos an index in 'string'.
   * @return the character at the given index, or 0 if there is no such character.
   */
  private static char getChar(final String string, final int pos) {
    return pos < string.length() ? string.charAt(pos) : (char) 0;
  }

  /**
   * Checks the reference to a type in a type annotation.
   *
   * @param typeRef a reference to an annotated type.
   */
  static void checkTypeRef(final int typeRef) {
    int mask = 0;
    switch (typeRef >>> 24) {
      case TypeReference.CLASS_TYPE_PARAMETER:
      case TypeReference.METHOD_TYPE_PARAMETER:
      case TypeReference.METHOD_FORMAL_PARAMETER:
        mask = 0xFFFF0000;
        break;
      case TypeReference.FIELD:
      case TypeReference.METHOD_RETURN:
      case TypeReference.METHOD_RECEIVER:
      case TypeReference.LOCAL_VARIABLE:
      case TypeReference.RESOURCE_VARIABLE:
      case TypeReference.INSTANCEOF:
      case TypeReference.NEW:
      case TypeReference.CONSTRUCTOR_REFERENCE:
      case TypeReference.METHOD_REFERENCE:
        mask = 0xFF000000;
        break;
      case TypeReference.CLASS_EXTENDS:
      case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
      case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
      case TypeReference.THROWS:
      case TypeReference.EXCEPTION_PARAMETER:
        mask = 0xFFFFFF00;
        break;
      case TypeReference.CAST:
      case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
      case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
      case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
      case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
        mask = 0xFF0000FF;
        break;
      default:
        break;
    }
    if (mask == 0 || (typeRef & ~mask) != 0) {
      throw new IllegalArgumentException(
          "Invalid type reference 0x" + Integer.toHexString(typeRef));
    }
  }

  /**
   * Returns the package name of an internal name.
   *
   * @param name an internal name.
   * @return the package name or "" if there is no package.
   */
  private static String packageName(final @InternalForm String name) {
    int index = name.lastIndexOf('/');
    if (index == -1) {
      return "";
    }
    return name.substring(0, index);
  }

  // -----------------------------------------------------------------------------------------------
  // Static verification methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Checks the given class.
   *
   * <p>Usage: CheckClassAdapter &lt;binary class name or class file name&gt;
   *
   * @param args the command line arguments.
   * @throws IOException if the class cannot be found, or if an IO exception occurs.
   */
  public static void main(final String[] args) throws IOException {
    main(args, new PrintWriter(System.err, true));
  }

  /**
   * Checks the given class.
   *
   * @param args the command line arguments.
   * @param logger where to log errors.
   * @throws IOException if the class cannot be found, or if an IO exception occurs.
   */
  static void main(final String[] args, final PrintWriter logger) throws IOException {
    if (args.length != 1) {
      logger.println(USAGE);
      return;
    }

    ClassReader classReader;
    if (args[0].endsWith(".class")) {
      // Can't fix PMD warning for 1.5 compatibility.
      try (InputStream inputStream = new FileInputStream(args[0])) { // NOPMD(AvoidFileStream)
        classReader = new ClassReader(inputStream);
      }
    } else {
      classReader = new ClassReader(args[0]);
    }

    verify(classReader, false, logger);
  }

  /**
   * Checks the given class.
   *
   * @param classReader the class to be checked.
   * @param printResults whether to print the results of the bytecode verification.
   * @param printWriter where the results (or the stack trace in case of error) must be printed.
   */
  public static void verify(
      final ClassReader classReader, final boolean printResults, final PrintWriter printWriter) {
    verify(classReader, null, printResults, printWriter);
  }

  /**
   * Checks the given class.
   *
   * @param classReader the class to be checked.
   * @param loader a <code>ClassLoader</code> which will be used to load referenced classes. May be
   *     {@literal null}.
   * @param printResults whether to print the results of the bytecode verification.
   * @param printWriter where the results (or the stack trace in case of error) must be printed.
   */
  public static void verify(
      final ClassReader classReader,
      final ClassLoader loader,
      final boolean printResults,
      final PrintWriter printWriter) {
    ClassNode classNode = new ClassNode();
    classReader.accept(
        new CheckClassAdapter(/*latest*/ Opcodes.ASM9, classNode, false) {},
        ClassReader.SKIP_DEBUG);

    Type syperType = classNode.superName == null ? null : Type.getObjectType(classNode.superName);
    List<MethodNode> methods = classNode.methods;

    List<Type> interfaces = new ArrayList<>();
    for (String interfaceName : classNode.interfaces) {
      interfaces.add(Type.getObjectType(interfaceName));
    }

    for (MethodNode method : methods) {
      SimpleVerifier verifier =
          new SimpleVerifier(
              Type.getObjectType(classNode.name),
              syperType,
              interfaces,
              (classNode.access & Opcodes.ACC_INTERFACE) != 0);
      Analyzer<BasicValue> analyzer = new Analyzer<>(verifier);
      if (loader != null) {
        verifier.setClassLoader(loader);
      }
      try {
        analyzer.analyze(classNode.name, method);
      } catch (AnalyzerException e) {
        e.printStackTrace(printWriter);
      }
      if (printResults) {
        printAnalyzerResult(method, analyzer, printWriter);
      }
    }
    printWriter.flush();
  }

  static void printAnalyzerResult(
      final MethodNode method, final Analyzer<BasicValue> analyzer, final PrintWriter printWriter) {
    Textifier textifier = new Textifier();
    TraceMethodVisitor traceMethodVisitor = new TraceMethodVisitor(textifier);

    printWriter.println(method.name + method.desc);
    for (int i = 0; i < method.instructions.size(); ++i) {
      method.instructions.get(i).accept(traceMethodVisitor);

      StringBuilder stringBuilder = new StringBuilder();
      Frame<BasicValue> frame = analyzer.getFrames()[i];
      if (frame == null) {
        stringBuilder.append('?');
      } else {
        for (int j = 0; j < frame.getLocals(); ++j) {
          stringBuilder.append(getUnqualifiedName(frame.getLocal(j).toString())).append(' ');
        }
        stringBuilder.append(" : ");
        for (int j = 0; j < frame.getStackSize(); ++j) {
          stringBuilder.append(getUnqualifiedName(frame.getStack(j).toString())).append(' ');
        }
      }
      while (stringBuilder.length() < method.maxStack + method.maxLocals + 1) {
        stringBuilder.append(' ');
      }
      printWriter.print(Integer.toString(i + 100000).substring(1));
      printWriter.print(
          " " + stringBuilder + " : " + textifier.text.get(textifier.text.size() - 1));
    }
    for (TryCatchBlockNode tryCatchBlock : method.tryCatchBlocks) {
      tryCatchBlock.accept(traceMethodVisitor);
      printWriter.print(" " + textifier.text.get(textifier.text.size() - 1));
    }
    printWriter.println();
  }

  private static String getUnqualifiedName(final String name) {
    int lastSlashIndex = name.lastIndexOf('/');
    if (lastSlashIndex == -1) {
      return name;
    } else {
      int endIndex = name.length();
      if (name.charAt(endIndex - 1) == ';') {
        endIndex--;
      }
      int lastBracketIndex = name.lastIndexOf('[');
      if (lastBracketIndex == -1) {
        return name.substring(lastSlashIndex + 1, endIndex);
      }
      return name.substring(0, lastBracketIndex + 1) + name.substring(lastSlashIndex + 1, endIndex);
    }
  }
}

package org.objectweb.asm.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.analysis.Analyzer;
import org.objectweb.asm.tree.analysis.AnalyzerException;
import org.objectweb.asm.tree.analysis.BasicValue;
import org.objectweb.asm.tree.analysis.BasicVerifier;

/**
 * A {@link MethodVisitor} that checks that its methods are properly used. More precisely this
 * method adapter checks each instruction individually, i.e., each visit method checks some
 * preconditions based <i>only</i> on its arguments - such as the fact that the given opcode is
 * correct for a given visit method. This adapter can also perform some basic data flow checks (more
 * precisely those that can be performed without the full class hierarchy - see {@link
 * org.objectweb.asm.tree.analysis.BasicVerifier}). For instance in a method whose signature is
 * {@code void m ()}, the invalid instruction IRETURN, or the invalid sequence IADD L2I will be
 * detected if the data flow checks are enabled. These checks are enabled by using the {@link
 * #CheckMethodAdapter(int,String,String,MethodVisitor,Map)} constructor. They are not performed if
 * any other constructor is used.
 *
 * @author Eric Bruneton
 */
public class CheckMethodAdapter extends MethodVisitor {

  /** The 'generic' instruction visit methods (i.e. those that take an opcode argument). */
  private enum Method {
    VISIT_INSN,
    VISIT_INT_INSN,
    VISIT_VAR_INSN,
    VISIT_TYPE_INSN,
    VISIT_FIELD_INSN,
    VISIT_METHOD_INSN,
    VISIT_JUMP_INSN
  }

  /** The method to use to visit each instruction. Only generic methods are represented here. */
  private static final Method[] OPCODE_METHODS = {
    Method.VISIT_INSN, // NOP
    Method.VISIT_INSN, // ACONST_NULL
    Method.VISIT_INSN, // ICONST_M1
    Method.VISIT_INSN, // ICONST_0
    Method.VISIT_INSN, // ICONST_1
    Method.VISIT_INSN, // ICONST_2
    Method.VISIT_INSN, // ICONST_3
    Method.VISIT_INSN, // ICONST_4
    Method.VISIT_INSN, // ICONST_5
    Method.VISIT_INSN, // LCONST_0
    Method.VISIT_INSN, // LCONST_1
    Method.VISIT_INSN, // FCONST_0
    Method.VISIT_INSN, // FCONST_1
    Method.VISIT_INSN, // FCONST_2
    Method.VISIT_INSN, // DCONST_0
    Method.VISIT_INSN, // DCONST_1
    Method.VISIT_INT_INSN, // BIPUSH
    Method.VISIT_INT_INSN, // SIPUSH
    null, // LDC
    null, // LDC_W
    null, // LDC2_W
    Method.VISIT_VAR_INSN, // ILOAD
    Method.VISIT_VAR_INSN, // LLOAD
    Method.VISIT_VAR_INSN, // FLOAD
    Method.VISIT_VAR_INSN, // DLOAD
    Method.VISIT_VAR_INSN, // ALOAD
    null, // ILOAD_0
    null, // ILOAD_1
    null, // ILOAD_2
    null, // ILOAD_3
    null, // LLOAD_0
    null, // LLOAD_1
    null, // LLOAD_2
    null, // LLOAD_3
    null, // FLOAD_0
    null, // FLOAD_1
    null, // FLOAD_2
    null, // FLOAD_3
    null, // DLOAD_0
    null, // DLOAD_1
    null, // DLOAD_2
    null, // DLOAD_3
    null, // ALOAD_0
    null, // ALOAD_1
    null, // ALOAD_2
    null, // ALOAD_3
    Method.VISIT_INSN, // IALOAD
    Method.VISIT_INSN, // LALOAD
    Method.VISIT_INSN, // FALOAD
    Method.VISIT_INSN, // DALOAD
    Method.VISIT_INSN, // AALOAD
    Method.VISIT_INSN, // BALOAD
    Method.VISIT_INSN, // CALOAD
    Method.VISIT_INSN, // SALOAD
    Method.VISIT_VAR_INSN, // ISTORE
    Method.VISIT_VAR_INSN, // LSTORE
    Method.VISIT_VAR_INSN, // FSTORE
    Method.VISIT_VAR_INSN, // DSTORE
    Method.VISIT_VAR_INSN, // ASTORE
    null, // ISTORE_0
    null, // ISTORE_1
    null, // ISTORE_2
    null, // ISTORE_3
    null, // LSTORE_0
    null, // LSTORE_1
    null, // LSTORE_2
    null, // LSTORE_3
    null, // FSTORE_0
    null, // FSTORE_1
    null, // FSTORE_2
    null, // FSTORE_3
    null, // DSTORE_0
    null, // DSTORE_1
    null, // DSTORE_2
    null, // DSTORE_3
    null, // ASTORE_0
    null, // ASTORE_1
    null, // ASTORE_2
    null, // ASTORE_3
    Method.VISIT_INSN, // IASTORE
    Method.VISIT_INSN, // LASTORE
    Method.VISIT_INSN, // FASTORE
    Method.VISIT_INSN, // DASTORE
    Method.VISIT_INSN, // AASTORE
    Method.VISIT_INSN, // BASTORE
    Method.VISIT_INSN, // CASTORE
    Method.VISIT_INSN, // SASTORE
    Method.VISIT_INSN, // POP
    Method.VISIT_INSN, // POP2
    Method.VISIT_INSN, // DUP
    Method.VISIT_INSN, // DUP_X1
    Method.VISIT_INSN, // DUP_X2
    Method.VISIT_INSN, // DUP2
    Method.VISIT_INSN, // DUP2_X1
    Method.VISIT_INSN, // DUP2_X2
    Method.VISIT_INSN, // SWAP
    Method.VISIT_INSN, // IADD
    Method.VISIT_INSN, // LADD
    Method.VISIT_INSN, // FADD
    Method.VISIT_INSN, // DADD
    Method.VISIT_INSN, // ISUB
    Method.VISIT_INSN, // LSUB
    Method.VISIT_INSN, // FSUB
    Method.VISIT_INSN, // DSUB
    Method.VISIT_INSN, // IMUL
    Method.VISIT_INSN, // LMUL
    Method.VISIT_INSN, // FMUL
    Method.VISIT_INSN, // DMUL
    Method.VISIT_INSN, // IDIV
    Method.VISIT_INSN, // LDIV
    Method.VISIT_INSN, // FDIV
    Method.VISIT_INSN, // DDIV
    Method.VISIT_INSN, // IREM
    Method.VISIT_INSN, // LREM
    Method.VISIT_INSN, // FREM
    Method.VISIT_INSN, // DREM
    Method.VISIT_INSN, // INEG
    Method.VISIT_INSN, // LNEG
    Method.VISIT_INSN, // FNEG
    Method.VISIT_INSN, // DNEG
    Method.VISIT_INSN, // ISHL
    Method.VISIT_INSN, // LSHL
    Method.VISIT_INSN, // ISHR
    Method.VISIT_INSN, // LSHR
    Method.VISIT_INSN, // IUSHR
    Method.VISIT_INSN, // LUSHR
    Method.VISIT_INSN, // IAND
    Method.VISIT_INSN, // LAND
    Method.VISIT_INSN, // IOR
    Method.VISIT_INSN, // LOR
    Method.VISIT_INSN, // IXOR
    Method.VISIT_INSN, // LXOR
    null, // IINC
    Method.VISIT_INSN, // I2L
    Method.VISIT_INSN, // I2F
    Method.VISIT_INSN, // I2D
    Method.VISIT_INSN, // L2I
    Method.VISIT_INSN, // L2F
    Method.VISIT_INSN, // L2D
    Method.VISIT_INSN, // F2I
    Method.VISIT_INSN, // F2L
    Method.VISIT_INSN, // F2D
    Method.VISIT_INSN, // D2I
    Method.VISIT_INSN, // D2L
    Method.VISIT_INSN, // D2F
    Method.VISIT_INSN, // I2B
    Method.VISIT_INSN, // I2C
    Method.VISIT_INSN, // I2S
    Method.VISIT_INSN, // LCMP
    Method.VISIT_INSN, // FCMPL
    Method.VISIT_INSN, // FCMPG
    Method.VISIT_INSN, // DCMPL
    Method.VISIT_INSN, // DCMPG
    Method.VISIT_JUMP_INSN, // IFEQ
    Method.VISIT_JUMP_INSN, // IFNE
    Method.VISIT_JUMP_INSN, // IFLT
    Method.VISIT_JUMP_INSN, // IFGE
    Method.VISIT_JUMP_INSN, // IFGT
    Method.VISIT_JUMP_INSN, // IFLE
    Method.VISIT_JUMP_INSN, // IF_ICMPEQ
    Method.VISIT_JUMP_INSN, // IF_ICMPNE
    Method.VISIT_JUMP_INSN, // IF_ICMPLT
    Method.VISIT_JUMP_INSN, // IF_ICMPGE
    Method.VISIT_JUMP_INSN, // IF_ICMPGT
    Method.VISIT_JUMP_INSN, // IF_ICMPLE
    Method.VISIT_JUMP_INSN, // IF_ACMPEQ
    Method.VISIT_JUMP_INSN, // IF_ACMPNE
    Method.VISIT_JUMP_INSN, // GOTO
    Method.VISIT_JUMP_INSN, // JSR
    Method.VISIT_VAR_INSN, // RET
    null, // TABLESWITCH
    null, // LOOKUPSWITCH
    Method.VISIT_INSN, // IRETURN
    Method.VISIT_INSN, // LRETURN
    Method.VISIT_INSN, // FRETURN
    Method.VISIT_INSN, // DRETURN
    Method.VISIT_INSN, // ARETURN
    Method.VISIT_INSN, // RETURN
    Method.VISIT_FIELD_INSN, // GETSTATIC
    Method.VISIT_FIELD_INSN, // PUTSTATIC
    Method.VISIT_FIELD_INSN, // GETFIELD
    Method.VISIT_FIELD_INSN, // PUTFIELD
    Method.VISIT_METHOD_INSN, // INVOKEVIRTUAL
    Method.VISIT_METHOD_INSN, // INVOKESPECIAL
    Method.VISIT_METHOD_INSN, // INVOKESTATIC
    Method.VISIT_METHOD_INSN, // INVOKEINTERFACE
    null, // INVOKEDYNAMIC
    Method.VISIT_TYPE_INSN, // NEW
    Method.VISIT_INT_INSN, // NEWARRAY
    Method.VISIT_TYPE_INSN, // ANEWARRAY
    Method.VISIT_INSN, // ARRAYLENGTH
    Method.VISIT_INSN, // ATHROW
    Method.VISIT_TYPE_INSN, // CHECKCAST
    Method.VISIT_TYPE_INSN, // INSTANCEOF
    Method.VISIT_INSN, // MONITORENTER
    Method.VISIT_INSN, // MONITOREXIT
    null, // WIDE
    null, // MULTIANEWARRAY
    Method.VISIT_JUMP_INSN, // IFNULL
    Method.VISIT_JUMP_INSN // IFNONNULL
  };

  private static final String INVALID = "Invalid ";
  private static final String INVALID_DESCRIPTOR = "Invalid descriptor: ";
  private static final String INVALID_TYPE_REFERENCE = "Invalid type reference sort 0x";
  private static final String INVALID_LOCAL_VARIABLE_INDEX = "Invalid local variable index";
  private static final String MUST_NOT_BE_NULL_OR_EMPTY = " (must not be null or empty)";
  private static final String START_LABEL = "start label";
  private static final String END_LABEL = "end label";

  /** The class version number. */
  public int version;

  /** The access flags of the visited method. */
  private int access;

  /**
   * The number of method parameters that can have runtime visible annotations. 0 means that all the
   * parameters from the method descriptor can have annotations.
   */
  private int visibleAnnotableParameterCount;

  /**
   * The number of method parameters that can have runtime invisible annotations. 0 means that all
   * the parameters from the method descriptor can have annotations.
   */
  private int invisibleAnnotableParameterCount;

  /** Whether the {@link #visitCode} method has been called. */
  private boolean visitCodeCalled;

  /** Whether the {@link #visitMaxs} method has been called. */
  private boolean visitMaxCalled;

  /** Whether the {@link #visitEnd} method has been called. */
  private boolean visitEndCalled;

  /** The number of visited instructions so far. */
  private int insnCount;

  /** The index of the instruction designated by each visited label. */
  private final Map<Label, Integer> labelInsnIndices;

  /** The labels referenced by the visited method. */
  private Set<Label> referencedLabels;

  /** The index of the instruction corresponding to the last visited stack map frame. */
  private int lastFrameInsnIndex = -1;

  /** The number of visited frames in expanded form. */
  private int numExpandedFrames;

  /** The number of visited frames in compressed form. */
  private int numCompressedFrames;

  /**
   * The exception handler ranges. Each pair of list element contains the start and end labels of an
   * exception handler block.
   */
  private List<Label> handlers;

  /**
   * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
   * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
   * <i>Subclasses must not use this constructor</i>. Instead, they must use the {@link
   * #CheckMethodAdapter(int, MethodVisitor, Map)} version.
   *
   * @param methodvisitor the method visitor to which this adapter must delegate calls.
   */
  public CheckMethodAdapter(final MethodVisitor methodvisitor) {
    this(methodvisitor, new HashMap<>());
  }

  /**
   * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
   * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
   * <i>Subclasses must not use this constructor</i>. Instead, they must use the {@link
   * #CheckMethodAdapter(int, MethodVisitor, Map)} version.
   *
   * @param methodVisitor the method visitor to which this adapter must delegate calls.
   * @param labelInsnIndices the index of the instruction designated by each visited label so far
   *     (in other methods). This map is updated with the labels from the visited method.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public CheckMethodAdapter(
      final MethodVisitor methodVisitor, final Map<Label, Integer> labelInsnIndices) {
    this(/* latest api = */ Opcodes.ASM9, methodVisitor, labelInsnIndices);
    if (getClass() != CheckMethodAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
   * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
   *
   * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of the
   *     {@code ASM}<i>x</i> values in {@link Opcodes}.
   * @param methodVisitor the method visitor to which this adapter must delegate calls.
   * @param labelInsnIndices the index of the instruction designated by each visited label so far
   *     (in other methods). This map is updated with the labels from the visited method.
   */
  protected CheckMethodAdapter(
      final int api,
      final MethodVisitor methodVisitor,
      final Map<Label, Integer> labelInsnIndices) {
    super(api, methodVisitor);
    this.labelInsnIndices = labelInsnIndices;
    this.referencedLabels = new HashSet<>();
    this.handlers = new ArrayList<>();
  }

  /**
   * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
   * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
   * instruction IRETURN, or the invalid sequence IADD L2I will be detected. <i>Subclasses must not
   * use this constructor</i>. Instead, they must use the {@link
   * #CheckMethodAdapter(int,int,String,String,MethodVisitor,Map)} version.
   *
   * @param access the method's access flags.
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param methodVisitor the method visitor to which this adapter must delegate calls.
   * @param labelInsnIndices the index of the instruction designated by each visited label so far
   *     (in other methods). This map is updated with the labels from the visited method.
   */
  public CheckMethodAdapter(
      final int access,
      final String name,
      final String descriptor,
      final MethodVisitor methodVisitor,
      final Map<Label, Integer> labelInsnIndices) {
    this(
        /* latest api = */ Opcodes.ASM9, access, name, descriptor, methodVisitor, labelInsnIndices);
    if (getClass() != CheckMethodAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
   * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
   * instruction IRETURN, or the invalid sequence IADD L2I will be detected.
   *
   * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of the
   *     {@code ASM}<i>x</i> values in {@link Opcodes}.
   * @param access the method's access flags.
   * @param name the method's name.
   * @param descriptor the method's descriptor (see {@link Type}).
   * @param methodVisitor the method visitor to which this adapter must delegate calls.
   * @param labelInsnIndices the index of the instruction designated by each visited label so far
   *     (in other methods). This map is updated with the labels from the visited method.
   */
  protected CheckMethodAdapter(
      final int api,
      final int access,
      final String name,
      final String descriptor,
      final MethodVisitor methodVisitor,
      final Map<Label, Integer> labelInsnIndices) {
    this(
        api,
        new MethodNode(api, access, name, descriptor, null, null) {
          @Override
          public void visitEnd() {
            int originalMaxLocals = maxLocals;
            int originalMaxStack = maxStack;
            boolean checkMaxStackAndLocals = false;
            boolean checkFrames = false;
            if (methodVisitor instanceof MethodWriterWrapper) {
              MethodWriterWrapper methodWriter = (MethodWriterWrapper) methodVisitor;
              // If 'methodVisitor' is a MethodWriter of a ClassWriter with no flags to compute the
              // max stack and locals nor the stack map frames, we know that valid max stack and
              // locals must be provided. Otherwise we assume they are not needed at this stage.
              checkMaxStackAndLocals = !methodWriter.computesMaxs();
              // If 'methodVisitor' is a MethodWriter of a ClassWriter with no flags to compute the
              // stack map frames, we know that valid frames must be provided. Otherwise we assume
              // they are not needed at this stage.
              checkFrames = methodWriter.requiresFrames() && !methodWriter.computesFrames();
            }
            Analyzer<BasicValue> analyzer =
                checkFrames
                    ? new CheckFrameAnalyzer<>(new BasicVerifier())
                    : new Analyzer<>(new BasicVerifier());
            try {
              if (checkMaxStackAndLocals) {
                analyzer.analyze("dummy", this);
              } else {
                analyzer.analyzeAndComputeMaxs("dummy", this);
              }
            } catch (IndexOutOfBoundsException | AnalyzerException e) {
              throwError(analyzer, e);
            }
            if (methodVisitor != null) {
              maxLocals = originalMaxLocals;
              maxStack = originalMaxStack;
              accept(methodVisitor);
            }
          }

          private void throwError(final Analyzer<BasicValue> analyzer, final Exception e) {
            StringWriter stringWriter = new StringWriter();
            PrintWriter printWriter = new PrintWriter(stringWriter, true);
            CheckClassAdapter.printAnalyzerResult(this, analyzer, printWriter);
            printWriter.close();
            throw new IllegalArgumentException(e.getMessage() + ' ' + stringWriter.toString(), e);
          }
        },
        labelInsnIndices);
    this.access = access;
  }

  @Override
  public void visitParameter(final String name, final int access) {
    if (name != null) {
      checkUnqualifiedName(version, name, "name");
    }
    CheckClassAdapter.checkAccess(
        access, Opcodes.ACC_FINAL | Opcodes.ACC_MANDATED | Opcodes.ACC_SYNTHETIC);
    super.visitParameter(name, access);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    checkVisitEndNotCalled();
    checkDescriptor(version, descriptor, false);
    return new CheckAnnotationAdapter(super.visitAnnotation(descriptor, visible));
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    checkVisitEndNotCalled();
    int sort = new TypeReference(typeRef).getSort();
    if (sort != TypeReference.METHOD_TYPE_PARAMETER
        && sort != TypeReference.METHOD_TYPE_PARAMETER_BOUND
        && sort != TypeReference.METHOD_RETURN
        && sort != TypeReference.METHOD_RECEIVER
        && sort != TypeReference.METHOD_FORMAL_PARAMETER
        && sort != TypeReference.THROWS) {
      throw new IllegalArgumentException(INVALID_TYPE_REFERENCE + Integer.toHexString(sort));
    }
    CheckClassAdapter.checkTypeRef(typeRef);
    CheckMethodAdapter.checkDescriptor(version, descriptor, false);
    return new CheckAnnotationAdapter(
        super.visitTypeAnnotation(typeRef, typePath, descriptor, visible));
  }

  @Override
  public AnnotationVisitor visitAnnotationDefault() {
    checkVisitEndNotCalled();
    return new CheckAnnotationAdapter(super.visitAnnotationDefault(), false);
  }

  @Override
  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    checkVisitEndNotCalled();
    if (visible) {
      visibleAnnotableParameterCount = parameterCount;
    } else {
      invisibleAnnotableParameterCount = parameterCount;
    }
    super.visitAnnotableParameterCount(parameterCount, visible);
  }

  @Override
  public AnnotationVisitor visitParameterAnnotation(
      final int parameter, final String descriptor, final boolean visible) {
    checkVisitEndNotCalled();
    if ((visible
            && visibleAnnotableParameterCount > 0
            && parameter >= visibleAnnotableParameterCount)
        || (!visible
            && invisibleAnnotableParameterCount > 0
            && parameter >= invisibleAnnotableParameterCount)) {
      throw new IllegalArgumentException("Invalid parameter index");
    }
    checkDescriptor(version, descriptor, false);
    return new CheckAnnotationAdapter(
        super.visitParameterAnnotation(parameter, descriptor, visible));
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    checkVisitEndNotCalled();
    if (attribute == null) {
      throw new IllegalArgumentException("Invalid attribute (must not be null)");
    }
    super.visitAttribute(attribute);
  }

  @Override
  public void visitCode() {
    if ((access & Opcodes.ACC_ABSTRACT) != 0) {
      throw new UnsupportedOperationException("Abstract methods cannot have code");
    }
    visitCodeCalled = true;
    super.visitCode();
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    if (insnCount == lastFrameInsnIndex) {
      throw new IllegalStateException("At most one frame can be visited at a given code location.");
    }
    lastFrameInsnIndex = insnCount;
    int maxNumLocal;
    int maxNumStack;
    switch (type) {
      case Opcodes.F_NEW:
      case Opcodes.F_FULL:
        maxNumLocal = Integer.MAX_VALUE;
        maxNumStack = Integer.MAX_VALUE;
        break;

      case Opcodes.F_SAME:
        maxNumLocal = 0;
        maxNumStack = 0;
        break;

      case Opcodes.F_SAME1:
        maxNumLocal = 0;
        maxNumStack = 1;
        break;

      case Opcodes.F_APPEND:
      case Opcodes.F_CHOP:
        maxNumLocal = 3;
        maxNumStack = 0;
        break;

      default:
        throw new IllegalArgumentException("Invalid frame type " + type);
    }

    if (numLocal > maxNumLocal) {
      throw new IllegalArgumentException(
          "Invalid numLocal=" + numLocal + " for frame type " + type);
    }
    if (numStack > maxNumStack) {
      throw new IllegalArgumentException(
          "Invalid numStack=" + numStack + " for frame type " + type);
    }

    if (type != Opcodes.F_CHOP) {
      if (numLocal > 0 && (local == null || local.length < numLocal)) {
        throw new IllegalArgumentException("Array local[] is shorter than numLocal");
      }
      for (int i = 0; i < numLocal; ++i) {
        checkFrameValue(local[i]);
      }
    }
    if (numStack > 0 && (stack == null || stack.length < numStack)) {
      throw new IllegalArgumentException("Array stack[] is shorter than numStack");
    }
    for (int i = 0; i < numStack; ++i) {
      checkFrameValue(stack[i]);
    }
    if (type == Opcodes.F_NEW) {
      ++numExpandedFrames;
    } else {
      ++numCompressedFrames;
    }
    if (numExpandedFrames > 0 && numCompressedFrames > 0) {
      throw new IllegalArgumentException("Expanded and compressed frames must not be mixed.");
    }
    super.visitFrame(type, numLocal, local, numStack, stack);
  }

  @Override
  public void visitInsn(final int opcode) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkOpcodeMethod(opcode, Method.VISIT_INSN);
    super.visitInsn(opcode);
    ++insnCount;
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkOpcodeMethod(opcode, Method.VISIT_INT_INSN);
    switch (opcode) {
      case Opcodes.BIPUSH:
        checkSignedByte(operand, "Invalid operand");
        break;
      case Opcodes.SIPUSH:
        checkSignedShort(operand, "Invalid operand");
        break;
      case Opcodes.NEWARRAY:
        if (operand < Opcodes.T_BOOLEAN || operand > Opcodes.T_LONG) {
          throw new IllegalArgumentException(
              "Invalid operand (must be an array type code T_...): " + operand);
        }
        break;
      default:
        throw new AssertionError();
    }
    super.visitIntInsn(opcode, operand);
    ++insnCount;
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkOpcodeMethod(opcode, Method.VISIT_VAR_INSN);
    checkUnsignedShort(varIndex, INVALID_LOCAL_VARIABLE_INDEX);
    super.visitVarInsn(opcode, varIndex);
    ++insnCount;
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkOpcodeMethod(opcode, Method.VISIT_TYPE_INSN);
    checkInternalName(version, type, "type");
    if (opcode == Opcodes.NEW && type.charAt(0) == '[') {
      throw new IllegalArgumentException("NEW cannot be used to create arrays: " + type);
    }
    super.visitTypeInsn(opcode, type);
    ++insnCount;
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkOpcodeMethod(opcode, Method.VISIT_FIELD_INSN);
    checkInternalName(version, owner, "owner");
    checkUnqualifiedName(version, name, "name");
    checkDescriptor(version, descriptor, false);
    super.visitFieldInsn(opcode, owner, name, descriptor);
    ++insnCount;
  }

  @Override
  public void visitMethodInsn(
      final int opcodeAndSource,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
      // Redirect the call to the deprecated version of this method.
      super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
      return;
    }
    int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;

    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkOpcodeMethod(opcode, Method.VISIT_METHOD_INSN);
    if (opcode != Opcodes.INVOKESPECIAL || !"<init>".equals(name)) {
      checkMethodIdentifier(version, name, "name");
    }
    checkInternalName(version, owner, "owner");
    checkMethodDescriptor(version, descriptor);
    if (opcode == Opcodes.INVOKEVIRTUAL && isInterface) {
      throw new IllegalArgumentException("INVOKEVIRTUAL can't be used with interfaces");
    }
    if (opcode == Opcodes.INVOKEINTERFACE && !isInterface) {
      throw new IllegalArgumentException("INVOKEINTERFACE can't be used with classes");
    }
    if (opcode == Opcodes.INVOKESPECIAL && isInterface && (version & 0xFFFF) < Opcodes.V1_8) {
      throw new IllegalArgumentException(
          "INVOKESPECIAL can't be used with interfaces prior to Java 8");
    }
    super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
    ++insnCount;
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkMethodIdentifier(version, name, "name");
    checkMethodDescriptor(version, descriptor);
    if (bootstrapMethodHandle.getTag() != Opcodes.H_INVOKESTATIC
        && bootstrapMethodHandle.getTag() != Opcodes.H_NEWINVOKESPECIAL) {
      throw new IllegalArgumentException("invalid handle tag " + bootstrapMethodHandle.getTag());
    }
    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {
      checkLdcConstant(bootstrapMethodArgument);
    }
    super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
    ++insnCount;
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkOpcodeMethod(opcode, Method.VISIT_JUMP_INSN);
    checkLabel(label, /* checkVisited= */ false, "label");
    super.visitJumpInsn(opcode, label);
    ++insnCount;
  }

  @Override
  public void visitLabel(final Label label) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkLabel(label, /* checkVisited= */ false, "label");
    if (labelInsnIndices.get(label) != null) {
      throw new IllegalStateException("Already visited label");
    }
    labelInsnIndices.put(label, insnCount);
    super.visitLabel(label);
  }

  @Override
  public void visitLdcInsn(final Object value) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkLdcConstant(value);
    super.visitLdcInsn(value);
    ++insnCount;
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkUnsignedShort(varIndex, INVALID_LOCAL_VARIABLE_INDEX);
    checkSignedShort(increment, "Invalid increment");
    super.visitIincInsn(varIndex, increment);
    ++insnCount;
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    if (max < min) {
      throw new IllegalArgumentException(
          "Max = " + max + " must be greater than or equal to min = " + min);
    }
    checkLabel(dflt, /* checkVisited= */ false, "default label");
    if (labels == null || labels.length != max - min + 1) {
      throw new IllegalArgumentException("There must be max - min + 1 labels");
    }
    for (int i = 0; i < labels.length; ++i) {
      checkLabel(labels[i], /* checkVisited= */ false, "label at index " + i);
    }
    super.visitTableSwitchInsn(min, max, dflt, labels);
    ++insnCount;
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    checkVisitMaxsNotCalled();
    checkVisitCodeCalled();
    checkLabel(dflt, /* checkVisited= */ false, "default label");
    if (keys == null || labels == null || keys.length != labels.length) {
      throw new IllegalArgumentException("There must be the same number of keys and labels");
    }
    for (int i = 0; i < labels.length; ++i) {
      checkLabel(labels[i], /* checkVisited= */ false, "label at index " + i);
    }
    super.visitLookupSwitchInsn(dflt, keys, labels);
    ++insnCount;
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkDescriptor(version, descriptor, false);
    if (descriptor.charAt(0) != '[') {
      throw new IllegalArgumentException(
          "Invalid descriptor (must be an array type descriptor): " + descriptor);
    }
    if (numDimensions < 1) {
      throw new IllegalArgumentException(
          "Invalid dimensions (must be greater than 0): " + numDimensions);
    }
    if (numDimensions > descriptor.lastIndexOf('[') + 1) {
      throw new IllegalArgumentException(
          "Invalid dimensions (must not be greater than numDimensions(descriptor)): "
              + numDimensions);
    }
    super.visitMultiANewArrayInsn(descriptor, numDimensions);
    ++insnCount;
  }

  @Override
  public AnnotationVisitor visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    int sort = new TypeReference(typeRef).getSort();
    if (sort != TypeReference.INSTANCEOF
        && sort != TypeReference.NEW
        && sort != TypeReference.CONSTRUCTOR_REFERENCE
        && sort != TypeReference.METHOD_REFERENCE
        && sort != TypeReference.CAST
        && sort != TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
        && sort != TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT
        && sort != TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
        && sort != TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT) {
      throw new IllegalArgumentException(INVALID_TYPE_REFERENCE + Integer.toHexString(sort));
    }
    CheckClassAdapter.checkTypeRef(typeRef);
    CheckMethodAdapter.checkDescriptor(version, descriptor, false);
    return new CheckAnnotationAdapter(
        super.visitInsnAnnotation(typeRef, typePath, descriptor, visible));
  }

  @Override
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @Nullable @InternalForm String type) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkLabel(start, /* checkVisited= */ false, START_LABEL);
    checkLabel(end, /* checkVisited= */ false, END_LABEL);
    checkLabel(handler, /* checkVisited= */ false, "handler label");
    if (labelInsnIndices.get(start) != null
        || labelInsnIndices.get(end) != null
        || labelInsnIndices.get(handler) != null) {
      throw new IllegalStateException("Try catch blocks must be visited before their labels");
    }
    if (type != null) {
      checkInternalName(version, type, "type");
    }
    super.visitTryCatchBlock(start, end, handler, type);
    handlers.add(start);
    handlers.add(end);
  }

  @Override
  public AnnotationVisitor visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    int sort = new TypeReference(typeRef).getSort();
    if (sort != TypeReference.EXCEPTION_PARAMETER) {
      throw new IllegalArgumentException(INVALID_TYPE_REFERENCE + Integer.toHexString(sort));
    }
    CheckClassAdapter.checkTypeRef(typeRef);
    CheckMethodAdapter.checkDescriptor(version, descriptor, false);
    return new CheckAnnotationAdapter(
        super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible));
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkUnqualifiedName(version, name, "name");
    checkDescriptor(version, descriptor, false);
    if (signature != null) {
      CheckClassAdapter.checkFieldSignature(signature);
    }
    checkLabel(start, /* checkVisited= */ true, START_LABEL);
    checkLabel(end, /* checkVisited= */ true, END_LABEL);
    checkUnsignedShort(index, INVALID_LOCAL_VARIABLE_INDEX);
    int startInsnIndex = labelInsnIndices.get(start).intValue();
    int endInsnIndex = labelInsnIndices.get(end).intValue();
    if (endInsnIndex < startInsnIndex) {
      throw new IllegalArgumentException(
          "Invalid start and end labels (end must be greater than start)");
    }
    super.visitLocalVariable(name, descriptor, signature, start, end, index);
  }

  @Override
  public AnnotationVisitor visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    int sort = new TypeReference(typeRef).getSort();
    if (sort != TypeReference.LOCAL_VARIABLE && sort != TypeReference.RESOURCE_VARIABLE) {
      throw new IllegalArgumentException(INVALID_TYPE_REFERENCE + Integer.toHexString(sort));
    }
    CheckClassAdapter.checkTypeRef(typeRef);
    checkDescriptor(version, descriptor, false);
    if (start == null
        || end == null
        || index == null
        || end.length != start.length
        || index.length != start.length) {
      throw new IllegalArgumentException(
          "Invalid start, end and index arrays (must be non null and of identical length");
    }
    for (int i = 0; i < start.length; ++i) {
      checkLabel(start[i], /* checkVisited= */ true, START_LABEL);
      checkLabel(end[i], /* checkVisited= */ true, END_LABEL);
      checkUnsignedShort(index[i], INVALID_LOCAL_VARIABLE_INDEX);
      int startInsnIndex = labelInsnIndices.get(start[i]).intValue();
      int endInsnIndex = labelInsnIndices.get(end[i]).intValue();
      if (endInsnIndex < startInsnIndex) {
        throw new IllegalArgumentException(
            "Invalid start and end labels (end must be greater than start)");
      }
    }
    return super.visitLocalVariableAnnotation(
        typeRef, typePath, start, end, index, descriptor, visible);
  }

  @Override
  public void visitLineNumber(final int line, final Label start) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    checkUnsignedShort(line, "Invalid line number");
    checkLabel(start, /* checkVisited= */ true, START_LABEL);
    super.visitLineNumber(line, start);
  }

  @Override
  public void visitMaxs(final int maxStack, final int maxLocals) {
    checkVisitCodeCalled();
    checkVisitMaxsNotCalled();
    visitMaxCalled = true;
    for (Label l : referencedLabels) {
      if (labelInsnIndices.get(l) == null) {
        throw new IllegalStateException("Undefined label used");
      }
    }
    for (int i = 0; i < handlers.size(); i += 2) {
      Integer startInsnIndex = labelInsnIndices.get(handlers.get(i));
      Integer endInsnIndex = labelInsnIndices.get(handlers.get(i + 1));
      if (endInsnIndex.intValue() <= startInsnIndex.intValue()) {
        throw new IllegalStateException("Empty try catch block handler range");
      }
    }
    checkUnsignedShort(maxStack, "Invalid max stack");
    checkUnsignedShort(maxLocals, "Invalid max locals");
    super.visitMaxs(maxStack, maxLocals);
  }

  @Override
  public void visitEnd() {
    checkVisitEndNotCalled();
    visitEndCalled = true;
    super.visitEnd();
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /** Checks that the {@link #visitCode} method has been called. */
  private void checkVisitCodeCalled() {
    if (!visitCodeCalled) {
      throw new IllegalStateException(
          "Cannot visit instructions before visitCode has been called.");
    }
  }

  /** Checks that the {@link #visitMaxs} method has not been called. */
  private void checkVisitMaxsNotCalled() {
    if (visitMaxCalled) {
      throw new IllegalStateException("Cannot visit instructions after visitMaxs has been called.");
    }
  }

  /** Checks that the {@link #visitEnd} method has not been called. */
  private void checkVisitEndNotCalled() {
    if (visitEndCalled) {
      throw new IllegalStateException("Cannot visit elements after visitEnd has been called.");
    }
  }

  /**
   * Checks a stack frame value.
   *
   * @param value the value to be checked.
   */
  private void checkFrameValue(final Object value) {
    if (value == Opcodes.TOP
        || value == Opcodes.INTEGER
        || value == Opcodes.FLOAT
        || value == Opcodes.LONG
        || value == Opcodes.DOUBLE
        || value == Opcodes.NULL
        || value == Opcodes.UNINITIALIZED_THIS) {
      return;
    }
    if (value instanceof String) {
      checkInternalName(version, (String) value, "Invalid stack frame value");
    } else if (value instanceof Label) {
      checkLabel((Label) value, /* checkVisited= */ false, "label");
    } else {
      throw new IllegalArgumentException("Invalid stack frame value: " + value);
    }
  }

  /**
   * Checks that the method to visit the given opcode is equal to the given method.
   *
   * @param opcode the opcode to be checked.
   * @param method the expected visit method.
   */
  private static void checkOpcodeMethod(final int opcode, final Method method) {
    if (opcode < Opcodes.NOP || opcode > Opcodes.IFNONNULL) {
      throw new IllegalArgumentException("Invalid opcode: " + opcode);
    }
    if (OPCODE_METHODS[opcode] != method) {
      throw new IllegalArgumentException(
          "Invalid combination of opcode and method: " + opcode + ", " + method);
    }
  }

  /**
   * Checks that the given value is a signed byte.
   *
   * @param value the value to be checked.
   * @param message the message to use in case of error.
   */
  private static void checkSignedByte(final int value, final String message) {
    if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {
      throw new IllegalArgumentException(message + " (must be a signed byte): " + value);
    }
  }

  /**
   * Checks that the given value is a signed short.
   *
   * @param value the value to be checked.
   * @param message the message to use in case of error.
   */
  private static void checkSignedShort(final int value, final String message) {
    if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
      throw new IllegalArgumentException(message + " (must be a signed short): " + value);
    }
  }

  /**
   * Checks that the given value is an unsigned short.
   *
   * @param value the value to be checked.
   * @param message the message to use in case of error.
   */
  private static void checkUnsignedShort(final int value, final String message) {
    if (value < 0 || value > 65535) {
      throw new IllegalArgumentException(message + " (must be an unsigned short): " + value);
    }
  }

  /**
   * Checks that the given value is an {@link Integer}, {@link Float}, {@link Long}, {@link Double}
   * or {@link String} value.
   *
   * @param value the value to be checked.
   */
  static void checkConstant(final Object value) {
    if (!(value instanceof Integer)
        && !(value instanceof Float)
        && !(value instanceof Long)
        && !(value instanceof Double)
        && !(value instanceof String)) {
      throw new IllegalArgumentException("Invalid constant: " + value);
    }
  }

  /**
   * Checks that the given value is a valid operand for the LDC instruction.
   *
   * @param value the value to be checked.
   */
  private void checkLdcConstant(final Object value) {
    if (value instanceof Type) {
      int sort = ((Type) value).getSort();
      if (sort != Type.OBJECT && sort != Type.ARRAY && sort != Type.METHOD) {
        throw new IllegalArgumentException("Illegal LDC constant value");
      }
      if (sort != Type.METHOD && (version & 0xFFFF) < Opcodes.V1_5) {
        throw new IllegalArgumentException("ldc of a constant class requires at least version 1.5");
      }
      if (sort == Type.METHOD && (version & 0xFFFF) < Opcodes.V1_7) {
        throw new IllegalArgumentException("ldc of a method type requires at least version 1.7");
      }
    } else if (value instanceof Handle) {
      if ((version & 0xFFFF) < Opcodes.V1_7) {
        throw new IllegalArgumentException("ldc of a Handle requires at least version 1.7");
      }
      Handle handle = (Handle) value;
      int tag = handle.getTag();
      if (tag < Opcodes.H_GETFIELD || tag > Opcodes.H_INVOKEINTERFACE) {
        throw new IllegalArgumentException("invalid handle tag " + tag);
      }
      checkInternalName(this.version, handle.getOwner(), "handle owner");
      if (tag <= Opcodes.H_PUTSTATIC) {
        checkDescriptor(this.version, handle.getDesc(), false);
      } else {
        checkMethodDescriptor(this.version, handle.getDesc());
      }
      String handleName = handle.getName();
      if (!("<init>".equals(handleName) && tag == Opcodes.H_NEWINVOKESPECIAL)) {
        checkMethodIdentifier(this.version, handleName, "handle name");
      }
    } else if (value instanceof ConstantDynamic) {
      if ((version & 0xFFFF) < Opcodes.V11) {
        throw new IllegalArgumentException("ldc of a ConstantDynamic requires at least version 11");
      }
      ConstantDynamic constantDynamic = (ConstantDynamic) value;
      checkMethodIdentifier(this.version, constantDynamic.getName(), "constant dynamic name");
      checkDescriptor(this.version, constantDynamic.getDescriptor(), false);
      checkLdcConstant(constantDynamic.getBootstrapMethod());
      int bootstrapMethodArgumentCount = constantDynamic.getBootstrapMethodArgumentCount();
      for (int i = 0; i < bootstrapMethodArgumentCount; ++i) {
        checkLdcConstant(constantDynamic.getBootstrapMethodArgument(i));
      }
    } else {
      checkConstant(value);
    }
  }

  /**
   * Checks that the given string is a valid unqualified name.
   *
   * @param version the class version.
   * @param name the string to be checked.
   * @param message the message to use in case of error.
   */
  static void checkUnqualifiedName(final int version, final String name, final String message) {
    checkIdentifier(version, name, 0, -1, message);
  }

  /**
   * Checks that the given substring is a valid Java identifier.
   *
   * @param version the class version.
   * @param name the string to be checked.
   * @param startPos the index of the first character of the identifier (inclusive).
   * @param endPos the index of the last character of the identifier (exclusive). -1 is equivalent
   *     to {@code name.length()} if name is not {@literal null}.
   * @param message the message to use in case of error.
   */
  static void checkIdentifier(
      final int version,
      final String name,
      final int startPos,
      final int endPos,
      final String message) {
    if (name == null || (endPos == -1 ? name.length() <= startPos : endPos <= startPos)) {
      throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
    }
    int max = endPos == -1 ? name.length() : endPos;
    if ((version & 0xFFFF) >= Opcodes.V1_5) {
      for (int i = startPos; i < max; i = name.offsetByCodePoints(i, 1)) {
        if (".;[/".indexOf(name.codePointAt(i)) != -1) {
          throw new IllegalArgumentException(
              INVALID + message + " (must not contain . ; [ or /): " + name);
        }
      }
      return;
    }
    for (int i = startPos; i < max; i = name.offsetByCodePoints(i, 1)) {
      if (i == startPos
          ? !Character.isJavaIdentifierStart(name.codePointAt(i))
          : !Character.isJavaIdentifierPart(name.codePointAt(i))) {
        throw new IllegalArgumentException(
            INVALID + message + " (must be a valid Java identifier): " + name);
      }
    }
  }

  /**
   * Checks that the given string is a valid Java identifier.
   *
   * @param version the class version.
   * @param name the string to be checked.
   * @param message the message to use in case of error.
   */
  static void checkMethodIdentifier(final int version, final String name, final String message) {
    if (name == null || name.length() == 0) {
      throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
    }
    if ((version & 0xFFFF) >= Opcodes.V1_5) {
      for (int i = 0; i < name.length(); i = name.offsetByCodePoints(i, 1)) {
        if (".;[/<>".indexOf(name.codePointAt(i)) != -1) {
          throw new IllegalArgumentException(
              INVALID + message + " (must be a valid unqualified name): " + name);
        }
      }
      return;
    }
    for (int i = 0; i < name.length(); i = name.offsetByCodePoints(i, 1)) {
      if (i == 0
          ? !Character.isJavaIdentifierStart(name.codePointAt(i))
          : !Character.isJavaIdentifierPart(name.codePointAt(i))) {
        throw new IllegalArgumentException(
            INVALID
                + message
                + " (must be a '<init>', '<clinit>' or a valid Java identifier): "
                + name);
      }
    }
  }

  /**
   * Checks that the given string is a valid internal class name or array type descriptor.
   *
   * @param version the class version.
   * @param name the string to be checked.
   * @param message the message to use in case of error.
   */
  static void checkInternalName(final int version, final @InternalForm String name, final String message) {
    if (name == null || name.length() == 0) {
      throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
    }
    if (name.charAt(0) == '[') {
      checkDescriptor(version, name, false);
    } else {
      checkInternalClassName(version, name, message);
    }
  }

  /**
   * Checks that the given string is a valid internal class name.
   *
   * @param version the class version.
   * @param name the string to be checked.
   * @param message the message to use in case of error.
   */
  private static void checkInternalClassName(
      final int version, final String name, final String message) {
    try {
      int startIndex = 0;
      int slashIndex;
      while ((slashIndex = name.indexOf('/', startIndex + 1)) != -1) {
        checkIdentifier(version, name, startIndex, slashIndex, null);
        startIndex = slashIndex + 1;
      }
      checkIdentifier(version, name, startIndex, name.length(), null);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException(
          INVALID + message + " (must be an internal class name): " + name, e);
    }
  }

  /**
   * Checks that the given string is a valid type descriptor.
   *
   * @param version the class version.
   * @param descriptor the string to be checked.
   * @param canBeVoid {@literal true} if {@code V} can be considered valid.
   */
  static void checkDescriptor(final int version, final String descriptor, final boolean canBeVoid) {
    int endPos = checkDescriptor(version, descriptor, 0, canBeVoid);
    if (endPos != descriptor.length()) {
      throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
    }
  }

  /**
   * Checks that the given substring is a valid type descriptor.
   *
   * @param version the class version.
   * @param descriptor the string to be checked.
   * @param startPos the index of the first character of the type descriptor (inclusive).
   * @param canBeVoid whether {@code V} can be considered valid.
   * @return the index of the last character of the type descriptor, plus one.
   */
  private static int checkDescriptor(
      final int version, final String descriptor, final int startPos, final boolean canBeVoid) {
    if (descriptor == null || startPos >= descriptor.length()) {
      throw new IllegalArgumentException("Invalid type descriptor (must not be null or empty)");
    }
    switch (descriptor.charAt(startPos)) {
      case 'V':
        if (canBeVoid) {
          return startPos + 1;
        } else {
          throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
        }
      case 'Z':
      case 'C':
      case 'B':
      case 'S':
      case 'I':
      case 'F':
      case 'J':
      case 'D':
        return startPos + 1;
      case '[':
        int pos = startPos + 1;
        while (pos < descriptor.length() && descriptor.charAt(pos) == '[') {
          ++pos;
        }
        if (pos < descriptor.length()) {
          return checkDescriptor(version, descriptor, pos, false);
        } else {
          throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
        }
      case 'L':
        int endPos = descriptor.indexOf(';', startPos);
        if (startPos == -1 || endPos - startPos < 2) {
          throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
        }
        try {
          checkInternalClassName(version, descriptor.substring(startPos + 1, endPos), null);
        } catch (IllegalArgumentException e) {
          throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor, e);
        }
        return endPos + 1;
      default:
        throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
    }
  }

  /**
   * Checks that the given string is a valid method descriptor.
   *
   * @param version the class version.
   * @param descriptor the string to be checked.
   */
  static void checkMethodDescriptor(final int version, final String descriptor) {
    if (descriptor == null || descriptor.length() == 0) {
      throw new IllegalArgumentException("Invalid method descriptor (must not be null or empty)");
    }
    if (descriptor.charAt(0) != '(' || descriptor.length() < 3) {
      throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
    }
    int pos = 1;
    if (descriptor.charAt(pos) != ')') {
      do {
        if (descriptor.charAt(pos) == 'V') {
          throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
        }
        pos = checkDescriptor(version, descriptor, pos, false);
      } while (pos < descriptor.length() && descriptor.charAt(pos) != ')');
    }
    pos = checkDescriptor(version, descriptor, pos + 1, true);
    if (pos != descriptor.length()) {
      throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
    }
  }

  /**
   * Checks that the given label is not null. This method can also check that the label has been
   * visited.
   *
   * @param label the label to be checked.
   * @param checkVisited whether to check that the label has been visited.
   * @param message the message to use in case of error.
   */
  private void checkLabel(final Label label, final boolean checkVisited, final String message) {
    if (label == null) {
      throw new IllegalArgumentException(INVALID + message + " (must not be null)");
    }
    if (checkVisited && labelInsnIndices.get(label) == null) {
      throw new IllegalArgumentException(INVALID + message + " (must be visited first)");
    }
    referencedLabels.add(label);
  }

  static class MethodWriterWrapper extends MethodVisitor {

    /** The class version number. */
    private final int version;

    private final ClassWriter owner;

    MethodWriterWrapper(
        final int api,
        final int version,
        final ClassWriter owner,
        final MethodVisitor methodWriter) {
      super(api, methodWriter);
      this.version = version;
      this.owner = owner;
    }

    boolean computesMaxs() {
      return owner.hasFlags(ClassWriter.COMPUTE_MAXS) || owner.hasFlags(ClassWriter.COMPUTE_FRAMES);
    }

    boolean computesFrames() {
      return owner.hasFlags(ClassWriter.COMPUTE_FRAMES);
    }

    boolean requiresFrames() {
      return (version & 0xFFFF) >= Opcodes.V1_7;
    }
  }
}

package org.objectweb.asm.util;

import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A {@link ModuleVisitor} that prints the fields it visits with a {@link Printer}.
 *
 * @author Remi Forax
 */
public final class TraceModuleVisitor extends ModuleVisitor {

  /** The printer to convert the visited module into text. */
  // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
  public final Printer p;

  /**
   * Constructs a new {@link TraceModuleVisitor}.
   *
   * @param printer the printer to convert the visited module into text.
   */
  public TraceModuleVisitor(final Printer printer) {
    this(null, printer);
  }

  /**
   * Constructs a new {@link TraceModuleVisitor}.
   *
   * @param moduleVisitor the module visitor to which to delegate calls. May be {@literal null}.
   * @param printer the printer to convert the visited module into text.
   */
  public TraceModuleVisitor(final ModuleVisitor moduleVisitor, final Printer printer) {
    super(/* latest api = */ Opcodes.ASM9, moduleVisitor);
    this.p = printer;
  }

  @Override
  public void visitMainClass(final String mainClass) {
    p.visitMainClass(mainClass);
    super.visitMainClass(mainClass);
  }

  @Override
  public void visitPackage(final String packaze) {
    p.visitPackage(packaze);
    super.visitPackage(packaze);
  }

  @Override
  public void visitRequire(final String module, final int access, final String version) {
    p.visitRequire(module, access, version);
    super.visitRequire(module, access, version);
  }

  @Override
  public void visitExport(final String packaze, final int access, final String... modules) {
    p.visitExport(packaze, access, modules);
    super.visitExport(packaze, access, modules);
  }

  @Override
  public void visitOpen(final String packaze, final int access, final String... modules) {
    p.visitOpen(packaze, access, modules);
    super.visitOpen(packaze, access, modules);
  }

  @Override
  public void visitUse(final String use) {
    p.visitUse(use);
    super.visitUse(use);
  }

  @Override
  public void visitProvide(final String service, final String... providers) {
    p.visitProvide(service, providers);
    super.visitProvide(service, providers);
  }

  @Override
  public void visitEnd() {
    p.visitModuleEnd();
    super.visitEnd();
  }
}

package org.objectweb.asm.util;

import java.util.HashSet;
import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;

/**
 * A {@link ModuleVisitor} that checks that its methods are properly used.
 *
 * @author Remi Forax
 */
public class CheckModuleAdapter extends ModuleVisitor {
  /** Whether the visited module is open. */
  private final boolean isOpen;

  /** The fully qualified names of the dependencies of the visited module. */
  private final NameSet requiredModules = new NameSet("Modules requires");

  /** The internal names of the packages exported by the visited module. */
  private final NameSet exportedPackages = new NameSet("Module exports");

  /** The internal names of the packages opened by the visited module. */
  private final NameSet openedPackages = new NameSet("Module opens");

  /** The internal names of the services used by the visited module. */
  private final NameSet usedServices = new NameSet("Module uses");

  /** The internal names of the services provided by the visited module. */
  private final NameSet providedServices = new NameSet("Module provides");

  /** The class version number. */
  int classVersion;

  /** Whether the {@link #visitEnd} method has been called. */
  private boolean visitEndCalled;

  /**
   * Constructs a new {@link CheckModuleAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #CheckModuleAdapter(int, ModuleVisitor, boolean)} version.
   *
   * @param moduleVisitor the module visitor to which this adapter must delegate calls.
   * @param isOpen whether the visited module is open. Open modules have their {@link
   *     Opcodes#ACC_OPEN} access flag set in {@link org.objectweb.asm.ClassVisitor#visitModule}.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public CheckModuleAdapter(final ModuleVisitor moduleVisitor, final boolean isOpen) {
    this(/* latest api = */ Opcodes.ASM9, moduleVisitor, isOpen);
    if (getClass() != CheckModuleAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link CheckModuleAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param moduleVisitor the module visitor to which this adapter must delegate calls.
   * @param isOpen whether the visited module is open. Open modules have their {@link
   *     Opcodes#ACC_OPEN} access flag set in {@link org.objectweb.asm.ClassVisitor#visitModule}.
   */
  protected CheckModuleAdapter(
      final int api, final ModuleVisitor moduleVisitor, final boolean isOpen) {
    super(api, moduleVisitor);
    this.isOpen = isOpen;
  }

  @Override
  public void visitMainClass(final @InternalForm String mainClass) {
    // Modules can only appear in V9 or more classes.
    CheckMethodAdapter.checkInternalName(Opcodes.V9, mainClass, "module main class");
    super.visitMainClass(mainClass);
  }

  @Override
  public void visitPackage(final String packaze) {
    CheckMethodAdapter.checkInternalName(Opcodes.V9, packaze, "module package");
    super.visitPackage(packaze);
  }

  @Override
  public void visitRequire(final String module, final int access, final String version) {
    checkVisitEndNotCalled();
    CheckClassAdapter.checkFullyQualifiedName(Opcodes.V9, module, "required module");
    requiredModules.checkNameNotAlreadyDeclared(module);
    CheckClassAdapter.checkAccess(
        access,
        Opcodes.ACC_STATIC_PHASE
            | Opcodes.ACC_TRANSITIVE
            | Opcodes.ACC_SYNTHETIC
            | Opcodes.ACC_MANDATED);
    if (classVersion >= Opcodes.V10
        && module.equals("java.base")
        && (access & (Opcodes.ACC_STATIC_PHASE | Opcodes.ACC_TRANSITIVE)) != 0) {
      throw new IllegalArgumentException(
          "Invalid access flags: "
              + access
              + " java.base can not be declared ACC_TRANSITIVE or ACC_STATIC_PHASE");
    }
    super.visitRequire(module, access, version);
  }

  @Override
  public void visitExport(final String packaze, final int access, final String... modules) {
    checkVisitEndNotCalled();
    CheckMethodAdapter.checkInternalName(Opcodes.V9, packaze, "package name");
    exportedPackages.checkNameNotAlreadyDeclared(packaze);
    CheckClassAdapter.checkAccess(access, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_MANDATED);
    if (modules != null) {
      for (String module : modules) {
        CheckClassAdapter.checkFullyQualifiedName(Opcodes.V9, module, "module export to");
      }
    }
    super.visitExport(packaze, access, modules);
  }

  @Override
  public void visitOpen(final String packaze, final int access, final String... modules) {
    checkVisitEndNotCalled();
    if (isOpen) {
      throw new UnsupportedOperationException("An open module can not use open directive");
    }
    CheckMethodAdapter.checkInternalName(Opcodes.V9, packaze, "package name");
    openedPackages.checkNameNotAlreadyDeclared(packaze);
    CheckClassAdapter.checkAccess(access, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_MANDATED);
    if (modules != null) {
      for (String module : modules) {
        CheckClassAdapter.checkFullyQualifiedName(Opcodes.V9, module, "module open to");
      }
    }
    super.visitOpen(packaze, access, modules);
  }

  @Override
  public void visitUse(final @InternalForm String service) {
    checkVisitEndNotCalled();
    CheckMethodAdapter.checkInternalName(Opcodes.V9, service, "service");
    usedServices.checkNameNotAlreadyDeclared(service);
    super.visitUse(service);
  }

  @Override
  public void visitProvide(final @InternalForm String service, final @InternalForm String... providers) {
    checkVisitEndNotCalled();
    CheckMethodAdapter.checkInternalName(Opcodes.V9, service, "service");
    providedServices.checkNameNotAlreadyDeclared(service);
    if (providers == null || providers.length == 0) {
      throw new IllegalArgumentException("Providers cannot be null or empty");
    }
    for (String provider : providers) {
      CheckMethodAdapter.checkInternalName(Opcodes.V9, provider, "provider");
    }
    super.visitProvide(service, providers);
  }

  @Override
  public void visitEnd() {
    checkVisitEndNotCalled();
    visitEndCalled = true;
    super.visitEnd();
  }

  private void checkVisitEndNotCalled() {
    if (visitEndCalled) {
      throw new IllegalStateException("Cannot call a visit method after visitEnd has been called");
    }
  }

  private static class NameSet {

    private final String type; // The purpose of the NameSet; NOT a Java type.
    private final HashSet<@InternalForm String> names;

    NameSet(final String type) {
      this.type = type;
      this.names = new HashSet<>();
    }

    void checkNameNotAlreadyDeclared(final @InternalForm String name) {
      if (!names.add(name)) {
        throw new IllegalArgumentException(type + " '" + name + "' already declared");
      }
    }
  }
}

package org.objectweb.asm.util;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;

/**
 * A {@link FieldVisitor} that prints the fields it visits with a {@link Printer}.
 *
 * @author Eric Bruneton
 */
public final class TraceFieldVisitor extends FieldVisitor {

  /** The printer to convert the visited field into text. */
  // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
  public final Printer p;

  /**
   * Constructs a new {@link TraceFieldVisitor}.
   *
   * @param printer the printer to convert the visited field into text.
   */
  public TraceFieldVisitor(final Printer printer) {
    this(null, printer);
  }

  /**
   * Constructs a new {@link TraceFieldVisitor}.
   *
   * @param fieldVisitor the field visitor to which to delegate calls. May be {@literal null}.
   * @param printer the printer to convert the visited field into text.
   */
  public TraceFieldVisitor(final FieldVisitor fieldVisitor, final Printer printer) {
    super(/* latest api = */ Opcodes.ASM9, fieldVisitor);
    this.p = printer;
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitFieldAnnotation(descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitAnnotation(descriptor, visible), annotationPrinter);
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitFieldTypeAnnotation(typeRef, typePath, descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitTypeAnnotation(typeRef, typePath, descriptor, visible), annotationPrinter);
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    p.visitFieldAttribute(attribute);
    super.visitAttribute(attribute);
  }

  @Override
  public void visitEnd() {
    p.visitFieldEnd();
    super.visitEnd();
  }
}

package org.objectweb.asm.util;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;

/**
 * A {@link MethodVisitor} that prints the methods it visits with a {@link Printer}.
 *
 * @author Eric Bruneton
 */
public final class TraceMethodVisitor extends MethodVisitor {

  /** The printer to convert the visited method into text. */
  // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
  public final Printer p;

  /**
   * Constructs a new {@link TraceMethodVisitor}.
   *
   * @param printer the printer to convert the visited method into text.
   */
  public TraceMethodVisitor(final Printer printer) {
    this(null, printer);
  }

  /**
   * Constructs a new {@link TraceMethodVisitor}.
   *
   * @param methodVisitor the method visitor to which to delegate calls. May be {@literal null}.
   * @param printer the printer to convert the visited method into text.
   */
  public TraceMethodVisitor(final MethodVisitor methodVisitor, final Printer printer) {
    super(/* latest api = */ Opcodes.ASM9, methodVisitor);
    this.p = printer;
  }

  @Override
  public void visitParameter(final String name, final int access) {
    p.visitParameter(name, access);
    super.visitParameter(name, access);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitMethodAnnotation(descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitAnnotation(descriptor, visible), annotationPrinter);
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitMethodTypeAnnotation(typeRef, typePath, descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitTypeAnnotation(typeRef, typePath, descriptor, visible), annotationPrinter);
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    p.visitMethodAttribute(attribute);
    super.visitAttribute(attribute);
  }

  @Override
  public AnnotationVisitor visitAnnotationDefault() {
    Printer annotationPrinter = p.visitAnnotationDefault();
    return new TraceAnnotationVisitor(super.visitAnnotationDefault(), annotationPrinter);
  }

  @Override
  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    p.visitAnnotableParameterCount(parameterCount, visible);
    super.visitAnnotableParameterCount(parameterCount, visible);
  }

  @Override
  public AnnotationVisitor visitParameterAnnotation(
      final int parameter, final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitParameterAnnotation(parameter, descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitParameterAnnotation(parameter, descriptor, visible), annotationPrinter);
  }

  @Override
  public void visitCode() {
    p.visitCode();
    super.visitCode();
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    p.visitFrame(type, numLocal, local, numStack, stack);
    super.visitFrame(type, numLocal, local, numStack, stack);
  }

  @Override
  public void visitInsn(final int opcode) {
    p.visitInsn(opcode);
    super.visitInsn(opcode);
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    p.visitIntInsn(opcode, operand);
    super.visitIntInsn(opcode, operand);
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    p.visitVarInsn(opcode, varIndex);
    super.visitVarInsn(opcode, varIndex);
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    p.visitTypeInsn(opcode, type);
    super.visitTypeInsn(opcode, type);
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    p.visitFieldInsn(opcode, owner, name, descriptor);
    super.visitFieldInsn(opcode, owner, name, descriptor);
  }

  @Override
  @SuppressWarnings("deprecation")
  public void visitMethodInsn(
      final int opcode,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    // Call the method that p is supposed to implement, depending on its api version.
    if (p.api < Opcodes.ASM5) {
      if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {
        throw new IllegalArgumentException("INVOKESPECIAL/STATIC on interfaces require ASM5");
      }
      // If p is an ASMifier (resp. Textifier), or a subclass that does not override the old
      // visitMethodInsn method, the default implementation in Printer will redirect this to the
      // new method in ASMifier (resp. Textifier). In all other cases, p overrides the old method
      // and this call executes it.
      p.visitMethodInsn(opcode, owner, name, descriptor);
    } else {
      p.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
    }
    if (mv != null) {
      mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
    }
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    p.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
    super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    p.visitJumpInsn(opcode, label);
    super.visitJumpInsn(opcode, label);
  }

  @Override
  public void visitLabel(final Label label) {
    p.visitLabel(label);
    super.visitLabel(label);
  }

  @Override
  public void visitLdcInsn(final Object value) {
    p.visitLdcInsn(value);
    super.visitLdcInsn(value);
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    p.visitIincInsn(varIndex, increment);
    super.visitIincInsn(varIndex, increment);
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    p.visitTableSwitchInsn(min, max, dflt, labels);
    super.visitTableSwitchInsn(min, max, dflt, labels);
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    p.visitLookupSwitchInsn(dflt, keys, labels);
    super.visitLookupSwitchInsn(dflt, keys, labels);
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    p.visitMultiANewArrayInsn(descriptor, numDimensions);
    super.visitMultiANewArrayInsn(descriptor, numDimensions);
  }

  @Override
  public AnnotationVisitor visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitInsnAnnotation(typeRef, typePath, descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitInsnAnnotation(typeRef, typePath, descriptor, visible), annotationPrinter);
  }

  @Override
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @InternalForm String type) {
    p.visitTryCatchBlock(start, end, handler, type);
    super.visitTryCatchBlock(start, end, handler, type);
  }

  @Override
  public AnnotationVisitor visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible), annotationPrinter);
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    p.visitLocalVariable(name, descriptor, signature, start, end, index);
    super.visitLocalVariable(name, descriptor, signature, start, end, index);
  }

  @Override
  public AnnotationVisitor visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    Printer annotationPrinter =
        p.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitLocalVariableAnnotation(
            typeRef, typePath, start, end, index, descriptor, visible),
        annotationPrinter);
  }

  @Override
  public void visitLineNumber(final int line, final Label start) {
    p.visitLineNumber(line, start);
    super.visitLineNumber(line, start);
  }

  @Override
  public void visitMaxs(final int maxStack, final int maxLocals) {
    p.visitMaxs(maxStack, maxLocals);
    super.visitMaxs(maxStack, maxLocals);
  }

  @Override
  public void visitEnd() {
    p.visitMethodEnd();
    super.visitEnd();
  }
}

package org.objectweb.asm.util;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;

/**
 * A {@link FieldVisitor} that checks that its methods are properly used.
 *
 * @author Eric Bruneton
 */
public class CheckFieldAdapter extends FieldVisitor {

  /** Whether the {@link #visitEnd} method has been called. */
  private boolean visitEndCalled;

  /**
   * Constructs a new {@link CheckFieldAdapter}. <i>Subclasses must not use this constructor</i>.
   * Instead, they must use the {@link #CheckFieldAdapter(int, FieldVisitor)} version.
   *
   * @param fieldVisitor the field visitor to which this adapter must delegate calls.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public CheckFieldAdapter(final FieldVisitor fieldVisitor) {
    this(/* latest api = */ Opcodes.ASM9, fieldVisitor);
    if (getClass() != CheckFieldAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link CheckFieldAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param fieldVisitor the field visitor to which this adapter must delegate calls.
   */
  protected CheckFieldAdapter(final int api, final FieldVisitor fieldVisitor) {
    super(api, fieldVisitor);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    checkVisitEndNotCalled();
    // Annotations can only appear in V1_5 or more classes.
    CheckMethodAdapter.checkDescriptor(Opcodes.V1_5, descriptor, false);
    return new CheckAnnotationAdapter(super.visitAnnotation(descriptor, visible));
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    checkVisitEndNotCalled();
    int sort = new TypeReference(typeRef).getSort();
    if (sort != TypeReference.FIELD) {
      throw new IllegalArgumentException(
          "Invalid type reference sort 0x" + Integer.toHexString(sort));
    }
    CheckClassAdapter.checkTypeRef(typeRef);
    CheckMethodAdapter.checkDescriptor(Opcodes.V1_5, descriptor, false);
    return new CheckAnnotationAdapter(
        super.visitTypeAnnotation(typeRef, typePath, descriptor, visible));
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    checkVisitEndNotCalled();
    if (attribute == null) {
      throw new IllegalArgumentException("Invalid attribute (must not be null)");
    }
    super.visitAttribute(attribute);
  }

  @Override
  public void visitEnd() {
    checkVisitEndNotCalled();
    visitEndCalled = true;
    super.visitEnd();
  }

  private void checkVisitEndNotCalled() {
    if (visitEndCalled) {
      throw new IllegalStateException("Cannot call a visit method after visitEnd has been called");
    }
  }
}

package org.objectweb.asm.util;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;
import org.objectweb.asm.signature.SignatureReader;

/**
 * A {@link Printer} that prints a disassembled view of the classes it visits.
 *
 * @author Eric Bruneton
 */
public class Textifier extends Printer {

  /** The help message shown when command line arguments are incorrect. */
  private static final String USAGE =
      "Prints a disassembled view of the given class.\n"
          + "Usage: Textifier [-nodebug] <fully qualified class name or class file name>";

  /**
   * The type of internal names (see {@link Type#getInternalName()}). See {@link #appendDescriptor}.
   */
  public static final int INTERNAL_NAME = 0;

  /** The type of field descriptors. See {@link #appendDescriptor}. */
  public static final int FIELD_DESCRIPTOR = 1;

  /** The type of field signatures. See {@link #appendDescriptor}. */
  public static final int FIELD_SIGNATURE = 2;

  /** The type of method descriptors. See {@link #appendDescriptor}. */
  public static final int METHOD_DESCRIPTOR = 3;

  /** The type of method signatures. See {@link #appendDescriptor}. */
  public static final int METHOD_SIGNATURE = 4;

  /** The type of class signatures. See {@link #appendDescriptor}. */
  public static final int CLASS_SIGNATURE = 5;

  /** The type of method handle descriptors. See {@link #appendDescriptor}. */
  public static final int HANDLE_DESCRIPTOR = 9;

  private static final String CLASS_SUFFIX = ".class";
  private static final String DEPRECATED = "// DEPRECATED\n";
  private static final String RECORD = "// RECORD\n";
  private static final String INVISIBLE = " // invisible\n";

  private static final List<String> FRAME_TYPES =
      Collections.unmodifiableList(Arrays.asList("T", "I", "F", "D", "J", "N", "U"));

  /** The indentation of class members at depth level 1 (e.g. fields, methods). */
  protected String tab = "  ";

  /** The indentation of class elements at depth level 2 (e.g. bytecode instructions in methods). */
  protected String tab2 = "    ";

  /** The indentation of class elements at depth level 3 (e.g. switch cases in methods). */
  protected String tab3 = "      ";

  /** The indentation of labels. */
  protected String ltab = "   ";

  /** The names of the labels. */
  protected Map<Label, String> labelNames;

  /** The access flags of the visited class. */
  private int access;

  /** The number of annotation values visited so far. */
  private int numAnnotationValues;

  /**
   * Constructs a new {@link Textifier}. <i>Subclasses must not use this constructor</i>. Instead,
   * they must use the {@link #Textifier(int)} version.
   *
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public Textifier() {
    this(/* latest api = */ Opcodes.ASM9);
    if (getClass() != Textifier.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link Textifier}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   */
  protected Textifier(final int api) {
    super(api);
  }

  /**
   * Prints a disassembled view of the given class to the standard output.
   *
   * <p>Usage: Textifier [-nodebug] &lt;binary class name or class file name &gt;
   *
   * @param args the command line arguments.
   * @throws IOException if the class cannot be found, or if an IOException occurs.
   */
  public static void main(final String[] args) throws IOException {
    main(args, new PrintWriter(System.out, true), new PrintWriter(System.err, true));
  }

  /**
   * Prints a disassembled view of the given class to the given output.
   *
   * <p>Usage: Textifier [-nodebug] &lt;binary class name or class file name &gt;
   *
   * @param args the command line arguments.
   * @param output where to print the result.
   * @param logger where to log errors.
   * @throws IOException if the class cannot be found, or if an IOException occurs.
   */
  static void main(final String[] args, final PrintWriter output, final PrintWriter logger)
      throws IOException {
    main(args, USAGE, new Textifier(), output, logger);
  }

  // -----------------------------------------------------------------------------------------------
  // Classes
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visit(
      final int version,
      final int access,
      final @InternalForm String name,
      final String signature,
      final @InternalForm String superName,
      final @InternalForm String[] interfaces) {
    if ((access & Opcodes.ACC_MODULE) != 0) {
      // Modules are printed in visitModule.
      return;
    }
    this.access = access;
    int majorVersion = version & 0xFFFF;
    int minorVersion = version >>> 16;
    stringBuilder.setLength(0);
    stringBuilder
        .append("// class version ")
        .append(majorVersion)
        .append('.')
        .append(minorVersion)
        .append(" (")
        .append(version)
        .append(")\n");
    if ((access & Opcodes.ACC_DEPRECATED) != 0) {
      stringBuilder.append(DEPRECATED);
    }
    if ((access & Opcodes.ACC_RECORD) != 0) {
      stringBuilder.append(RECORD);
    }
    appendRawAccess(access);

    appendDescriptor(CLASS_SIGNATURE, signature);
    if (signature != null) {
      appendJavaDeclaration(name, signature);
    }

    appendAccess(access & ~(Opcodes.ACC_SUPER | Opcodes.ACC_MODULE));
    if ((access & Opcodes.ACC_ANNOTATION) != 0) {
      stringBuilder.append("@interface ");
    } else if ((access & Opcodes.ACC_INTERFACE) != 0) {
      stringBuilder.append("interface ");
    } else if ((access & Opcodes.ACC_ENUM) == 0) {
      stringBuilder.append("class ");
    }
    appendDescriptor(INTERNAL_NAME, name);

    if (superName != null && !"java/lang/Object".equals(superName)) {
      stringBuilder.append(" extends ");
      appendDescriptor(INTERNAL_NAME, superName);
    }
    if (interfaces != null && interfaces.length > 0) {
      stringBuilder.append(" implements ");
      for (int i = 0; i < interfaces.length; ++i) {
        appendDescriptor(INTERNAL_NAME, interfaces[i]);
        if (i != interfaces.length - 1) {
          stringBuilder.append(' ');
        }
      }
    }
    stringBuilder.append(" {\n\n");

    text.add(stringBuilder.toString());
  }

  @Override
  public void visitSource(final String file, final String debug) {
    stringBuilder.setLength(0);
    if (file != null) {
      stringBuilder.append(tab).append("// compiled from: ").append(file).append('\n');
    }
    if (debug != null) {
      stringBuilder.append(tab).append("// debug info: ").append(debug).append('\n');
    }
    if (stringBuilder.length() > 0) {
      text.add(stringBuilder.toString());
    }
  }

  @Override
  public Printer visitModule(final String name, final int access, final String version) {
    stringBuilder.setLength(0);
    if ((access & Opcodes.ACC_OPEN) != 0) {
      stringBuilder.append("open ");
    }
    stringBuilder
        .append("module ")
        .append(name)
        .append(" { ")
        .append(version == null ? "" : "// " + version)
        .append("\n\n");
    text.add(stringBuilder.toString());
    return addNewTextifier(null);
  }

  @Override
  public void visitNestHost(final @InternalForm String nestHost) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("NESTHOST ");
    appendDescriptor(INTERNAL_NAME, nestHost);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitOuterClass(final @InternalForm String owner, final String name, final String descriptor) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("OUTERCLASS ");
    appendDescriptor(INTERNAL_NAME, owner);
    stringBuilder.append(' ');
    if (name != null) {
      stringBuilder.append(name).append(' ');
    }
    appendDescriptor(METHOD_DESCRIPTOR, descriptor);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public Textifier visitClassAnnotation(final String descriptor, final boolean visible) {
    text.add("\n");
    return visitAnnotation(descriptor, visible);
  }

  @Override
  public Printer visitClassTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    text.add("\n");
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitClassAttribute(final Attribute attribute) {
    text.add("\n");
    visitAttribute(attribute);
  }

  @Override
  public void visitNestMember(final @InternalForm String nestMember) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("NESTMEMBER ");
    appendDescriptor(INTERNAL_NAME, nestMember);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitPermittedSubclass(final @InternalForm String permittedSubclass) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("PERMITTEDSUBCLASS ");
    appendDescriptor(INTERNAL_NAME, permittedSubclass);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitInnerClass(
      final @InternalForm String name, final @InternalForm String outerName, final @Identifier String innerName, final int access) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab);
    appendRawAccess(access & ~Opcodes.ACC_SUPER);
    stringBuilder.append(tab);
    appendAccess(access);
    stringBuilder.append("INNERCLASS ");
    appendDescriptor(INTERNAL_NAME, name);
    stringBuilder.append(' ');
    appendDescriptor(INTERNAL_NAME, outerName);
    stringBuilder.append(' ');
    appendDescriptor(INTERNAL_NAME, innerName);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public Printer visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("RECORDCOMPONENT ");
    if (signature != null) {
      stringBuilder.append(tab);
      appendDescriptor(FIELD_SIGNATURE, signature);
      stringBuilder.append(tab);
      appendJavaDeclaration(name, signature);
    }

    stringBuilder.append(tab);

    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append(' ').append(name);

    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
    return addNewTextifier(null);
  }

  @Override
  public Textifier visitField(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    stringBuilder.setLength(0);
    stringBuilder.append('\n');
    if ((access & Opcodes.ACC_DEPRECATED) != 0) {
      stringBuilder.append(tab).append(DEPRECATED);
    }
    stringBuilder.append(tab);
    appendRawAccess(access);
    if (signature != null) {
      stringBuilder.append(tab);
      appendDescriptor(FIELD_SIGNATURE, signature);
      stringBuilder.append(tab);
      appendJavaDeclaration(name, signature);
    }

    stringBuilder.append(tab);
    appendAccess(access);

    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append(' ').append(name);
    if (value != null) {
      stringBuilder.append(" = ");
      appendConstant(value);
    }

    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
    return addNewTextifier(null);
  }

  @Override
  public Textifier visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final @InternalForm String[] exceptions) {
    stringBuilder.setLength(0);
    stringBuilder.append('\n');
    if ((access & Opcodes.ACC_DEPRECATED) != 0) {
      stringBuilder.append(tab).append(DEPRECATED);
    }
    stringBuilder.append(tab);
    appendRawAccess(access);

    if (signature != null) {
      stringBuilder.append(tab);
      appendDescriptor(METHOD_SIGNATURE, signature);
      stringBuilder.append(tab);
      appendJavaDeclaration(name, signature);
    }

    stringBuilder.append(tab);
    appendAccess(access & ~(Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT));
    if ((access & Opcodes.ACC_NATIVE) != 0) {
      stringBuilder.append("native ");
    }
    if ((access & Opcodes.ACC_VARARGS) != 0) {
      stringBuilder.append("varargs ");
    }
    if ((access & Opcodes.ACC_BRIDGE) != 0) {
      stringBuilder.append("bridge ");
    }
    if ((this.access & Opcodes.ACC_INTERFACE) != 0
        && (access & (Opcodes.ACC_ABSTRACT | Opcodes.ACC_STATIC)) == 0) {
      stringBuilder.append("default ");
    }

    stringBuilder.append(name);
    appendDescriptor(METHOD_DESCRIPTOR, descriptor);
    if (exceptions != null && exceptions.length > 0) {
      stringBuilder.append(" throws");
      for (String exception : exceptions) {
        stringBuilder.append(' ');
        appendDescriptor(INTERNAL_NAME, exception);
      }
    }

    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
    return addNewTextifier(null);
  }

  @Override
  public void visitClassEnd() {
    text.add("}\n");
  }

  // -----------------------------------------------------------------------------------------------
  // Modules
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visitMainClass(final String mainClass) {
    stringBuilder.setLength(0);
    stringBuilder.append("  // main class ").append(mainClass).append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitPackage(final String packaze) {
    stringBuilder.setLength(0);
    stringBuilder.append("  // package ").append(packaze).append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitRequire(final String require, final int access, final String version) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("requires ");
    if ((access & Opcodes.ACC_TRANSITIVE) != 0) {
      stringBuilder.append("transitive ");
    }
    if ((access & Opcodes.ACC_STATIC_PHASE) != 0) {
      stringBuilder.append("static ");
    }
    stringBuilder.append(require).append(';');
    appendRawAccess(access);
    if (version != null) {
      stringBuilder.append("  // version ").append(version).append('\n');
    }
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitExport(final String packaze, final int access, final String... modules) {
    visitExportOrOpen("exports ", packaze, access, modules);
  }

  @Override
  public void visitOpen(final String packaze, final int access, final String... modules) {
    visitExportOrOpen("opens ", packaze, access, modules);
  }

  private void visitExportOrOpen(
      final String method, final String packaze, final int access, final String... modules) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append(method);
    stringBuilder.append(packaze);
    if (modules != null && modules.length > 0) {
      stringBuilder.append(" to");
    } else {
      stringBuilder.append(';');
    }
    appendRawAccess(access);
    if (modules != null && modules.length > 0) {
      for (int i = 0; i < modules.length; ++i) {
        stringBuilder.append(tab2).append(modules[i]);
        stringBuilder.append(i != modules.length - 1 ? ",\n" : ";\n");
      }
    }
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitUse(final @InternalForm String use) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("uses ");
    appendDescriptor(INTERNAL_NAME, use);
    stringBuilder.append(";\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitProvide(final @InternalForm String provide, final @InternalForm String... providers) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("provides ");
    appendDescriptor(INTERNAL_NAME, provide);
    stringBuilder.append(" with\n");
    for (int i = 0; i < providers.length; ++i) {
      stringBuilder.append(tab2);
      appendDescriptor(INTERNAL_NAME, providers[i]);
      stringBuilder.append(i != providers.length - 1 ? ",\n" : ";\n");
    }
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitModuleEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Annotations
  // -----------------------------------------------------------------------------------------------

  // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
  @Override
  public void visit(final String name, final Object value) {
    visitAnnotationValue(name);
    if (value instanceof String) {
      visitString((String) value);
    } else if (value instanceof Type) {
      visitType((Type) value);
    } else if (value instanceof Byte) {
      visitByte(((Byte) value).byteValue());
    } else if (value instanceof Boolean) {
      visitBoolean(((Boolean) value).booleanValue());
    } else if (value instanceof Short) {
      visitShort(((Short) value).shortValue());
    } else if (value instanceof Character) {
      visitChar(((Character) value).charValue());
    } else if (value instanceof Integer) {
      visitInt(((Integer) value).intValue());
    } else if (value instanceof Float) {
      visitFloat(((Float) value).floatValue());
    } else if (value instanceof Long) {
      visitLong(((Long) value).longValue());
    } else if (value instanceof Double) {
      visitDouble(((Double) value).doubleValue());
    } else if (value.getClass().isArray()) {
      stringBuilder.append('{');
      if (value instanceof byte[]) {
        byte[] byteArray = (byte[]) value;
        for (int i = 0; i < byteArray.length; i++) {
          maybeAppendComma(i);
          visitByte(byteArray[i]);
        }
      } else if (value instanceof boolean[]) {
        boolean[] booleanArray = (boolean[]) value;
        for (int i = 0; i < booleanArray.length; i++) {
          maybeAppendComma(i);
          visitBoolean(booleanArray[i]);
        }
      } else if (value instanceof short[]) {
        short[] shortArray = (short[]) value;
        for (int i = 0; i < shortArray.length; i++) {
          maybeAppendComma(i);
          visitShort(shortArray[i]);
        }
      } else if (value instanceof char[]) {
        char[] charArray = (char[]) value;
        for (int i = 0; i < charArray.length; i++) {
          maybeAppendComma(i);
          visitChar(charArray[i]);
        }
      } else if (value instanceof int[]) {
        int[] intArray = (int[]) value;
        for (int i = 0; i < intArray.length; i++) {
          maybeAppendComma(i);
          visitInt(intArray[i]);
        }
      } else if (value instanceof long[]) {
        long[] longArray = (long[]) value;
        for (int i = 0; i < longArray.length; i++) {
          maybeAppendComma(i);
          visitLong(longArray[i]);
        }
      } else if (value instanceof float[]) {
        float[] floatArray = (float[]) value;
        for (int i = 0; i < floatArray.length; i++) {
          maybeAppendComma(i);
          visitFloat(floatArray[i]);
        }
      } else if (value instanceof double[]) {
        double[] doubleArray = (double[]) value;
        for (int i = 0; i < doubleArray.length; i++) {
          maybeAppendComma(i);
          visitDouble(doubleArray[i]);
        }
      }
      stringBuilder.append('}');
    }
    text.add(stringBuilder.toString());
  }

  private void visitInt(final int value) {
    stringBuilder.append(value);
  }

  private void visitLong(final long value) {
    stringBuilder.append(value).append('L');
  }

  private void visitFloat(final float value) {
    stringBuilder.append(value).append('F');
  }

  private void visitDouble(final double value) {
    stringBuilder.append(value).append('D');
  }

  private void visitChar(final char value) {
    stringBuilder.append("(char)").append((int) value);
  }

  private void visitShort(final short value) {
    stringBuilder.append("(short)").append(value);
  }

  private void visitByte(final byte value) {
    stringBuilder.append("(byte)").append(value);
  }

  private void visitBoolean(final boolean value) {
    stringBuilder.append(value);
  }

  private void visitString(final String value) {
    appendString(stringBuilder, value);
  }

  private void visitType(final Type value) {
    stringBuilder.append(value.getClassName()).append(CLASS_SUFFIX);
  }

  @Override
  public void visitEnum(final String name, final String descriptor, final String value) {
    visitAnnotationValue(name);
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append('.').append(value);
    text.add(stringBuilder.toString());
  }

  @Override
  public Textifier visitAnnotation(final String name, final String descriptor) {
    visitAnnotationValue(name);
    stringBuilder.append('@');
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append('(');
    text.add(stringBuilder.toString());
    return addNewTextifier(")");
  }

  @Override
  public Textifier visitArray(final String name) {
    visitAnnotationValue(name);
    stringBuilder.append('{');
    text.add(stringBuilder.toString());
    return addNewTextifier("}");
  }

  @Override
  public void visitAnnotationEnd() {
    // Nothing to do.
  }

  private void visitAnnotationValue(final String name) {
    stringBuilder.setLength(0);
    maybeAppendComma(numAnnotationValues++);
    if (name != null) {
      stringBuilder.append(name).append('=');
    }
  }

  // -----------------------------------------------------------------------------------------------
  // Record components
  // -----------------------------------------------------------------------------------------------

  @Override
  public Textifier visitRecordComponentAnnotation(final String descriptor, final boolean visible) {
    return visitAnnotation(descriptor, visible);
  }

  @Override
  public Printer visitRecordComponentTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitRecordComponentAttribute(final Attribute attribute) {
    visitAttribute(attribute);
  }

  @Override
  public void visitRecordComponentEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Fields
  // -----------------------------------------------------------------------------------------------

  @Override
  public Textifier visitFieldAnnotation(final String descriptor, final boolean visible) {
    return visitAnnotation(descriptor, visible);
  }

  @Override
  public Printer visitFieldTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitFieldAttribute(final Attribute attribute) {
    visitAttribute(attribute);
  }

  @Override
  public void visitFieldEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visitParameter(final String name, final int access) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("// parameter ");
    appendAccess(access);
    stringBuilder.append(' ').append((name == null) ? "<no name>" : name).append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public Textifier visitAnnotationDefault() {
    text.add(tab2 + "default=");
    return addNewTextifier("\n");
  }

  @Override
  public Textifier visitMethodAnnotation(final String descriptor, final boolean visible) {
    return visitAnnotation(descriptor, visible);
  }

  @Override
  public Printer visitMethodTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public Textifier visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("// annotable parameter count: ");
    stringBuilder.append(parameterCount);
    stringBuilder.append(visible ? " (visible)\n" : " (invisible)\n");
    text.add(stringBuilder.toString());
    return this;
  }

  @Override
  public Textifier visitParameterAnnotation(
      final int parameter, final String descriptor, final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append('@');
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append('(');
    text.add(stringBuilder.toString());

    stringBuilder.setLength(0);
    stringBuilder
        .append(visible ? ") // parameter " : ") // invisible, parameter ")
        .append(parameter)
        .append('\n');
    return addNewTextifier(stringBuilder.toString());
  }

  @Override
  public void visitMethodAttribute(final Attribute attribute) {
    visitAttribute(attribute);
  }

  @Override
  public void visitCode() {
    // Nothing to do.
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    stringBuilder.setLength(0);
    stringBuilder.append(ltab);
    stringBuilder.append("FRAME ");
    switch (type) {
      case Opcodes.F_NEW:
      case Opcodes.F_FULL:
        stringBuilder.append("FULL [");
        appendFrameTypes(numLocal, local);
        stringBuilder.append("] [");
        appendFrameTypes(numStack, stack);
        stringBuilder.append(']');
        break;
      case Opcodes.F_APPEND:
        stringBuilder.append("APPEND [");
        appendFrameTypes(numLocal, local);
        stringBuilder.append(']');
        break;
      case Opcodes.F_CHOP:
        stringBuilder.append("CHOP ").append(numLocal);
        break;
      case Opcodes.F_SAME:
        stringBuilder.append("SAME");
        break;
      case Opcodes.F_SAME1:
        stringBuilder.append("SAME1 ");
        appendFrameTypes(1, stack);
        break;
      default:
        throw new IllegalArgumentException();
    }
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitInsn(final int opcode) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append(OPCODES[opcode]).append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    stringBuilder.setLength(0);
    stringBuilder
        .append(tab2)
        .append(OPCODES[opcode])
        .append(' ')
        .append(opcode == Opcodes.NEWARRAY ? TYPES[operand] : Integer.toString(operand))
        .append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append(OPCODES[opcode]).append(' ').append(varIndex).append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append(OPCODES[opcode]).append(' ');
    appendDescriptor(INTERNAL_NAME, type);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append(OPCODES[opcode]).append(' ');
    appendDescriptor(INTERNAL_NAME, owner);
    stringBuilder.append('.').append(name).append(" : ");
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitMethodInsn(
      final int opcode,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append(OPCODES[opcode]).append(' ');
    appendDescriptor(INTERNAL_NAME, owner);
    stringBuilder.append('.').append(name).append(' ');
    appendDescriptor(METHOD_DESCRIPTOR, descriptor);
    if (isInterface) {
      stringBuilder.append(" (itf)");
    }
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("INVOKEDYNAMIC").append(' ');
    stringBuilder.append(name);
    appendDescriptor(METHOD_DESCRIPTOR, descriptor);
    stringBuilder.append(" [");
    stringBuilder.append('\n');
    stringBuilder.append(tab3);
    appendHandle(bootstrapMethodHandle, tab3);
    stringBuilder.append('\n').append(tab3);
    appendBoostrapMethodArgs(bootstrapMethodArguments, tab3);
    stringBuilder.append('\n');
    stringBuilder.append(tab2).append("]\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append(OPCODES[opcode]).append(' ');
    appendLabel(label);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitLabel(final Label label) {
    stringBuilder.setLength(0);
    stringBuilder.append(ltab);
    appendLabel(label);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitLdcInsn(final Object value) {
    stringBuilder.setLength(0);
    if (value instanceof ConstantDynamic) {
      stringBuilder.append(tab2).append("LDC ");
      appendConstantDynamic((ConstantDynamic) value, tab2);
    } else if (value instanceof Handle) {
      stringBuilder.append(tab2);
      appendHandle((Handle) value, tab2 + "LDC ");
    } else {
      stringBuilder.append(tab2).append("LDC ");
      appendConstant(value);
    }
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    stringBuilder.setLength(0);
    stringBuilder
        .append(tab2)
        .append("IINC ")
        .append(varIndex)
        .append(' ')
        .append(increment)
        .append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("TABLESWITCH\n");
    for (int i = 0; i < labels.length; ++i) {
      stringBuilder.append(tab3).append(min + i).append(": ");
      appendLabel(labels[i]);
      stringBuilder.append('\n');
    }
    stringBuilder.append(tab3).append("default: ");
    appendLabel(dflt);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("LOOKUPSWITCH\n");
    for (int i = 0; i < labels.length; ++i) {
      stringBuilder.append(tab3).append(keys[i]).append(": ");
      appendLabel(labels[i]);
      stringBuilder.append('\n');
    }
    stringBuilder.append(tab3).append("default: ");
    appendLabel(dflt);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("MULTIANEWARRAY ");
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append(' ').append(numDimensions).append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public Printer visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @InternalForm String type) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("TRYCATCHBLOCK ");
    appendLabel(start);
    stringBuilder.append(' ');
    appendLabel(end);
    stringBuilder.append(' ');
    appendLabel(handler);
    stringBuilder.append(' ');
    appendDescriptor(INTERNAL_NAME, type);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public Printer visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("TRYCATCHBLOCK @");
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append('(');
    text.add(stringBuilder.toString());

    stringBuilder.setLength(0);
    stringBuilder.append(") : ");
    appendTypeReference(typeRef);
    stringBuilder.append(", ").append(typePath);
    stringBuilder.append(visible ? "\n" : INVISIBLE);
    return addNewTextifier(stringBuilder.toString());
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("LOCALVARIABLE ").append(name).append(' ');
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append(' ');
    appendLabel(start);
    stringBuilder.append(' ');
    appendLabel(end);
    stringBuilder.append(' ').append(index).append('\n');

    if (signature != null) {
      stringBuilder.append(tab2);
      appendDescriptor(FIELD_SIGNATURE, signature);
      stringBuilder.append(tab2);
      appendJavaDeclaration(name, signature);
    }
    text.add(stringBuilder.toString());
  }

  @Override
  public Printer visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("LOCALVARIABLE @");
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append('(');
    text.add(stringBuilder.toString());

    stringBuilder.setLength(0);
    stringBuilder.append(") : ");
    appendTypeReference(typeRef);
    stringBuilder.append(", ").append(typePath);
    for (int i = 0; i < start.length; ++i) {
      stringBuilder.append(" [ ");
      appendLabel(start[i]);
      stringBuilder.append(" - ");
      appendLabel(end[i]);
      stringBuilder.append(" - ").append(index[i]).append(" ]");
    }
    stringBuilder.append(visible ? "\n" : INVISIBLE);
    return addNewTextifier(stringBuilder.toString());
  }

  @Override
  public void visitLineNumber(final int line, final Label start) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("LINENUMBER ").append(line).append(' ');
    appendLabel(start);
    stringBuilder.append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitMaxs(final int maxStack, final int maxLocals) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("MAXSTACK = ").append(maxStack).append('\n');
    text.add(stringBuilder.toString());

    stringBuilder.setLength(0);
    stringBuilder.append(tab2).append("MAXLOCALS = ").append(maxLocals).append('\n');
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitMethodEnd() {
    // Nothing to do.
  }

  // -----------------------------------------------------------------------------------------------
  // Common methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Prints a disassembled view of the given annotation.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values.
   */
  // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
  public Textifier visitAnnotation(final String descriptor, final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append('@');
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append('(');
    text.add(stringBuilder.toString());
    return addNewTextifier(visible ? ")\n" : ") // invisible\n");
  }

  /**
   * Prints a disassembled view of the given type annotation.
   *
   * @param typeRef a reference to the annotated type. See {@link TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a visitor to visit the annotation values.
   */
  public Textifier visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append('@');
    appendDescriptor(FIELD_DESCRIPTOR, descriptor);
    stringBuilder.append('(');
    text.add(stringBuilder.toString());

    stringBuilder.setLength(0);
    stringBuilder.append(") : ");
    appendTypeReference(typeRef);
    stringBuilder.append(", ").append(typePath);
    stringBuilder.append(visible ? "\n" : INVISIBLE);
    return addNewTextifier(stringBuilder.toString());
  }

  /**
   * Prints a disassembled view of the given attribute.
   *
   * @param attribute an attribute.
   */
  public void visitAttribute(final Attribute attribute) {
    stringBuilder.setLength(0);
    stringBuilder.append(tab).append("ATTRIBUTE ");
    appendDescriptor(-1, attribute.type);

    if (attribute instanceof TextifierSupport) {
      if (labelNames == null) {
        labelNames = new HashMap<>();
      }
      ((TextifierSupport) attribute).textify(stringBuilder, labelNames);
    } else {
      stringBuilder.append(" : unknown\n");
    }

    text.add(stringBuilder.toString());
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Appends a string representation of the given access flags to {@link #stringBuilder}.
   *
   * @param accessFlags some access flags.
   */
  private void appendAccess(final int accessFlags) {
    if ((accessFlags & Opcodes.ACC_PUBLIC) != 0) {
      stringBuilder.append("public ");
    }
    if ((accessFlags & Opcodes.ACC_PRIVATE) != 0) {
      stringBuilder.append("private ");
    }
    if ((accessFlags & Opcodes.ACC_PROTECTED) != 0) {
      stringBuilder.append("protected ");
    }
    if ((accessFlags & Opcodes.ACC_FINAL) != 0) {
      stringBuilder.append("final ");
    }
    if ((accessFlags & Opcodes.ACC_STATIC) != 0) {
      stringBuilder.append("static ");
    }
    if ((accessFlags & Opcodes.ACC_SYNCHRONIZED) != 0) {
      stringBuilder.append("synchronized ");
    }
    if ((accessFlags & Opcodes.ACC_VOLATILE) != 0) {
      stringBuilder.append("volatile ");
    }
    if ((accessFlags & Opcodes.ACC_TRANSIENT) != 0) {
      stringBuilder.append("transient ");
    }
    if ((accessFlags & Opcodes.ACC_ABSTRACT) != 0) {
      stringBuilder.append("abstract ");
    }
    if ((accessFlags & Opcodes.ACC_STRICT) != 0) {
      stringBuilder.append("strictfp ");
    }
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0) {
      stringBuilder.append("synthetic ");
    }
    if ((accessFlags & Opcodes.ACC_MANDATED) != 0) {
      stringBuilder.append("mandated ");
    }
    if ((accessFlags & Opcodes.ACC_ENUM) != 0) {
      stringBuilder.append("enum ");
    }
  }

  /**
   * Appends a constant value. This method can be used for {@link Integer}, {@link Float}, {@link
   * Long}, {@link Double}, {@link Boolean}, {@link String}, and {@link Type}. Attempting to use any
   * other type will result in its {@link Object#toString()} representation.
   *
   * @param constant the constant to be appended.
   */
  private void appendConstant(final Object constant) {
    if (constant instanceof Number) {
      if (constant instanceof Double) {
        stringBuilder.append(constant).append('D');
      } else if (constant instanceof Float) {
        stringBuilder.append(constant).append('F');
      } else if (constant instanceof Long) {
        stringBuilder.append(constant).append('L');
      } else {
        // Integer (or other "unsupported" Number subclass)
        stringBuilder.append(constant);
      }
    } else {
      if (constant instanceof Type) {
        stringBuilder.append(((Type) constant).getDescriptor()).append(CLASS_SUFFIX);
      } else if (constant instanceof String) {
        Printer.appendString(stringBuilder, constant.toString());
      } else {
        // Boolean or other "unsupported" constant
        stringBuilder.append(constant);
      }
    }
  }

  /**
   * Append the contents of a {@link ConstantDynamic}.
   *
   * @param condy the constant dynamic to append
   * @param condyIndent the indent to use for newlines.
   */
  private void appendConstantDynamic(final ConstantDynamic condy, final String condyIndent) {
    stringBuilder
        .append(condy.getName())
        .append(" : ")
        .append(condy.getDescriptor())
        .append(" [\n");
    stringBuilder.append(condyIndent).append(tab);
    appendHandle(condy.getBootstrapMethod(), condyIndent + tab);
    stringBuilder.append('\n').append(condyIndent).append(tab);
    Object[] bsmArgs = new Object[condy.getBootstrapMethodArgumentCount()];
    for (int i = 0; i < bsmArgs.length; i++) {
      bsmArgs[i] = condy.getBootstrapMethodArgument(i);
    }
    appendBoostrapMethodArgs(bsmArgs, condyIndent + tab);
    stringBuilder.append('\n').append(condyIndent).append(']');
  }

  /**
   * Appends bootstrap method args for {@link ConstantDynamic} and {@link #visitInvokeDynamicInsn}.
   *
   * @param bsmArgs the bootstrap method arguments.
   * @param argIndent the indent to use for newlines.
   */
  private void appendBoostrapMethodArgs(final Object[] bsmArgs, final String argIndent) {
    stringBuilder.append("// arguments:");
    if (bsmArgs.length == 0) {
      stringBuilder.append(" none");
    } else {
      for (int i = 0; i < bsmArgs.length; i++) {
        Object arg = bsmArgs[i];
        if (i != 0) {
          stringBuilder.append(", ");
        }
        stringBuilder.append('\n').append(argIndent);
        if (arg instanceof Type) {
          Type type = (Type) arg;
          if (type.getSort() == Type.METHOD) {
            appendDescriptor(METHOD_DESCRIPTOR, type.getDescriptor());
          } else {
            visitType(type);
          }
        } else if (arg instanceof Handle) {
          appendHandle((Handle) arg, argIndent);
        } else if (arg instanceof ConstantDynamic) {
          stringBuilder.append("// constant dynamic: ").append('\n').append(argIndent);
          appendConstantDynamic((ConstantDynamic) arg, argIndent);
        } else {
          appendConstant(arg);
        }
      }
    }
  }

  /**
   * Appends the hexadecimal value of the given access flags to {@link #stringBuilder}.
   *
   * @param accessFlags some access flags.
   */
  private void appendRawAccess(final int accessFlags) {
    stringBuilder
        .append("// access flags 0x")
        .append(Integer.toHexString(accessFlags).toUpperCase())
        .append('\n');
  }

  /**
   * Appends an internal name, a type descriptor or a type signature to {@link #stringBuilder}.
   *
   * @param type the type of 'value'. Must be one of {@link #INTERNAL_NAME}, {@link
   *     #FIELD_DESCRIPTOR}, {@link #FIELD_SIGNATURE}, {@link #METHOD_DESCRIPTOR}, {@link
   *     #METHOD_SIGNATURE}, {@link #CLASS_SIGNATURE} or {@link #HANDLE_DESCRIPTOR}.
   * @param value an internal name (see {@link Type#getInternalName()}), type descriptor or a type
   *     signature. May be {@literal null}.
   */
  protected void appendDescriptor(final int type, final String value) {
    if (type == CLASS_SIGNATURE || type == FIELD_SIGNATURE || type == METHOD_SIGNATURE) {
      if (value != null) {
        stringBuilder.append("// signature ").append(value).append('\n');
      }
    } else {
      stringBuilder.append(value);
    }
  }

  /**
   * Appends the Java generic type declaration corresponding to the given signature.
   *
   * @param name a class, field or method name.
   * @param signature a class, field or method signature.
   */
  private void appendJavaDeclaration(final String name, final String signature) {
    TraceSignatureVisitor traceSignatureVisitor = new TraceSignatureVisitor(access);
    new SignatureReader(signature).accept(traceSignatureVisitor);
    stringBuilder.append("// declaration: ");
    if (traceSignatureVisitor.getReturnType() != null) {
      stringBuilder.append(traceSignatureVisitor.getReturnType());
      stringBuilder.append(' ');
    }
    stringBuilder.append(name);
    stringBuilder.append(traceSignatureVisitor.getDeclaration());
    if (traceSignatureVisitor.getExceptions() != null) {
      stringBuilder.append(" throws ").append(traceSignatureVisitor.getExceptions());
    }
    stringBuilder.append('\n');
  }

  /**
   * Appends the name of the given label to {@link #stringBuilder}. Constructs a new label name if
   * the given label does not yet have one.
   *
   * @param label a label.
   */
  protected void appendLabel(final Label label) {
    if (labelNames == null) {
      labelNames = new HashMap<>();
    }
    String name = labelNames.get(label);
    if (name == null) {
      name = "L" + labelNames.size();
      labelNames.put(label, name);
    }
    stringBuilder.append(name);
  }

  @Deprecated
  protected void appendHandle(final Handle handle) {
    appendHandle(handle, tab3);
  }

  /**
   * Appends a string representation of the given handle to {@link #stringBuilder}.
   *
   * @param handle a handle.
   * @param afterComment this is the prefix of the line after the handle kind.
   */
  protected void appendHandle(final Handle handle, final String afterComment) {
    int tag = handle.getTag();
    stringBuilder.append("// handle kind 0x").append(Integer.toHexString(tag)).append(" : ");
    boolean isMethodHandle = false;
    switch (tag) {
      case Opcodes.H_GETFIELD:
        stringBuilder.append("GETFIELD");
        break;
      case Opcodes.H_GETSTATIC:
        stringBuilder.append("GETSTATIC");
        break;
      case Opcodes.H_PUTFIELD:
        stringBuilder.append("PUTFIELD");
        break;
      case Opcodes.H_PUTSTATIC:
        stringBuilder.append("PUTSTATIC");
        break;
      case Opcodes.H_INVOKEINTERFACE:
        stringBuilder.append("INVOKEINTERFACE");
        isMethodHandle = true;
        break;
      case Opcodes.H_INVOKESPECIAL:
        stringBuilder.append("INVOKESPECIAL");
        isMethodHandle = true;
        break;
      case Opcodes.H_INVOKESTATIC:
        stringBuilder.append("INVOKESTATIC");
        isMethodHandle = true;
        break;
      case Opcodes.H_INVOKEVIRTUAL:
        stringBuilder.append("INVOKEVIRTUAL");
        isMethodHandle = true;
        break;
      case Opcodes.H_NEWINVOKESPECIAL:
        stringBuilder.append("NEWINVOKESPECIAL");
        isMethodHandle = true;
        break;
      default:
        throw new IllegalArgumentException();
    }
    stringBuilder.append('\n');
    stringBuilder.append(afterComment);
    appendDescriptor(INTERNAL_NAME, handle.getOwner());
    stringBuilder.append('.');
    stringBuilder.append(handle.getName());
    if (!isMethodHandle) {
      stringBuilder.append('(');
    }
    appendDescriptor(HANDLE_DESCRIPTOR, handle.getDesc());
    if (!isMethodHandle) {
      stringBuilder.append(')');
    }
    if (handle.isInterface()) {
      stringBuilder.append(" itf");
    }
  }

  /**
   * Appends a comma to {@link #stringBuilder} if the given number is strictly positive.
   *
   * @param numValues a number of 'values visited so far', for instance the number of annotation
   *     values visited so far in an annotation visitor.
   */
  private void maybeAppendComma(final int numValues) {
    if (numValues > 0) {
      stringBuilder.append(", ");
    }
  }

  /**
   * Appends a string representation of the given type reference to {@link #stringBuilder}.
   *
   * @param typeRef a type reference. See {@link TypeReference}.
   */
  private void appendTypeReference(final int typeRef) {
    TypeReference typeReference = new TypeReference(typeRef);
    switch (typeReference.getSort()) {
      case TypeReference.CLASS_TYPE_PARAMETER:
        stringBuilder.append("CLASS_TYPE_PARAMETER ").append(typeReference.getTypeParameterIndex());
        break;
      case TypeReference.METHOD_TYPE_PARAMETER:
        stringBuilder
            .append("METHOD_TYPE_PARAMETER ")
            .append(typeReference.getTypeParameterIndex());
        break;
      case TypeReference.CLASS_EXTENDS:
        stringBuilder.append("CLASS_EXTENDS ").append(typeReference.getSuperTypeIndex());
        break;
      case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
        stringBuilder
            .append("CLASS_TYPE_PARAMETER_BOUND ")
            .append(typeReference.getTypeParameterIndex())
            .append(", ")
            .append(typeReference.getTypeParameterBoundIndex());
        break;
      case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
        stringBuilder
            .append("METHOD_TYPE_PARAMETER_BOUND ")
            .append(typeReference.getTypeParameterIndex())
            .append(", ")
            .append(typeReference.getTypeParameterBoundIndex());
        break;
      case TypeReference.FIELD:
        stringBuilder.append("FIELD");
        break;
      case TypeReference.METHOD_RETURN:
        stringBuilder.append("METHOD_RETURN");
        break;
      case TypeReference.METHOD_RECEIVER:
        stringBuilder.append("METHOD_RECEIVER");
        break;
      case TypeReference.METHOD_FORMAL_PARAMETER:
        stringBuilder
            .append("METHOD_FORMAL_PARAMETER ")
            .append(typeReference.getFormalParameterIndex());
        break;
      case TypeReference.THROWS:
        stringBuilder.append("THROWS ").append(typeReference.getExceptionIndex());
        break;
      case TypeReference.LOCAL_VARIABLE:
        stringBuilder.append("LOCAL_VARIABLE");
        break;
      case TypeReference.RESOURCE_VARIABLE:
        stringBuilder.append("RESOURCE_VARIABLE");
        break;
      case TypeReference.EXCEPTION_PARAMETER:
        stringBuilder.append("EXCEPTION_PARAMETER ").append(typeReference.getTryCatchBlockIndex());
        break;
      case TypeReference.INSTANCEOF:
        stringBuilder.append("INSTANCEOF");
        break;
      case TypeReference.NEW:
        stringBuilder.append("NEW");
        break;
      case TypeReference.CONSTRUCTOR_REFERENCE:
        stringBuilder.append("CONSTRUCTOR_REFERENCE");
        break;
      case TypeReference.METHOD_REFERENCE:
        stringBuilder.append("METHOD_REFERENCE");
        break;
      case TypeReference.CAST:
        stringBuilder.append("CAST ").append(typeReference.getTypeArgumentIndex());
        break;
      case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
        stringBuilder
            .append("CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT ")
            .append(typeReference.getTypeArgumentIndex());
        break;
      case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
        stringBuilder
            .append("METHOD_INVOCATION_TYPE_ARGUMENT ")
            .append(typeReference.getTypeArgumentIndex());
        break;
      case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
        stringBuilder
            .append("CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT ")
            .append(typeReference.getTypeArgumentIndex());
        break;
      case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
        stringBuilder
            .append("METHOD_REFERENCE_TYPE_ARGUMENT ")
            .append(typeReference.getTypeArgumentIndex());
        break;
      default:
        throw new IllegalArgumentException();
    }
  }

  /**
   * Appends the given stack map frame types to {@link #stringBuilder}.
   *
   * @param numTypes the number of stack map frame types in 'frameTypes'.
   * @param frameTypes an array of stack map frame types, in the format described in {@link
   *     org.objectweb.asm.MethodVisitor#visitFrame}.
   */
  private void appendFrameTypes(final int numTypes, final Object[] frameTypes) {
    for (int i = 0; i < numTypes; ++i) {
      if (i > 0) {
        stringBuilder.append(' ');
      }
      if (frameTypes[i] instanceof String) {
        String descriptor = (String) frameTypes[i];
        if (descriptor.charAt(0) == '[') {
          appendDescriptor(FIELD_DESCRIPTOR, descriptor);
        } else {
          appendDescriptor(INTERNAL_NAME, descriptor);
        }
      } else if (frameTypes[i] instanceof Integer) {
        stringBuilder.append(FRAME_TYPES.get(((Integer) frameTypes[i]).intValue()));
      } else {
        appendLabel((Label) frameTypes[i]);
      }
    }
  }

  /**
   * Creates and adds to {@link #text} a new {@link Textifier}, followed by the given string.
   *
   * @param endText the text to add to {@link #text} after the textifier. May be {@literal null}.
   * @return the newly created {@link Textifier}.
   */
  private Textifier addNewTextifier(final String endText) {
    Textifier textifier = createTextifier();
    text.add(textifier.getText());
    if (endText != null) {
      text.add(endText);
    }
    return textifier;
  }

  /**
   * Creates a new {@link Textifier}.
   *
   * @return a new {@link Textifier}.
   */
  protected Textifier createTextifier() {
    return new Textifier(api);
  }
}

package org.objectweb.asm.util;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

/**
 * An {@link AnnotationVisitor} that checks that its methods are properly used.
 *
 * @author Eric Bruneton
 */
public class CheckAnnotationAdapter extends AnnotationVisitor {

  /**
   * Whether the values of the visited annotation are named. AnnotationVisitor instances used for
   * annotation default and annotation arrays use unnamed values.
   */
  private final boolean useNamedValue;

  /** Whether the {@link #visitEnd} method has been called. */
  private boolean visitEndCalled;

  public CheckAnnotationAdapter(final AnnotationVisitor annotationVisitor) {
    this(annotationVisitor, true);
  }

  CheckAnnotationAdapter(final AnnotationVisitor annotationVisitor, final boolean useNamedValues) {
    super(/* latest api = */ Opcodes.ASM9, annotationVisitor);
    this.useNamedValue = useNamedValues;
  }

  @Override
  public void visit(final String name, final Object value) {
    checkVisitEndNotCalled();
    checkName(name);
    if (!(value instanceof Byte
        || value instanceof Boolean
        || value instanceof Character
        || value instanceof Short
        || value instanceof Integer
        || value instanceof Long
        || value instanceof Float
        || value instanceof Double
        || value instanceof String
        || value instanceof Type
        || value instanceof byte[]
        || value instanceof boolean[]
        || value instanceof char[]
        || value instanceof short[]
        || value instanceof int[]
        || value instanceof long[]
        || value instanceof float[]
        || value instanceof double[])) {
      throw new IllegalArgumentException("Invalid annotation value");
    }
    if (value instanceof Type && ((Type) value).getSort() == Type.METHOD) {
      throw new IllegalArgumentException("Invalid annotation value");
    }
    super.visit(name, value);
  }

  @Override
  public void visitEnum(final String name, final String descriptor, final String value) {
    checkVisitEndNotCalled();
    checkName(name);
    // Annotations can only appear in V1_5 or more classes.
    CheckMethodAdapter.checkDescriptor(Opcodes.V1_5, descriptor, false);
    if (value == null) {
      throw new IllegalArgumentException("Invalid enum value");
    }
    super.visitEnum(name, descriptor, value);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
    checkVisitEndNotCalled();
    checkName(name);
    // Annotations can only appear in V1_5 or more classes.
    CheckMethodAdapter.checkDescriptor(Opcodes.V1_5, descriptor, false);
    return new CheckAnnotationAdapter(super.visitAnnotation(name, descriptor));
  }

  @Override
  public AnnotationVisitor visitArray(final String name) {
    checkVisitEndNotCalled();
    checkName(name);
    return new CheckAnnotationAdapter(super.visitArray(name), false);
  }

  @Override
  public void visitEnd() {
    checkVisitEndNotCalled();
    visitEndCalled = true;
    super.visitEnd();
  }

  private void checkName(final String name) {
    if (useNamedValue && name == null) {
      throw new IllegalArgumentException("Annotation value name must not be null");
    }
  }

  private void checkVisitEndNotCalled() {
    if (visitEndCalled) {
      throw new IllegalStateException("Cannot call a visit method after visitEnd has been called");
    }
  }
}

package org.objectweb.asm.util;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Opcodes;

/**
 * An {@link AnnotationVisitor} that prints the annotations it visits with a {@link Printer}.
 *
 * @author Eric Bruneton
 */
public final class TraceAnnotationVisitor extends AnnotationVisitor {

  /** The printer to convert the visited annotation into text. */
  private final Printer printer;

  /**
   * Constructs a new {@link TraceAnnotationVisitor}.
   *
   * @param printer the printer to convert the visited annotation into text.
   */
  public TraceAnnotationVisitor(final Printer printer) {
    this(null, printer);
  }

  /**
   * Constructs a new {@link TraceAnnotationVisitor}.
   *
   * @param annotationVisitor the annotation visitor to which to delegate calls. May be {@literal
   *     null}.
   * @param printer the printer to convert the visited annotation into text.
   */
  public TraceAnnotationVisitor(final AnnotationVisitor annotationVisitor, final Printer printer) {
    super(/* latest api = */ Opcodes.ASM9, annotationVisitor);
    this.printer = printer;
  }

  @Override
  public void visit(final String name, final Object value) {
    printer.visit(name, value);
    super.visit(name, value);
  }

  @Override
  public void visitEnum(final String name, final String descriptor, final String value) {
    printer.visitEnum(name, descriptor, value);
    super.visitEnum(name, descriptor, value);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {
    Printer annotationPrinter = printer.visitAnnotation(name, descriptor);
    return new TraceAnnotationVisitor(super.visitAnnotation(name, descriptor), annotationPrinter);
  }

  @Override
  public AnnotationVisitor visitArray(final String name) {
    Printer arrayPrinter = printer.visitArray(name);
    return new TraceAnnotationVisitor(super.visitArray(name), arrayPrinter);
  }

  @Override
  public void visitEnd() {
    printer.visitAnnotationEnd();
    super.visitEnd();
  }
}

package org.objectweb.asm.util;

import java.io.PrintWriter;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.ModuleVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.TypePath;

/**
 * A {@link ClassVisitor} that prints the classes it visits with a {@link Printer}. This class
 * visitor can be used in the middle of a class visitor chain to trace the class that is visited at
 * a given point in this chain. This may be useful for debugging purposes.
 *
 * <p>When used with a {@link Textifier}, the trace printed when visiting the {@code Hello} class is
 * the following:
 *
 * <pre>
 * // class version 49.0 (49) // access flags 0x21 public class Hello {
 *
 * // compiled from: Hello.java
 *
 * // access flags 0x1
 * public &lt;init&gt; ()V
 * ALOAD 0
 * INVOKESPECIAL java/lang/Object &lt;init&gt; ()V
 * RETURN
 * MAXSTACK = 1 MAXLOCALS = 1
 *
 * // access flags 0x9
 * public static main ([Ljava/lang/String;)V
 * GETSTATIC java/lang/System out Ljava/io/PrintStream;
 * LDC &quot;hello&quot;
 * INVOKEVIRTUAL java/io/PrintStream println (Ljava/lang/String;)V
 * RETURN
 * MAXSTACK = 2 MAXLOCALS = 1
 * }
 * </pre>
 *
 * <p>where {@code Hello} is defined by:
 *
 * <pre>
 * public class Hello {
 *
 *   public static void main(String[] args) {
 *     System.out.println(&quot;hello&quot;);
 *   }
 * }
 * </pre>
 *
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
public final class TraceClassVisitor extends ClassVisitor {

  /** The print writer to be used to print the class. May be {@literal null}. */
  private final PrintWriter printWriter;

  /** The printer to convert the visited class into text. */
  // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
  public final Printer p;

  /**
   * Constructs a new {@link TraceClassVisitor}.
   *
   * @param printWriter the print writer to be used to print the class. May be {@literal null}.
   */
  public TraceClassVisitor(final PrintWriter printWriter) {
    this(null, printWriter);
  }

  /**
   * Constructs a new {@link TraceClassVisitor}.
   *
   * @param classVisitor the class visitor to which to delegate calls. May be {@literal null}.
   * @param printWriter the print writer to be used to print the class. May be {@literal null}.
   */
  public TraceClassVisitor(final ClassVisitor classVisitor, final PrintWriter printWriter) {
    this(classVisitor, new Textifier(), printWriter);
  }

  /**
   * Constructs a new {@link TraceClassVisitor}.
   *
   * @param classVisitor the class visitor to which to delegate calls. May be {@literal null}.
   * @param printer the printer to convert the visited class into text.
   * @param printWriter the print writer to be used to print the class. May be {@literal null}.
   */
  public TraceClassVisitor(
      final ClassVisitor classVisitor, final Printer printer, final PrintWriter printWriter) {
    super(/* latest api = */ Opcodes.ASM9, classVisitor);
    this.printWriter = printWriter;
    this.p = printer;
  }

  @Override
  public void visit(
      final int version,
      final int access,
      final String name,
      final String signature,
      final String superName,
      final String[] interfaces) {
    p.visit(version, access, name, signature, superName, interfaces);
    super.visit(version, access, name, signature, superName, interfaces);
  }

  @Override
  public void visitSource(final String file, final String debug) {
    p.visitSource(file, debug);
    super.visitSource(file, debug);
  }

  @Override
  public ModuleVisitor visitModule(final String name, final int flags, final String version) {
    Printer modulePrinter = p.visitModule(name, flags, version);
    return new TraceModuleVisitor(super.visitModule(name, flags, version), modulePrinter);
  }

  @Override
  public void visitNestHost(final String nestHost) {
    p.visitNestHost(nestHost);
    super.visitNestHost(nestHost);
  }

  @Override
  public void visitOuterClass(final @InternalForm String owner, final String name, final String descriptor) {
    p.visitOuterClass(owner, name, descriptor);
    super.visitOuterClass(owner, name, descriptor);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitClassAnnotation(descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitAnnotation(descriptor, visible), annotationPrinter);
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    Printer annotationPrinter = p.visitClassTypeAnnotation(typeRef, typePath, descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitTypeAnnotation(typeRef, typePath, descriptor, visible), annotationPrinter);
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    p.visitClassAttribute(attribute);
    super.visitAttribute(attribute);
  }

  @Override
  public void visitNestMember(final String nestMember) {
    p.visitNestMember(nestMember);
    super.visitNestMember(nestMember);
  }

  @Override
  public void visitPermittedSubclass(final String permittedSubclass) {
    p.visitPermittedSubclass(permittedSubclass);
    super.visitPermittedSubclass(permittedSubclass);
  }

  @Override
  public void visitInnerClass(
      final InternalForm String name, final InternalForm String outerName, final @Identifier String innerName, final int access) {
    p.visitInnerClass(name, outerName, innerName, access);
    super.visitInnerClass(name, outerName, innerName, access);
  }

  @Override
  public RecordComponentVisitor visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    Printer recordComponentPrinter = p.visitRecordComponent(name, descriptor, signature);
    return new TraceRecordComponentVisitor(
        super.visitRecordComponent(name, descriptor, signature), recordComponentPrinter);
  }

  @Override
  public FieldVisitor visitField(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    Printer fieldPrinter = p.visitField(access, name, descriptor, signature, value);
    return new TraceFieldVisitor(
        super.visitField(access, name, descriptor, signature, value), fieldPrinter);
  }

  @Override
  public MethodVisitor visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final String[] exceptions) {
    Printer methodPrinter = p.visitMethod(access, name, descriptor, signature, exceptions);
    return new TraceMethodVisitor(
        super.visitMethod(access, name, descriptor, signature, exceptions), methodPrinter);
  }

  @Override
  public void visitEnd() {
    p.visitClassEnd();
    if (printWriter != null) {
      p.print(printWriter);
      printWriter.flush();
    }
    super.visitEnd();
  }
}

package org.objectweb.asm.util;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.TypePath;

/**
 * A {@link Printer} that prints the ASM code to generate the classes it visits.
 *
 * @author Eric Bruneton
 */
// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
public class ASMifier extends Printer {

  /** The help message shown when command line arguments are incorrect. */
  private static final String USAGE =
      "Prints the ASM code to generate the given class.\n"
          + "Usage: ASMifier [-nodebug] <fully qualified class name or class file name>";

  /** A pseudo access flag used to distinguish class access flags. */
  private static final int ACCESS_CLASS = 0x40000;

  /** A pseudo access flag used to distinguish field access flags. */
  private static final int ACCESS_FIELD = 0x80000;

  /** A pseudo access flag used to distinguish inner class flags. */
  private static final int ACCESS_INNER = 0x100000;

  /** A pseudo access flag used to distinguish module requires / exports flags. */
  private static final int ACCESS_MODULE = 0x200000;

  private static final String ANNOTATION_VISITOR = "annotationVisitor";
  private static final String ANNOTATION_VISITOR0 = "annotationVisitor0 = ";
  private static final String COMMA = "\", \"";
  private static final String END_ARRAY = " });\n";
  private static final String END_PARAMETERS = ");\n\n";
  private static final String NEW_OBJECT_ARRAY = ", new Object[] {";
  private static final String VISIT_END = ".visitEnd();\n";

  private static final List<String> FRAME_TYPES =
      Collections.unmodifiableList(
          Arrays.asList(
              "Opcodes.TOP",
              "Opcodes.INTEGER",
              "Opcodes.FLOAT",
              "Opcodes.DOUBLE",
              "Opcodes.LONG",
              "Opcodes.NULL",
              "Opcodes.UNINITIALIZED_THIS"));

  private static final Map<Integer, String> CLASS_VERSIONS;

  static {
    HashMap<Integer, String> classVersions = new HashMap<>();
    classVersions.put(Opcodes.V1_1, "V1_1");
    classVersions.put(Opcodes.V1_2, "V1_2");
    classVersions.put(Opcodes.V1_3, "V1_3");
    classVersions.put(Opcodes.V1_4, "V1_4");
    classVersions.put(Opcodes.V1_5, "V1_5");
    classVersions.put(Opcodes.V1_6, "V1_6");
    classVersions.put(Opcodes.V1_7, "V1_7");
    classVersions.put(Opcodes.V1_8, "V1_8");
    classVersions.put(Opcodes.V9, "V9");
    classVersions.put(Opcodes.V10, "V10");
    classVersions.put(Opcodes.V11, "V11");
    classVersions.put(Opcodes.V12, "V12");
    classVersions.put(Opcodes.V13, "V13");
    classVersions.put(Opcodes.V14, "V14");
    classVersions.put(Opcodes.V15, "V15");
    classVersions.put(Opcodes.V16, "V16");
    classVersions.put(Opcodes.V17, "V17");
    classVersions.put(Opcodes.V18, "V18");
    classVersions.put(Opcodes.V19, "V19");
    classVersions.put(Opcodes.V20, "V20");
    classVersions.put(Opcodes.V21, "V21");
    classVersions.put(Opcodes.V22, "V22");
    classVersions.put(Opcodes.V23, "V23");
    classVersions.put(Opcodes.V24, "V24");
    CLASS_VERSIONS = Collections.unmodifiableMap(classVersions);
  }

  /** The name of the visitor variable in the produced code. */
  protected final String name;

  /** The identifier of the annotation visitor variable in the produced code. */
  protected final int id;

  /** The name of the Label variables in the produced code. */
  protected Map<Label, String> labelNames;

  /**
   * Constructs a new {@link ASMifier}. <i>Subclasses must not use this constructor</i>. Instead,
   * they must use the {@link #ASMifier(int, String, int)} version.
   *
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public ASMifier() {
    this(/* latest api = */ Opcodes.ASM9, "classWriter", 0);
    if (getClass() != ASMifier.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link ASMifier}.
   *
   * @param api the ASM API version implemented by this class. Must be one of the {@code
   *     ASM}<i>x</i> values in {@link Opcodes}.
   * @param visitorVariableName the name of the visitor variable in the produced code.
   * @param annotationVisitorId identifier of the annotation visitor variable in the produced code.
   */
  protected ASMifier(
      final int api, final String visitorVariableName, final int annotationVisitorId) {
    super(api);
    this.name = visitorVariableName;
    this.id = annotationVisitorId;
  }

  /**
   * Prints the ASM source code to generate the given class to the standard output.
   *
   * <p>Usage: ASMifier [-nodebug] &lt;binary class name or class file name&gt;
   *
   * @param args the command line arguments.
   * @throws IOException if the class cannot be found, or if an IOException occurs.
   */
  public static void main(final String[] args) throws IOException {
    main(args, new PrintWriter(System.out, true), new PrintWriter(System.err, true));
  }

  /**
   * Prints the ASM source code to generate the given class to the given output.
   *
   * <p>Usage: ASMifier [-nodebug] &lt;binary class name or class file name&gt;
   *
   * @param args the command line arguments.
   * @param output where to print the result.
   * @param logger where to log errors.
   * @throws IOException if the class cannot be found, or if an IOException occurs.
   */
  static void main(final String[] args, final PrintWriter output, final PrintWriter logger)
      throws IOException {
    main(args, USAGE, new ASMifier(), output, logger);
  }

  // -----------------------------------------------------------------------------------------------
  // Classes
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visit(
      final int version,
      final int access,
      final String name,
      final String signature,
      final String superName,
      final String[] interfaces) {
    String simpleName;
    if (name == null) {
      simpleName = "module-info";
    } else {
      int lastSlashIndex = name.lastIndexOf('/');
      if (lastSlashIndex == -1) {
        simpleName = name;
      } else {
        text.add("package asm." + name.substring(0, lastSlashIndex).replace('/', '.') + ";\n");
        simpleName = name.substring(lastSlashIndex + 1).replaceAll("[-\\(\\)]", "_");
      }
    }
    text.add("import org.objectweb.asm.AnnotationVisitor;\n");
    text.add("import org.objectweb.asm.Attribute;\n");
    text.add("import org.objectweb.asm.ClassReader;\n");
    text.add("import org.objectweb.asm.ClassWriter;\n");
    text.add("import org.objectweb.asm.ConstantDynamic;\n");
    text.add("import org.objectweb.asm.FieldVisitor;\n");
    text.add("import org.objectweb.asm.Handle;\n");
    text.add("import org.objectweb.asm.Label;\n");
    text.add("import org.objectweb.asm.MethodVisitor;\n");
    text.add("import org.objectweb.asm.Opcodes;\n");
    text.add("import org.objectweb.asm.RecordComponentVisitor;\n");
    text.add("import org.objectweb.asm.Type;\n");
    text.add("import org.objectweb.asm.TypePath;\n");
    text.add("public class " + simpleName + "Dump implements Opcodes {\n\n");
    text.add("public static byte[] dump () throws Exception {\n\n");
    text.add("ClassWriter classWriter = new ClassWriter(0);\n");
    text.add("FieldVisitor fieldVisitor;\n");
    text.add("RecordComponentVisitor recordComponentVisitor;\n");
    text.add("MethodVisitor methodVisitor;\n");
    text.add("AnnotationVisitor annotationVisitor0;\n\n");

    stringBuilder.setLength(0);
    stringBuilder.append("classWriter.visit(");
    String versionString = CLASS_VERSIONS.get(version);
    if (versionString != null) {
      stringBuilder.append(versionString);
    } else {
      stringBuilder.append(version);
    }
    stringBuilder.append(", ");
    appendAccessFlags(access | ACCESS_CLASS);
    stringBuilder.append(", ");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(signature);
    stringBuilder.append(", ");
    appendConstant(superName);
    stringBuilder.append(", ");
    if (interfaces != null && interfaces.length > 0) {
      stringBuilder.append("new String[] {");
      for (int i = 0; i < interfaces.length; ++i) {
        stringBuilder.append(i == 0 ? " " : ", ");
        appendConstant(interfaces[i]);
      }
      stringBuilder.append(" }");
    } else {
      stringBuilder.append("null");
    }
    stringBuilder.append(END_PARAMETERS);
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitSource(final String file, final String debug) {
    stringBuilder.setLength(0);
    stringBuilder.append("classWriter.visitSource(");
    appendConstant(file);
    stringBuilder.append(", ");
    appendConstant(debug);
    stringBuilder.append(END_PARAMETERS);
    text.add(stringBuilder.toString());
  }

  @Override
  public Printer visitModule(final String name, final int flags, final String version) {
    stringBuilder.setLength(0);
    stringBuilder.append("{\n");
    stringBuilder.append("ModuleVisitor moduleVisitor = classWriter.visitModule(");
    appendConstant(name);
    stringBuilder.append(", ");
    appendAccessFlags(flags | ACCESS_MODULE);
    stringBuilder.append(", ");
    appendConstant(version);
    stringBuilder.append(END_PARAMETERS);
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier("moduleVisitor", 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public void visitNestHost(final String nestHost) {
    stringBuilder.setLength(0);
    stringBuilder.append("classWriter.visitNestHost(");
    appendConstant(nestHost);
    stringBuilder.append(END_PARAMETERS);
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitOuterClass(final @InternalForm String owner, final String name, final String descriptor) {
    stringBuilder.setLength(0);
    stringBuilder.append("classWriter.visitOuterClass(");
    appendConstant(owner);
    stringBuilder.append(", ");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(END_PARAMETERS);
    text.add(stringBuilder.toString());
  }

  @Override
  public ASMifier visitClassAnnotation(final String descriptor, final boolean visible) {
    return visitAnnotation(descriptor, visible);
  }

  @Override
  public ASMifier visitClassTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitClassAttribute(final Attribute attribute) {
    visitAttribute(attribute);
  }

  @Override
  public void visitNestMember(final String nestMember) {
    stringBuilder.setLength(0);
    stringBuilder.append("classWriter.visitNestMember(");
    appendConstant(nestMember);
    stringBuilder.append(END_PARAMETERS);
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitPermittedSubclass(final String permittedSubclass) {
    stringBuilder.setLength(0);
    stringBuilder.append("classWriter.visitPermittedSubclass(");
    appendConstant(permittedSubclass);
    stringBuilder.append(END_PARAMETERS);
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitInnerClass(
      final InternalForm String name, final InternalForm String outerName, final @Identifier String innerName, final int access) {
    stringBuilder.setLength(0);
    stringBuilder.append("classWriter.visitInnerClass(");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(outerName);
    stringBuilder.append(", ");
    appendConstant(innerName);
    stringBuilder.append(", ");
    appendAccessFlags(access | ACCESS_INNER);
    stringBuilder.append(END_PARAMETERS);
    text.add(stringBuilder.toString());
  }

  @Override
  public ASMifier visitRecordComponent(
      final String name, final String descriptor, final String signature) {
    stringBuilder.setLength(0);
    stringBuilder.append("{\n");
    stringBuilder.append("recordComponentVisitor = classWriter.visitRecordComponent(");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(", ");
    appendConstant(signature);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier("recordComponentVisitor", 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public ASMifier visitField(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final Object value) {
    stringBuilder.setLength(0);
    stringBuilder.append("{\n");
    stringBuilder.append("fieldVisitor = classWriter.visitField(");
    appendAccessFlags(access | ACCESS_FIELD);
    stringBuilder.append(", ");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(", ");
    appendConstant(signature);
    stringBuilder.append(", ");
    appendConstant(value);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier("fieldVisitor", 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public ASMifier visitMethod(
      final int access,
      final String name,
      final String descriptor,
      final String signature,
      final String[] exceptions) {
    stringBuilder.setLength(0);
    stringBuilder.append("{\n");
    stringBuilder.append("methodVisitor = classWriter.visitMethod(");
    appendAccessFlags(access);
    stringBuilder.append(", ");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(", ");
    appendConstant(signature);
    stringBuilder.append(", ");
    if (exceptions != null && exceptions.length > 0) {
      stringBuilder.append("new String[] {");
      for (int i = 0; i < exceptions.length; ++i) {
        stringBuilder.append(i == 0 ? " " : ", ");
        appendConstant(exceptions[i]);
      }
      stringBuilder.append(" }");
    } else {
      stringBuilder.append("null");
    }
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier("methodVisitor", 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public void visitClassEnd() {
    text.add("classWriter.visitEnd();\n\n");
    text.add("return classWriter.toByteArray();\n");
    text.add("}\n");
    text.add("}\n");
  }

  // -----------------------------------------------------------------------------------------------
  // Modules
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visitMainClass(final String mainClass) {
    stringBuilder.setLength(0);
    stringBuilder.append("moduleVisitor.visitMainClass(");
    appendConstant(mainClass);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitPackage(final String packaze) {
    stringBuilder.setLength(0);
    stringBuilder.append("moduleVisitor.visitPackage(");
    appendConstant(packaze);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitRequire(final String module, final int access, final String version) {
    stringBuilder.setLength(0);
    stringBuilder.append("moduleVisitor.visitRequire(");
    appendConstant(module);
    stringBuilder.append(", ");
    appendAccessFlags(access | ACCESS_MODULE);
    stringBuilder.append(", ");
    appendConstant(version);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitExport(final String packaze, final int access, final String... modules) {
    visitExportOrOpen("moduleVisitor.visitExport(", packaze, access, modules);
  }

  @Override
  public void visitOpen(final String packaze, final int access, final String... modules) {
    visitExportOrOpen("moduleVisitor.visitOpen(", packaze, access, modules);
  }

  private void visitExportOrOpen(
      final String visitMethod, final String packaze, final int access, final String... modules) {
    stringBuilder.setLength(0);
    stringBuilder.append(visitMethod);
    appendConstant(packaze);
    stringBuilder.append(", ");
    appendAccessFlags(access | ACCESS_MODULE);
    if (modules != null && modules.length > 0) {
      stringBuilder.append(", new String[] {");
      for (int i = 0; i < modules.length; ++i) {
        stringBuilder.append(i == 0 ? " " : ", ");
        appendConstant(modules[i]);
      }
      stringBuilder.append(" }");
    }
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitUse(final String service) {
    stringBuilder.setLength(0);
    stringBuilder.append("moduleVisitor.visitUse(");
    appendConstant(service);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitProvide(final String service, final String... providers) {
    stringBuilder.setLength(0);
    stringBuilder.append("moduleVisitor.visitProvide(");
    appendConstant(service);
    stringBuilder.append(",  new String[] {");
    for (int i = 0; i < providers.length; ++i) {
      stringBuilder.append(i == 0 ? " " : ", ");
      appendConstant(providers[i]);
    }
    stringBuilder.append(END_ARRAY);
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitModuleEnd() {
    text.add("moduleVisitor.visitEnd();\n");
  }

  // -----------------------------------------------------------------------------------------------
  // Annotations
  // -----------------------------------------------------------------------------------------------

  // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
  @Override
  public void visit(final String name, final Object value) {
    stringBuilder.setLength(0);
    stringBuilder.append(ANNOTATION_VISITOR).append(id).append(".visit(");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(value);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitEnum(final String name, final String descriptor, final String value) {
    stringBuilder.setLength(0);
    stringBuilder.append(ANNOTATION_VISITOR).append(id).append(".visitEnum(");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(", ");
    appendConstant(value);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public ASMifier visitAnnotation(final String name, final String descriptor) {
    stringBuilder.setLength(0);
    stringBuilder
        .append("{\n")
        .append("AnnotationVisitor annotationVisitor")
        .append(id + 1)
        .append(" = annotationVisitor");
    stringBuilder.append(id).append(".visitAnnotation(");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, id + 1);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public ASMifier visitArray(final String name) {
    stringBuilder.setLength(0);
    stringBuilder.append("{\n");
    stringBuilder
        .append("AnnotationVisitor annotationVisitor")
        .append(id + 1)
        .append(" = annotationVisitor");
    stringBuilder.append(id).append(".visitArray(");
    appendConstant(name);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, id + 1);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public void visitAnnotationEnd() {
    stringBuilder.setLength(0);
    stringBuilder.append(ANNOTATION_VISITOR).append(id).append(VISIT_END);
    text.add(stringBuilder.toString());
  }

  // -----------------------------------------------------------------------------------------------
  // Record components
  // -----------------------------------------------------------------------------------------------

  @Override
  public ASMifier visitRecordComponentAnnotation(final String descriptor, final boolean visible) {
    return visitAnnotation(descriptor, visible);
  }

  @Override
  public ASMifier visitRecordComponentTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitRecordComponentAttribute(final Attribute attribute) {
    visitAttribute(attribute);
  }

  @Override
  public void visitRecordComponentEnd() {
    visitMemberEnd();
  }

  // -----------------------------------------------------------------------------------------------
  // Fields
  // -----------------------------------------------------------------------------------------------

  @Override
  public ASMifier visitFieldAnnotation(final String descriptor, final boolean visible) {
    return visitAnnotation(descriptor, visible);
  }

  @Override
  public ASMifier visitFieldTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitFieldAttribute(final Attribute attribute) {
    visitAttribute(attribute);
  }

  @Override
  public void visitFieldEnd() {
    visitMemberEnd();
  }

  // -----------------------------------------------------------------------------------------------
  // Methods
  // -----------------------------------------------------------------------------------------------

  @Override
  public void visitParameter(final String parameterName, final int access) {
    stringBuilder.setLength(0);
    stringBuilder.append(name).append(".visitParameter(");
    if (parameterName == null) {
      stringBuilder.append("null");
    } else {
      appendString(stringBuilder, parameterName);
    }
    stringBuilder.append(", ");
    appendAccessFlags(access);
    text.add(stringBuilder.append(");\n").toString());
  }

  @Override
  public ASMifier visitAnnotationDefault() {
    stringBuilder.setLength(0);
    stringBuilder
        .append("{\n")
        .append(ANNOTATION_VISITOR0)
        .append(name)
        .append(".visitAnnotationDefault();\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public ASMifier visitMethodAnnotation(final String descriptor, final boolean visible) {
    return visitAnnotation(descriptor, visible);
  }

  @Override
  public ASMifier visitMethodTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation(typeRef, typePath, descriptor, visible);
  }

  @Override
  public ASMifier visitAnnotableParameterCount(final int parameterCount, final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder
        .append(name)
        .append(".visitAnnotableParameterCount(")
        .append(parameterCount)
        .append(", ")
        .append(visible)
        .append(");\n");
    text.add(stringBuilder.toString());
    return this;
  }

  @Override
  public ASMifier visitParameterAnnotation(
      final int parameter, final String descriptor, final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder
        .append("{\n")
        .append(ANNOTATION_VISITOR0)
        .append(name)
        .append(".visitParameterAnnotation(")
        .append(parameter)
        .append(", ");
    appendConstant(descriptor);
    stringBuilder.append(", ").append(visible).append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public void visitMethodAttribute(final Attribute attribute) {
    visitAttribute(attribute);
  }

  @Override
  public void visitCode() {
    text.add(name + ".visitCode();\n");
  }

  @Override
  public void visitFrame(
      final int type,
      final int numLocal,
      final Object[] local,
      final int numStack,
      final Object[] stack) {
    stringBuilder.setLength(0);
    switch (type) {
      case Opcodes.F_NEW:
      case Opcodes.F_FULL:
        declareFrameTypes(numLocal, local);
        declareFrameTypes(numStack, stack);
        if (type == Opcodes.F_NEW) {
          stringBuilder.append(name).append(".visitFrame(Opcodes.F_NEW, ");
        } else {
          stringBuilder.append(name).append(".visitFrame(Opcodes.F_FULL, ");
        }
        stringBuilder.append(numLocal).append(NEW_OBJECT_ARRAY);
        appendFrameTypes(numLocal, local);
        stringBuilder.append("}, ").append(numStack).append(NEW_OBJECT_ARRAY);
        appendFrameTypes(numStack, stack);
        stringBuilder.append('}');
        break;
      case Opcodes.F_APPEND:
        declareFrameTypes(numLocal, local);
        stringBuilder
            .append(name)
            .append(".visitFrame(Opcodes.F_APPEND,")
            .append(numLocal)
            .append(NEW_OBJECT_ARRAY);
        appendFrameTypes(numLocal, local);
        stringBuilder.append("}, 0, null");
        break;
      case Opcodes.F_CHOP:
        stringBuilder
            .append(name)
            .append(".visitFrame(Opcodes.F_CHOP,")
            .append(numLocal)
            .append(", null, 0, null");
        break;
      case Opcodes.F_SAME:
        stringBuilder.append(name).append(".visitFrame(Opcodes.F_SAME, 0, null, 0, null");
        break;
      case Opcodes.F_SAME1:
        declareFrameTypes(1, stack);
        stringBuilder
            .append(name)
            .append(".visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] {");
        appendFrameTypes(1, stack);
        stringBuilder.append('}');
        break;
      default:
        throw new IllegalArgumentException();
    }
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitInsn(final int opcode) {
    stringBuilder.setLength(0);
    stringBuilder.append(name).append(".visitInsn(").append(OPCODES[opcode]).append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitIntInsn(final int opcode, final int operand) {
    stringBuilder.setLength(0);
    stringBuilder
        .append(name)
        .append(".visitIntInsn(")
        .append(OPCODES[opcode])
        .append(", ")
        .append(opcode == Opcodes.NEWARRAY ? TYPES[operand] : Integer.toString(operand))
        .append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitVarInsn(final int opcode, final int varIndex) {
    stringBuilder.setLength(0);
    stringBuilder
        .append(name)
        .append(".visitVarInsn(")
        .append(OPCODES[opcode])
        .append(", ")
        .append(varIndex)
        .append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitTypeInsn(final int opcode, final @InternalForm String type) {
    stringBuilder.setLength(0);
    stringBuilder.append(name).append(".visitTypeInsn(").append(OPCODES[opcode]).append(", ");
    appendConstant(type);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitFieldInsn(
      final int opcode, final @InternalForm String owner, final @Identifier String name, final String descriptor) {
    stringBuilder.setLength(0);
    stringBuilder.append(this.name).append(".visitFieldInsn(").append(OPCODES[opcode]).append(", ");
    appendConstant(owner);
    stringBuilder.append(", ");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitMethodInsn(
      final int opcode,
      final @InternalForm String owner,
      final @Identifier String name,
      final String descriptor,
      final boolean isInterface) {
    stringBuilder.setLength(0);
    stringBuilder
        .append(this.name)
        .append(".visitMethodInsn(")
        .append(OPCODES[opcode])
        .append(", ");
    appendConstant(owner);
    stringBuilder.append(", ");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(", ");
    stringBuilder.append(isInterface ? "true" : "false");
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitInvokeDynamicInsn(
      final String name,
      final String descriptor,
      final Handle bootstrapMethodHandle,
      final Object... bootstrapMethodArguments) {
    stringBuilder.setLength(0);
    stringBuilder.append(this.name).append(".visitInvokeDynamicInsn(");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(", ");
    appendConstant(bootstrapMethodHandle);
    stringBuilder.append(", new Object[]{");
    for (int i = 0; i < bootstrapMethodArguments.length; ++i) {
      appendConstant(bootstrapMethodArguments[i]);
      if (i != bootstrapMethodArguments.length - 1) {
        stringBuilder.append(", ");
      }
    }
    stringBuilder.append("});\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitJumpInsn(final int opcode, final Label label) {
    stringBuilder.setLength(0);
    declareLabel(label);
    stringBuilder.append(name).append(".visitJumpInsn(").append(OPCODES[opcode]).append(", ");
    appendLabel(label);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitLabel(final Label label) {
    stringBuilder.setLength(0);
    declareLabel(label);
    stringBuilder.append(name).append(".visitLabel(");
    appendLabel(label);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitLdcInsn(final Object value) {
    stringBuilder.setLength(0);
    stringBuilder.append(name).append(".visitLdcInsn(");
    appendConstant(value);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitIincInsn(final int varIndex, final int increment) {
    stringBuilder.setLength(0);
    stringBuilder
        .append(name)
        .append(".visitIincInsn(")
        .append(varIndex)
        .append(", ")
        .append(increment)
        .append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitTableSwitchInsn(
      final int min, final int max, final Label dflt, final Label... labels) {
    stringBuilder.setLength(0);
    for (Label label : labels) {
      declareLabel(label);
    }
    declareLabel(dflt);

    stringBuilder
        .append(name)
        .append(".visitTableSwitchInsn(")
        .append(min)
        .append(", ")
        .append(max)
        .append(", ");
    appendLabel(dflt);
    stringBuilder.append(", new Label[] {");
    for (int i = 0; i < labels.length; ++i) {
      stringBuilder.append(i == 0 ? " " : ", ");
      appendLabel(labels[i]);
    }
    stringBuilder.append(END_ARRAY);
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
    stringBuilder.setLength(0);
    for (Label label : labels) {
      declareLabel(label);
    }
    declareLabel(dflt);

    stringBuilder.append(name).append(".visitLookupSwitchInsn(");
    appendLabel(dflt);
    stringBuilder.append(", new int[] {");
    for (int i = 0; i < keys.length; ++i) {
      stringBuilder.append(i == 0 ? " " : ", ").append(keys[i]);
    }
    stringBuilder.append(" }, new Label[] {");
    for (int i = 0; i < labels.length; ++i) {
      stringBuilder.append(i == 0 ? " " : ", ");
      appendLabel(labels[i]);
    }
    stringBuilder.append(END_ARRAY);
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
    stringBuilder.setLength(0);
    stringBuilder.append(name).append(".visitMultiANewArrayInsn(");
    appendConstant(descriptor);
    stringBuilder.append(", ").append(numDimensions).append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public ASMifier visitInsnAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation("visitInsnAnnotation", typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitTryCatchBlock(
      final Label start, final Label end, final Label handler, final @InternalForm String type) {
    stringBuilder.setLength(0);
    declareLabel(start);
    declareLabel(end);
    declareLabel(handler);
    stringBuilder.append(name).append(".visitTryCatchBlock(");
    appendLabel(start);
    stringBuilder.append(", ");
    appendLabel(end);
    stringBuilder.append(", ");
    appendLabel(handler);
    stringBuilder.append(", ");
    appendConstant(type);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public ASMifier visitTryCatchAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation("visitTryCatchAnnotation", typeRef, typePath, descriptor, visible);
  }

  @Override
  public void visitLocalVariable(
      final String name,
      final String descriptor,
      final String signature,
      final Label start,
      final Label end,
      final int index) {
    stringBuilder.setLength(0);
    stringBuilder.append(this.name).append(".visitLocalVariable(");
    appendConstant(name);
    stringBuilder.append(", ");
    appendConstant(descriptor);
    stringBuilder.append(", ");
    appendConstant(signature);
    stringBuilder.append(", ");
    appendLabel(start);
    stringBuilder.append(", ");
    appendLabel(end);
    stringBuilder.append(", ").append(index).append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public Printer visitLocalVariableAnnotation(
      final int typeRef,
      final TypePath typePath,
      final Label[] start,
      final Label[] end,
      final int[] index,
      final String descriptor,
      final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder
        .append("{\n")
        .append(ANNOTATION_VISITOR0)
        .append(name)
        .append(".visitLocalVariableAnnotation(")
        .append(typeRef);
    if (typePath == null) {
      stringBuilder.append(", null, ");
    } else {
      stringBuilder.append(", TypePath.fromString(\"").append(typePath).append("\"), ");
    }
    stringBuilder.append("new Label[] {");
    for (int i = 0; i < start.length; ++i) {
      stringBuilder.append(i == 0 ? " " : ", ");
      appendLabel(start[i]);
    }
    stringBuilder.append(" }, new Label[] {");
    for (int i = 0; i < end.length; ++i) {
      stringBuilder.append(i == 0 ? " " : ", ");
      appendLabel(end[i]);
    }
    stringBuilder.append(" }, new int[] {");
    for (int i = 0; i < index.length; ++i) {
      stringBuilder.append(i == 0 ? " " : ", ").append(index[i]);
    }
    stringBuilder.append(" }, ");
    appendConstant(descriptor);
    stringBuilder.append(", ").append(visible).append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  @Override
  public void visitLineNumber(final int line, final Label start) {
    stringBuilder.setLength(0);
    stringBuilder.append(name).append(".visitLineNumber(").append(line).append(", ");
    appendLabel(start);
    stringBuilder.append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitMaxs(final int maxStack, final int maxLocals) {
    stringBuilder.setLength(0);
    stringBuilder
        .append(name)
        .append(".visitMaxs(")
        .append(maxStack)
        .append(", ")
        .append(maxLocals)
        .append(");\n");
    text.add(stringBuilder.toString());
  }

  @Override
  public void visitMethodEnd() {
    visitMemberEnd();
  }

  // -----------------------------------------------------------------------------------------------
  // Common methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Visits a class, field or method annotation.
   *
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a new {@link ASMifier} to visit the annotation values.
   */
  // DontCheck(OverloadMethodsDeclarationOrder): overloads are semantically different.
  public ASMifier visitAnnotation(final String descriptor, final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder
        .append("{\n")
        .append(ANNOTATION_VISITOR0)
        .append(name)
        .append(".visitAnnotation(");
    appendConstant(descriptor);
    stringBuilder.append(", ").append(visible).append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  /**
   * Visits a class, field or method type annotation.
   *
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link org.objectweb.asm.TypeReference#FIELD}. See {@link org.objectweb.asm.TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a new {@link ASMifier} to visit the annotation values.
   */
  public ASMifier visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    return visitTypeAnnotation("visitTypeAnnotation", typeRef, typePath, descriptor, visible);
  }

  /**
   * Visits a class, field, method, instruction or try catch block type annotation.
   *
   * @param method the name of the visit method for this type of annotation.
   * @param typeRef a reference to the annotated type. The sort of this type reference must be
   *     {@link org.objectweb.asm.TypeReference#FIELD}. See {@link org.objectweb.asm.TypeReference}.
   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or
   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets
   *     'typeRef' as a whole.
   * @param descriptor the class descriptor of the annotation class.
   * @param visible {@literal true} if the annotation is visible at runtime.
   * @return a new {@link ASMifier} to visit the annotation values.
   */
  public ASMifier visitTypeAnnotation(
      final String method,
      final int typeRef,
      final TypePath typePath,
      final String descriptor,
      final boolean visible) {
    stringBuilder.setLength(0);
    stringBuilder
        .append("{\n")
        .append(ANNOTATION_VISITOR0)
        .append(name)
        .append('.')
        .append(method)
        .append('(')
        .append(typeRef);
    if (typePath == null) {
      stringBuilder.append(", null, ");
    } else {
      stringBuilder.append(", TypePath.fromString(\"").append(typePath).append("\"), ");
    }
    appendConstant(descriptor);
    stringBuilder.append(", ").append(visible).append(");\n");
    text.add(stringBuilder.toString());
    ASMifier asmifier = createASMifier(ANNOTATION_VISITOR, 0);
    text.add(asmifier.getText());
    text.add("}\n");
    return asmifier;
  }

  /**
   * Visit a class, field or method attribute.
   *
   * @param attribute an attribute.
   */
  public void visitAttribute(final Attribute attribute) {
    stringBuilder.setLength(0);
    stringBuilder.append("// ATTRIBUTE ").append(attribute.type).append('\n');
    if (attribute instanceof ASMifierSupport) {
      if (labelNames == null) {
        labelNames = new HashMap<>();
      }
      stringBuilder.append("{\n");
      ((ASMifierSupport) attribute).asmify(stringBuilder, "attribute", labelNames);
      stringBuilder.append(name).append(".visitAttribute(attribute);\n");
      stringBuilder.append("}\n");
    }
    text.add(stringBuilder.toString());
  }

  /** Visits the end of a field, record component or method. */
  private void visitMemberEnd() {
    stringBuilder.setLength(0);
    stringBuilder.append(name).append(VISIT_END);
    text.add(stringBuilder.toString());
  }

  // -----------------------------------------------------------------------------------------------
  // Utility methods
  // -----------------------------------------------------------------------------------------------

  /**
   * Constructs a new {@link ASMifier}.
   *
   * @param visitorVariableName the name of the visitor variable in the produced code.
   * @param annotationVisitorId identifier of the annotation visitor variable in the produced code.
   * @return a new {@link ASMifier}.
   */
  // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
  protected ASMifier createASMifier(
      final String visitorVariableName, final int annotationVisitorId) {
    return new ASMifier(api, visitorVariableName, annotationVisitorId);
  }

  /**
   * Appends a string representation of the given access flags to {@link #stringBuilder}.
   *
   * @param accessFlags some access flags.
   */
  private void appendAccessFlags(final int accessFlags) {
    boolean isEmpty = true;
    if ((accessFlags & Opcodes.ACC_PUBLIC) != 0) {
      stringBuilder.append("ACC_PUBLIC");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_PRIVATE) != 0) {
      stringBuilder.append("ACC_PRIVATE");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_PROTECTED) != 0) {
      stringBuilder.append("ACC_PROTECTED");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_FINAL) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_FINAL");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_STATIC) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_STATIC");
      isEmpty = false;
    }
    if ((accessFlags & (Opcodes.ACC_SYNCHRONIZED | Opcodes.ACC_SUPER | Opcodes.ACC_TRANSITIVE))
        != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      if ((accessFlags & ACCESS_CLASS) == 0) {
        if ((accessFlags & ACCESS_MODULE) == 0) {
          stringBuilder.append("ACC_SYNCHRONIZED");
        } else {
          stringBuilder.append("ACC_TRANSITIVE");
        }
      } else {
        stringBuilder.append("ACC_SUPER");
      }
      isEmpty = false;
    }
    if ((accessFlags & (Opcodes.ACC_VOLATILE | Opcodes.ACC_BRIDGE | Opcodes.ACC_STATIC_PHASE))
        != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      if ((accessFlags & ACCESS_FIELD) == 0) {
        if ((accessFlags & ACCESS_MODULE) == 0) {
          stringBuilder.append("ACC_BRIDGE");
        } else {
          stringBuilder.append("ACC_STATIC_PHASE");
        }
      } else {
        stringBuilder.append("ACC_VOLATILE");
      }
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_VARARGS) != 0
        && (accessFlags & (ACCESS_CLASS | ACCESS_FIELD)) == 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_VARARGS");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_TRANSIENT) != 0 && (accessFlags & ACCESS_FIELD) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_TRANSIENT");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_NATIVE) != 0
        && (accessFlags & (ACCESS_CLASS | ACCESS_FIELD)) == 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_NATIVE");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_ENUM) != 0
        && (accessFlags & (ACCESS_CLASS | ACCESS_FIELD | ACCESS_INNER)) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_ENUM");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_ANNOTATION) != 0
        && (accessFlags & (ACCESS_CLASS | ACCESS_INNER)) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_ANNOTATION");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_ABSTRACT) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_ABSTRACT");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_INTERFACE) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_INTERFACE");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_STRICT) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_STRICT");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_SYNTHETIC");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_DEPRECATED");
      isEmpty = false;
    }
    if ((accessFlags & Opcodes.ACC_RECORD) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      stringBuilder.append("ACC_RECORD");
      isEmpty = false;
    }
    if ((accessFlags & (Opcodes.ACC_MANDATED | Opcodes.ACC_MODULE)) != 0) {
      if (!isEmpty) {
        stringBuilder.append(" | ");
      }
      if ((accessFlags & ACCESS_CLASS) == 0) {
        stringBuilder.append("ACC_MANDATED");
      } else {
        stringBuilder.append("ACC_MODULE");
      }
      isEmpty = false;
    }
    if (isEmpty) {
      stringBuilder.append('0');
    }
  }

  /**
   * Appends a string representation of the given constant to {@link #stringBuilder}.
   *
   * @param value a {@link String}, {@link Type}, {@link Handle}, {@link Byte}, {@link Short},
   *     {@link Character}, {@link Integer}, {@link Float}, {@link Long} or {@link Double} object,
   *     or an array of primitive values. May be {@literal null}.
   */
  protected void appendConstant(final Object value) {
    if (value == null) {
      stringBuilder.append("null");
    } else if (value instanceof String) {
      appendString(stringBuilder, (String) value);
    } else if (value instanceof Type) {
      stringBuilder.append("Type.getType(\"");
      stringBuilder.append(((Type) value).getDescriptor());
      stringBuilder.append("\")");
    } else if (value instanceof Handle) {
      stringBuilder.append("new Handle(");
      Handle handle = (Handle) value;
      stringBuilder.append("Opcodes.").append(HANDLE_TAG[handle.getTag()]).append(", \"");
      stringBuilder.append(handle.getOwner()).append(COMMA);
      stringBuilder.append(handle.getName()).append(COMMA);
      stringBuilder.append(handle.getDesc()).append("\", ");
      stringBuilder.append(handle.isInterface()).append(')');
    } else if (value instanceof ConstantDynamic) {
      stringBuilder.append("new ConstantDynamic(\"");
      ConstantDynamic constantDynamic = (ConstantDynamic) value;
      stringBuilder.append(constantDynamic.getName()).append(COMMA);
      stringBuilder.append(constantDynamic.getDescriptor()).append("\", ");
      appendConstant(constantDynamic.getBootstrapMethod());
      stringBuilder.append(NEW_OBJECT_ARRAY);
      int bootstrapMethodArgumentCount = constantDynamic.getBootstrapMethodArgumentCount();
      for (int i = 0; i < bootstrapMethodArgumentCount; ++i) {
        appendConstant(constantDynamic.getBootstrapMethodArgument(i));
        if (i != bootstrapMethodArgumentCount - 1) {
          stringBuilder.append(", ");
        }
      }
      stringBuilder.append("})");
    } else if (value instanceof Byte) {
      stringBuilder.append("new Byte((byte)").append(value).append(')');
    } else if (value instanceof Boolean) {
      stringBuilder.append(((Boolean) value).booleanValue() ? "Boolean.TRUE" : "Boolean.FALSE");
    } else if (value instanceof Short) {
      stringBuilder.append("new Short((short)").append(value).append(')');
    } else if (value instanceof Character) {
      stringBuilder
          .append("new Character((char)")
          .append((int) ((Character) value).charValue())
          .append(')');
    } else if (value instanceof Integer) {
      stringBuilder.append("new Integer(").append(value).append(')');
    } else if (value instanceof Float) {
      stringBuilder.append("new Float(\"").append(value).append("\")");
    } else if (value instanceof Long) {
      stringBuilder.append("new Long(").append(value).append("L)");
    } else if (value instanceof Double) {
      stringBuilder.append("new Double(\"").append(value).append("\")");
    } else if (value instanceof byte[]) {
      byte[] byteArray = (byte[]) value;
      stringBuilder.append("new byte[] {");
      for (int i = 0; i < byteArray.length; i++) {
        stringBuilder.append(i == 0 ? "" : ",").append(byteArray[i]);
      }
      stringBuilder.append('}');
    } else if (value instanceof boolean[]) {
      boolean[] booleanArray = (boolean[]) value;
      stringBuilder.append("new boolean[] {");
      for (int i = 0; i < booleanArray.length; i++) {
        stringBuilder.append(i == 0 ? "" : ",").append(booleanArray[i]);
      }
      stringBuilder.append('}');
    } else if (value instanceof short[]) {
      short[] shortArray = (short[]) value;
      stringBuilder.append("new short[] {");
      for (int i = 0; i < shortArray.length; i++) {
        stringBuilder.append(i == 0 ? "" : ",").append("(short)").append(shortArray[i]);
      }
      stringBuilder.append('}');
    } else if (value instanceof char[]) {
      char[] charArray = (char[]) value;
      stringBuilder.append("new char[] {");
      for (int i = 0; i < charArray.length; i++) {
        stringBuilder.append(i == 0 ? "" : ",").append("(char)").append((int) charArray[i]);
      }
      stringBuilder.append('}');
    } else if (value instanceof int[]) {
      int[] intArray = (int[]) value;
      stringBuilder.append("new int[] {");
      for (int i = 0; i < intArray.length; i++) {
        stringBuilder.append(i == 0 ? "" : ",").append(intArray[i]);
      }
      stringBuilder.append('}');
    } else if (value instanceof long[]) {
      long[] longArray = (long[]) value;
      stringBuilder.append("new long[] {");
      for (int i = 0; i < longArray.length; i++) {
        stringBuilder.append(i == 0 ? "" : ",").append(longArray[i]).append('L');
      }
      stringBuilder.append('}');
    } else if (value instanceof float[]) {
      float[] floatArray = (float[]) value;
      stringBuilder.append("new float[] {");
      for (int i = 0; i < floatArray.length; i++) {
        stringBuilder.append(i == 0 ? "" : ",").append(floatArray[i]).append('f');
      }
      stringBuilder.append('}');
    } else if (value instanceof double[]) {
      double[] doubleArray = (double[]) value;
      stringBuilder.append("new double[] {");
      for (int i = 0; i < doubleArray.length; i++) {
        stringBuilder.append(i == 0 ? "" : ",").append(doubleArray[i]).append('d');
      }
      stringBuilder.append('}');
    }
  }

  /**
   * Calls {@link #declareLabel} for each label in the given stack map frame types.
   *
   * @param numTypes the number of stack map frame types in 'frameTypes'.
   * @param frameTypes an array of stack map frame types, in the format described in {@link
   *     org.objectweb.asm.MethodVisitor#visitFrame}.
   */
  private void declareFrameTypes(final int numTypes, final Object[] frameTypes) {
    for (int i = 0; i < numTypes; ++i) {
      if (frameTypes[i] instanceof Label) {
        declareLabel((Label) frameTypes[i]);
      }
    }
  }

  /**
   * Appends the given stack map frame types to {@link #stringBuilder}.
   *
   * @param numTypes the number of stack map frame types in 'frameTypes'.
   * @param frameTypes an array of stack map frame types, in the format described in {@link
   *     org.objectweb.asm.MethodVisitor#visitFrame}.
   */
  private void appendFrameTypes(final int numTypes, final Object[] frameTypes) {
    for (int i = 0; i < numTypes; ++i) {
      if (i > 0) {
        stringBuilder.append(", ");
      }
      if (frameTypes[i] instanceof String) {
        appendConstant(frameTypes[i]);
      } else if (frameTypes[i] instanceof Integer) {
        stringBuilder.append(FRAME_TYPES.get(((Integer) frameTypes[i]).intValue()));
      } else {
        appendLabel((Label) frameTypes[i]);
      }
    }
  }

  /**
   * Appends a declaration of the given label to {@link #stringBuilder}. This declaration is of the
   * form "Label labelXXX = new Label();". Does nothing if the given label has already been
   * declared.
   *
   * @param label a label.
   */
  protected void declareLabel(final Label label) {
    if (labelNames == null) {
      labelNames = new HashMap<>();
    }
    String labelName = labelNames.get(label);
    if (labelName == null) {
      labelName = "label" + labelNames.size();
      labelNames.put(label, labelName);
      stringBuilder.append("Label ").append(labelName).append(" = new Label();\n");
    }
  }

  /**
   * Appends the name of the given label to {@link #stringBuilder}. The given label <i>must</i>
   * already have a name. One way to ensure this is to always call {@link #declareLabel} before
   * calling this method.
   *
   * @param label a label.
   */
  protected void appendLabel(final Label label) {
    stringBuilder.append(labelNames.get(label));
  }
}
/**
 * ASM: a very small and fast Java bytecode manipulation framework Copyright (c) 2000-2011 INRIA,
 * France Telecom All rights reserved.
 *
 * <p>Redistribution and use in source and binary forms, with or without modification, are permitted
 * provided that the following conditions are met: 1. Redistributions of source code must retain the
 * above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions
 * in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its contributors may be used to
 * endorse or promote products derived from this software without specific prior written permission.
 *
 * <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.objectweb.asm.util;

import java.util.Map;
import org.objectweb.asm.Label;

/**
 * An {@link org.objectweb.asm.Attribute} that can generate the ASM code to create an equivalent
 * attribute.
 *
 * @author Eugene Kuleshov
 */
// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
public interface ASMifierSupport {

  /**
   * Generates the ASM code to create an attribute equal to this attribute.
   *
   * @param outputBuilder where the generated code must be appended.
   * @param visitorVariableName the name of the visitor variable in the produced code.
   * @param labelNames the names of the labels in the generated code.
   */
  void asmify(
      StringBuilder outputBuilder, String visitorVariableName, Map<Label, String> labelNames);
}

package org.objectweb.asm.util;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.signature.SignatureVisitor;

/**
 * A {@link SignatureVisitor} that builds the Java generic type declaration corresponding to the
 * signature it visits.
 *
 * @author Eugene Kuleshov
 * @author Eric Bruneton
 */
public final class TraceSignatureVisitor extends SignatureVisitor {

  private static final String COMMA_SEPARATOR = ", ";
  private static final String EXTENDS_SEPARATOR = " extends ";
  private static final String IMPLEMENTS_SEPARATOR = " implements ";

  private static final Map<Character, String> BASE_TYPES;

  static {
    HashMap<Character, String> baseTypes = new HashMap<>();
    baseTypes.put('Z', "boolean");
    baseTypes.put('B', "byte");
    baseTypes.put('C', "char");
    baseTypes.put('S', "short");
    baseTypes.put('I', "int");
    baseTypes.put('J', "long");
    baseTypes.put('F', "float");
    baseTypes.put('D', "double");
    baseTypes.put('V', "void");
    BASE_TYPES = Collections.unmodifiableMap(baseTypes);
  }

  /** Whether the visited signature is a class signature of a Java interface. */
  private final boolean isInterface;

  /** The Java generic type declaration corresponding to the visited signature. */
  private final StringBuilder declaration;

  /** The Java generic method return type declaration corresponding to the visited signature. */
  private StringBuilder returnType;

  /** The Java generic exception types declaration corresponding to the visited signature. */
  private StringBuilder exceptions;

  /** Whether {@link #visitFormalTypeParameter} has been called. */
  private boolean formalTypeParameterVisited;

  /** Whether {@link #visitInterfaceBound} has been called. */
  private boolean interfaceBoundVisited;

  /** Whether {@link #visitParameterType} has been called. */
  private boolean parameterTypeVisited;

  /** Whether {@link #visitInterface} has been called. */
  private boolean interfaceVisited;

  /**
   * The stack used to keep track of class types that have arguments. Each element of this stack is
   * a boolean encoded in one bit. The top of the stack is the least significant bit. Pushing false
   * = *2, pushing true = *2+1, popping = /2.
   */
  private int argumentStack;

  /**
   * The stack used to keep track of array class types. Each element of this stack is a boolean
   * encoded in one bit. The top of the stack is the lowest order bit. Pushing false = *2, pushing
   * true = *2+1, popping = /2.
   */
  private int arrayStack;

  /** The separator to append before the next visited class or inner class type. */
  private String separator = "";

  /**
   * Constructs a new {@link TraceSignatureVisitor}.
   *
   * @param accessFlags for class type signatures, the access flags of the class.
   */
  public TraceSignatureVisitor(final int accessFlags) {
    super(/* latest api = */ Opcodes.ASM9);
    this.isInterface = (accessFlags & Opcodes.ACC_INTERFACE) != 0;
    this.declaration = new StringBuilder();
  }

  private TraceSignatureVisitor(final StringBuilder stringBuilder) {
    super(/* latest api = */ Opcodes.ASM9);
    this.isInterface = false;
    this.declaration = stringBuilder;
  }

  @Override
  public void visitFormalTypeParameter(final String name) {
    declaration.append(formalTypeParameterVisited ? COMMA_SEPARATOR : "<").append(name);
    formalTypeParameterVisited = true;
    interfaceBoundVisited = false;
  }

  @Override
  public SignatureVisitor visitClassBound() {
    separator = EXTENDS_SEPARATOR;
    startType();
    return this;
  }

  @Override
  public SignatureVisitor visitInterfaceBound() {
    separator = interfaceBoundVisited ? COMMA_SEPARATOR : EXTENDS_SEPARATOR;
    interfaceBoundVisited = true;
    startType();
    return this;
  }

  @Override
  public SignatureVisitor visitSuperclass() {
    endFormals();
    separator = EXTENDS_SEPARATOR;
    startType();
    return this;
  }

  @Override
  public SignatureVisitor visitInterface() {
    if (interfaceVisited) {
      separator = COMMA_SEPARATOR;
    } else {
      separator = isInterface ? EXTENDS_SEPARATOR : IMPLEMENTS_SEPARATOR;
      interfaceVisited = true;
    }
    startType();
    return this;
  }

  @Override
  public SignatureVisitor visitParameterType() {
    endFormals();
    if (parameterTypeVisited) {
      declaration.append(COMMA_SEPARATOR);
    } else {
      declaration.append('(');
      parameterTypeVisited = true;
    }
    startType();
    return this;
  }

  @Override
  public SignatureVisitor visitReturnType() {
    endFormals();
    if (parameterTypeVisited) {
      parameterTypeVisited = false;
    } else {
      declaration.append('(');
    }
    declaration.append(')');
    returnType = new StringBuilder();
    return new TraceSignatureVisitor(returnType);
  }

  @Override
  public SignatureVisitor visitExceptionType() {
    if (exceptions == null) {
      exceptions = new StringBuilder();
    } else {
      exceptions.append(COMMA_SEPARATOR);
    }
    return new TraceSignatureVisitor(exceptions);
  }

  @Override
  public void visitBaseType(final char descriptor) {
    String baseType = BASE_TYPES.get(descriptor);
    if (baseType == null) {
      throw new IllegalArgumentException();
    }
    declaration.append(baseType);
    endType();
  }

  @Override
  public void visitTypeVariable(final String name) {
    declaration.append(separator).append(name);
    separator = "";
    endType();
  }

  @Override
  public SignatureVisitor visitArrayType() {
    startType();
    arrayStack |= 1;
    return this;
  }

  @Override
  public void visitClassType(final String name) {
    if ("java/lang/Object".equals(name)) {
      // 'Map<java.lang.Object,java.util.List>' or 'abstract public V get(Object key);' should have
      // Object 'but java.lang.String extends java.lang.Object' is unnecessary.
      boolean needObjectClass = argumentStack % 2 != 0 || parameterTypeVisited;
      if (needObjectClass) {
        declaration.append(separator).append(name.replace('/', '.'));
      }
    } else {
      declaration.append(separator).append(name.replace('/', '.'));
    }
    separator = "";
    argumentStack *= 2;
  }

  @Override
  public void visitInnerClassType(final String name) {
    if (argumentStack % 2 != 0) {
      declaration.append('>');
    }
    argumentStack /= 2;
    declaration.append('.');
    declaration.append(separator).append(name.replace('/', '.'));
    separator = "";
    argumentStack *= 2;
  }

  @Override
  public void visitTypeArgument() {
    if (argumentStack % 2 == 0) {
      ++argumentStack;
      declaration.append('<');
    } else {
      declaration.append(COMMA_SEPARATOR);
    }
    declaration.append('?');
  }

  @Override
  public SignatureVisitor visitTypeArgument(final char tag) {
    if (argumentStack % 2 == 0) {
      ++argumentStack;
      declaration.append('<');
    } else {
      declaration.append(COMMA_SEPARATOR);
    }

    if (tag == EXTENDS) {
      declaration.append("? extends ");
    } else if (tag == SUPER) {
      declaration.append("? super ");
    }

    startType();
    return this;
  }

  @Override
  public void visitEnd() {
    if (argumentStack % 2 != 0) {
      declaration.append('>');
    }
    argumentStack /= 2;
    endType();
  }

  // -----------------------------------------------------------------------------------------------

  /**
   * Returns the Java generic type declaration corresponding to the visited signature.
   *
   * @return the Java generic type declaration corresponding to the visited signature.
   */
  public String getDeclaration() {
    return declaration.toString();
  }

  /**
   * Returns the Java generic method return type declaration corresponding to the visited signature.
   *
   * @return the Java generic method return type declaration corresponding to the visited signature.
   */
  public String getReturnType() {
    return returnType == null ? null : returnType.toString();
  }

  /**
   * Returns the Java generic exception types declaration corresponding to the visited signature.
   *
   * @return the Java generic exception types declaration corresponding to the visited signature.
   */
  public String getExceptions() {
    return exceptions == null ? null : exceptions.toString();
  }

  // -----------------------------------------------------------------------------------------------

  private void endFormals() {
    if (formalTypeParameterVisited) {
      declaration.append('>');
      formalTypeParameterVisited = false;
    }
  }

  private void startType() {
    arrayStack *= 2;
  }

  private void endType() {
    if (arrayStack % 2 == 0) {
      arrayStack /= 2;
    } else {
      while (arrayStack % 2 != 0) {
        arrayStack /= 2;
        declaration.append("[]");
      }
    }
  }
}

package org.objectweb.asm.util;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.TypePath;

/**
 * A {@link RecordComponentVisitor} that prints the record components it visits with a {@link
 * Printer}.
 *
 * @author Remi Forax
 */
public final class TraceRecordComponentVisitor extends RecordComponentVisitor {

  /** The printer to convert the visited record component into text. */
  public final Printer printer;

  /**
   * Constructs a new {@link TraceRecordComponentVisitor}.
   *
   * @param printer the printer to convert the visited record component into text.
   */
  public TraceRecordComponentVisitor(final Printer printer) {
    this(null, printer);
  }

  /**
   * Constructs a new {@link TraceRecordComponentVisitor}.
   *
   * @param recordComponentVisitor the record component visitor to which to delegate calls. May be
   *     {@literal null}.
   * @param printer the printer to convert the visited record component into text.
   */
  public TraceRecordComponentVisitor(
      final RecordComponentVisitor recordComponentVisitor, final Printer printer) {
    super(/* latest api ='*/ Opcodes.ASM9, recordComponentVisitor);
    this.printer = printer;
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    Printer annotationPrinter = printer.visitRecordComponentAnnotation(descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitAnnotation(descriptor, visible), annotationPrinter);
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    Printer annotationPrinter =
        printer.visitRecordComponentTypeAnnotation(typeRef, typePath, descriptor, visible);
    return new TraceAnnotationVisitor(
        super.visitTypeAnnotation(typeRef, typePath, descriptor, visible), annotationPrinter);
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    printer.visitRecordComponentAttribute(attribute);
    super.visitAttribute(attribute);
  }

  @Override
  public void visitEnd() {
    printer.visitRecordComponentEnd();
    super.visitEnd();
  }
}
/**
 * ASM: a very small and fast Java bytecode manipulation framework Copyright (c) 2000-2011 INRIA,
 * France Telecom All rights reserved.
 *
 * <p>Redistribution and use in source and binary forms, with or without modification, are permitted
 * provided that the following conditions are met: 1. Redistributions of source code must retain the
 * above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions
 * in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its contributors may be used to
 * endorse or promote products derived from this software without specific prior written permission.
 *
 * <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.objectweb.asm.util;

import java.util.Map;
import org.objectweb.asm.Label;

/**
 * An {@link org.objectweb.asm.Attribute} that can print a readable representation of itself.
 *
 * @author Eugene Kuleshov
 */
public interface TextifierSupport {

  /**
   * Generates a human readable representation of this attribute.
   *
   * @param outputBuilder where the human representation of this attribute must be appended.
   * @param labelNames the human readable names of the labels.
   */
  void textify(StringBuilder outputBuilder, Map<Label, String> labelNames);
}

package org.objectweb.asm.util;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.RecordComponentVisitor;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.TypeReference;

/**
 * A {@link RecordComponentVisitor} that checks that its methods are properly used.
 *
 * @author Eric Bruneton
 * @author Remi Forax
 */
public class CheckRecordComponentAdapter extends RecordComponentVisitor {

  /** Whether the {@link #visitEnd()} method has been called. */
  private boolean visitEndCalled;

  /**
   * Constructs a new {@link CheckRecordComponentAdapter}. <i>Subclasses must not use this
   * constructor</i>. Instead, they must use the {@link #CheckRecordComponentAdapter(int,
   * RecordComponentVisitor)} version.
   *
   * @param recordComponentVisitor the record component visitor to which this adapter must delegate
   *     calls.
   * @throws IllegalStateException If a subclass calls this constructor.
   */
  public CheckRecordComponentAdapter(final RecordComponentVisitor recordComponentVisitor) {
    this(/* latest api =*/ Opcodes.ASM9, recordComponentVisitor);
    if (getClass() != CheckRecordComponentAdapter.class) {
      throw new IllegalStateException();
    }
  }

  /**
   * Constructs a new {@link CheckRecordComponentAdapter}.
   *
   * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM8}
   *     or {@link Opcodes#ASM9}.
   * @param recordComponentVisitor the record component visitor to which this adapter must delegate
   *     calls.
   */
  protected CheckRecordComponentAdapter(
      final int api, final RecordComponentVisitor recordComponentVisitor) {
    super(api, recordComponentVisitor);
  }

  @Override
  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
    checkVisitEndNotCalled();
    // Annotations can only appear in V1_5 or more classes.
    CheckMethodAdapter.checkDescriptor(Opcodes.V1_5, descriptor, false);
    return new CheckAnnotationAdapter(super.visitAnnotation(descriptor, visible));
  }

  @Override
  public AnnotationVisitor visitTypeAnnotation(
      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
    checkVisitEndNotCalled();
    int sort = new TypeReference(typeRef).getSort();
    if (sort != TypeReference.FIELD) {
      throw new IllegalArgumentException(
          "Invalid type reference sort 0x" + Integer.toHexString(sort));
    }
    CheckClassAdapter.checkTypeRef(typeRef);
    CheckMethodAdapter.checkDescriptor(Opcodes.V1_5, descriptor, false);
    return new CheckAnnotationAdapter(
        super.visitTypeAnnotation(typeRef, typePath, descriptor, visible));
  }

  @Override
  public void visitAttribute(final Attribute attribute) {
    checkVisitEndNotCalled();
    if (attribute == null) {
      throw new IllegalArgumentException("Invalid attribute (must not be null)");
    }
    super.visitAttribute(attribute);
  }

  @Override
  public void visitEnd() {
    checkVisitEndNotCalled();
    visitEndCalled = true;
    super.visitEnd();
  }

  private void checkVisitEndNotCalled() {
    if (visitEndCalled) {
      throw new IllegalStateException("Cannot call a visit method after visitEnd has been called");
    }
  }
}
